diff -ruN SDL-1.2.13/Makefile SDL-1.2.13_OOx64/Makefile
--- SDL-1.2.13/Makefile	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile	2017-12-20 13:11:43 +0000
@@ -0,0 +1,184 @@
+# Makefile to build and install the SDL library
+
+top_builddir = .
+srcdir  = .
+objects = build
+depend	= build-deps
+prefix = /mingw/../devlibs
+exec_prefix = ${prefix}
+bindir	= ${exec_prefix}/bin
+libdir  = ${exec_prefix}/lib
+includedir = ${prefix}/include
+datarootdir = ${prefix}/share
+datadir	= ${datarootdir}
+mandir	= ${datarootdir}/man
+auxdir	= ./build-scripts
+distpath = $(srcdir)/..
+distdir = SDL-1.2.13
+distfile = $(distdir).tar.gz
+
+
+SHELL	= /bin/sh
+CC      = gcc
+INCLUDE = -I./include
+CFLAGS  = -g -O2 -I/mingw/../devlibs/include
+#-I/mingw/../devlibs/dx9sdk/include
+EXTRA_CFLAGS = -I./include -D_GNU_SOURCE=1
+LDFLAGS = -L/mingw/../devlibs/lib
+# -L/mingw/../devlibs/dx9sdk/lib
+EXTRA_LDFLAGS =  -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid -ldxerr8 -ldinput8 -lole32
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+INSTALL = /bin/install -c
+NASM	= /mingw/bin/nasm -f win64 -I ./src/hermes/
+AR	= ar
+RANLIB	= ranlib
+WINDRES	= windres
+
+TARGET  = libSDL.la
+SOURCES =  ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/haptic/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/haptic/win32/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc
+OBJECTS = $(objects)/SDL_HelperWindow.lo $(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_haptic.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_syshaptic.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o
+
+SDLMAIN_TARGET = libSDLmain.a
+SDLMAIN_SOURCES = ./src/main/win32/*.c
+SDLMAIN_OBJECTS = $(objects)/SDL_win32_main.o
+
+DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
+
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_haptic.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+
+LT_AGE      = 11
+LT_CURRENT  = 11
+LT_RELEASE  = 1.2
+LT_REVISION = 2
+LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+
+$(srcdir)/configure: $(srcdir)/configure.in
+	@echo "Warning, configure.in is out of date"
+	#(cd $(srcdir) && sh autogen.sh && sh configure)
+	@sleep 3
+
+Makefile: $(srcdir)/Makefile.in
+	$(SHELL) config.status $@
+
+$(objects):
+	$(SHELL) $(auxdir)/mkinstalldirs $@
+
+.PHONY: all depend install install-bin install-hdrs install-lib install-data install-man uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man clean distclean dist
+depend:
+	@SOURCES="$(SOURCES)" INCLUDE="$(INCLUDE)" output="$(depend)" \
+	$(SHELL) $(auxdir)/makedep.sh
+	@for src in $(SDLMAIN_SOURCES); do \
+	    obj=`echo $$src | sed -e 's|.*/||' -e 's|\.[^\.]*$$|.o|'`; \
+	    echo "\$$(objects)/$$obj: $$src" >>$(depend); \
+	    echo "	\$$(CC) \$$(CFLAGS) \$$(EXTRA_CFLAGS) -c $$src -o \$$@" >>$(depend); \
+	done
+
+include $(depend)
+
+$(objects)/$(TARGET): $(OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+
+$(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
+	$(AR) cru $@ $(SDLMAIN_OBJECTS)
+	$(RANLIB) $@
+
+install: all install-bin install-hdrs install-lib install-data install-man
+install-bin:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(INSTALL) -m 755 sdl-config $(DESTDIR)$(bindir)/sdl-config
+install-hdrs:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(includedir)/SDL
+	for file in $(HDRS); do \
+	    $(INSTALL) -m 644 $(srcdir)/include/$$file $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	$(INSTALL) -m 644 include/SDL_config.h $(DESTDIR)$(includedir)/SDL/SDL_config.h
+install-lib: $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(DESTDIR)$(libdir)/$(TARGET)
+	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+install-data:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(datadir)/aclocal
+	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(DESTDIR)$(datadir)/aclocal/sdl.m4
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(DESTDIR)$(libdir)/pkgconfig
+install-man:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(mandir)/man3
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    $(INSTALL) -m 644 $$src $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+uninstall: uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man
+uninstall-bin:
+	rm -f $(DESTDIR)$(bindir)/sdl-config
+uninstall-hdrs:
+	for file in $(HDRS); do \
+	    rm -f $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	rm -f $(DESTDIR)$(includedir)/SDL/SDL_config.h
+	-rmdir $(DESTDIR)$(includedir)/SDL
+uninstall-lib:
+	$(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$(TARGET)
+	rm -f $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+uninstall-data:
+	rm -f $(DESTDIR)$(datadir)/aclocal/sdl.m4
+uninstall-man:
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    rm -f $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+clean:
+	rm -rf $(objects)
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+distclean: clean
+	rm -f Makefile include/SDL_config.h sdl-config
+	rm -f SDL.qpg
+	rm -f config.status config.cache config.log libtool $(depend)
+	rm -rf $(srcdir)/autom4te*
+	rm -rf $(srcdir)/test/autom4te*
+	find $(srcdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	cp $(srcdir)/include/SDL_config.h.default $(srcdir)/include/SDL_config.h
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+dist $(distfile):
+	$(SHELL) $(auxdir)/mkinstalldirs $(distdir)
+	tar cf - $(DIST) | (cd $(distdir); tar xf -)
+	cp $(distdir)/include/SDL_config.h.default $(distdir)/include/SDL_config.h
+	rm -rf `find $(distdir) -name .svn`
+	rm -rf $(distdir)/test/autom4te*
+	find $(distdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	if test -f $(distdir)/test/Makefile; then (cd $(distdir)/test && make distclean); fi
+	tar cvf - $(distdir) | gzip --best >$(distfile)
+	rm -rf $(distdir)
+
+rpm: $(distfile)
+	rpmbuild -ta $?
+
+# Create a SVN snapshot that people can run update on
+snapshot:
+	svn co http://svn.libsdl.org/branches/SDL-1.2
+	(cd SDL-1.2 && ./autogen.sh && rm -rf autom4te.cache)
+	cp SDL-1.2/include/SDL_config.h.default SDL-1.2/include/SDL_config.h
+	tar zcf $(HOME)/SDL-1.2.tar.gz SDL-1.2
+	rm -f $(HOME)/SDL-1.2.zip
+	zip -r $(HOME)/SDL-1.2.zip SDL-1.2
+	rm -rf SDL-1.2
diff -ruN SDL-1.2.13/Makefile.bak SDL-1.2.13_OOx64/Makefile.bak
--- SDL-1.2.13/Makefile.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile.bak	2017-12-19 14:35:35 +0000
@@ -0,0 +1,182 @@
+# Makefile to build and install the SDL library
+
+top_builddir = .
+srcdir  = .
+objects = build
+depend	= build-deps
+prefix = /mingw/../devlibs
+exec_prefix = ${prefix}
+bindir	= ${exec_prefix}/bin
+libdir  = ${exec_prefix}/lib
+includedir = ${prefix}/include
+datarootdir = ${prefix}/share
+datadir	= ${datarootdir}
+mandir	= ${datarootdir}/man
+auxdir	= ./build-scripts
+distpath = $(srcdir)/..
+distdir = SDL-1.2.13
+distfile = $(distdir).tar.gz
+
+
+SHELL	= /bin/sh
+CC      = gcc
+INCLUDE = -I./include
+CFLAGS  = -g -O2 -I/mingw/../devlibs/include -I/mingw/../devlibs/dx9sdk/include 
+EXTRA_CFLAGS = -I./include -D_GNU_SOURCE=1
+LDFLAGS = -L/mingw/../devlibs/lib
+EXTRA_LDFLAGS =  -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid -ldxerr8 -ldinput8 -lole32
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+INSTALL = /bin/install -c
+NASM	= /mingw/bin/nasm -f win64 -I ./src/hermes/
+AR	= ar
+RANLIB	= ranlib
+WINDRES	= windres
+
+TARGET  = libSDL.la
+SOURCES =  ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/haptic/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/haptic/win32/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc
+OBJECTS = $(objects)/SDL_HelperWindow.lo $(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_haptic.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_syshaptic.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o
+
+SDLMAIN_TARGET = libSDLmain.a
+SDLMAIN_SOURCES = ./src/main/win32/*.c
+SDLMAIN_OBJECTS = $(objects)/SDL_win32_main.o
+
+DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
+
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_haptic.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+
+LT_AGE      = 11
+LT_CURRENT  = 11
+LT_RELEASE  = 1.2
+LT_REVISION = 2
+LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+
+$(srcdir)/configure: $(srcdir)/configure.in
+	@echo "Warning, configure.in is out of date"
+	#(cd $(srcdir) && sh autogen.sh && sh configure)
+	@sleep 3
+
+Makefile: $(srcdir)/Makefile.in
+	$(SHELL) config.status $@
+
+$(objects):
+	$(SHELL) $(auxdir)/mkinstalldirs $@
+
+.PHONY: all depend install install-bin install-hdrs install-lib install-data install-man uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man clean distclean dist
+depend:
+	@SOURCES="$(SOURCES)" INCLUDE="$(INCLUDE)" output="$(depend)" \
+	$(SHELL) $(auxdir)/makedep.sh
+	@for src in $(SDLMAIN_SOURCES); do \
+	    obj=`echo $$src | sed -e 's|.*/||' -e 's|\.[^\.]*$$|.o|'`; \
+	    echo "\$$(objects)/$$obj: $$src" >>$(depend); \
+	    echo "	\$$(CC) \$$(CFLAGS) \$$(EXTRA_CFLAGS) -c $$src -o \$$@" >>$(depend); \
+	done
+
+include $(depend)
+
+$(objects)/$(TARGET): $(OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+
+$(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
+	$(AR) cru $@ $(SDLMAIN_OBJECTS)
+	$(RANLIB) $@
+
+install: all install-bin install-hdrs install-lib install-data install-man
+install-bin:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(INSTALL) -m 755 sdl-config $(DESTDIR)$(bindir)/sdl-config
+install-hdrs:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(includedir)/SDL
+	for file in $(HDRS); do \
+	    $(INSTALL) -m 644 $(srcdir)/include/$$file $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	$(INSTALL) -m 644 include/SDL_config.h $(DESTDIR)$(includedir)/SDL/SDL_config.h
+install-lib: $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(DESTDIR)$(libdir)/$(TARGET)
+	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+install-data:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(datadir)/aclocal
+	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(DESTDIR)$(datadir)/aclocal/sdl.m4
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(DESTDIR)$(libdir)/pkgconfig
+install-man:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(mandir)/man3
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    $(INSTALL) -m 644 $$src $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+uninstall: uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man
+uninstall-bin:
+	rm -f $(DESTDIR)$(bindir)/sdl-config
+uninstall-hdrs:
+	for file in $(HDRS); do \
+	    rm -f $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	rm -f $(DESTDIR)$(includedir)/SDL/SDL_config.h
+	-rmdir $(DESTDIR)$(includedir)/SDL
+uninstall-lib:
+	$(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$(TARGET)
+	rm -f $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+uninstall-data:
+	rm -f $(DESTDIR)$(datadir)/aclocal/sdl.m4
+uninstall-man:
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    rm -f $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+clean:
+	rm -rf $(objects)
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+distclean: clean
+	rm -f Makefile include/SDL_config.h sdl-config
+	rm -f SDL.qpg
+	rm -f config.status config.cache config.log libtool $(depend)
+	rm -rf $(srcdir)/autom4te*
+	rm -rf $(srcdir)/test/autom4te*
+	find $(srcdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	cp $(srcdir)/include/SDL_config.h.default $(srcdir)/include/SDL_config.h
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+dist $(distfile):
+	$(SHELL) $(auxdir)/mkinstalldirs $(distdir)
+	tar cf - $(DIST) | (cd $(distdir); tar xf -)
+	cp $(distdir)/include/SDL_config.h.default $(distdir)/include/SDL_config.h
+	rm -rf `find $(distdir) -name .svn`
+	rm -rf $(distdir)/test/autom4te*
+	find $(distdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	if test -f $(distdir)/test/Makefile; then (cd $(distdir)/test && make distclean); fi
+	tar cvf - $(distdir) | gzip --best >$(distfile)
+	rm -rf $(distdir)
+
+rpm: $(distfile)
+	rpmbuild -ta $?
+
+# Create a SVN snapshot that people can run update on
+snapshot:
+	svn co http://svn.libsdl.org/branches/SDL-1.2
+	(cd SDL-1.2 && ./autogen.sh && rm -rf autom4te.cache)
+	cp SDL-1.2/include/SDL_config.h.default SDL-1.2/include/SDL_config.h
+	tar zcf $(HOME)/SDL-1.2.tar.gz SDL-1.2
+	rm -f $(HOME)/SDL-1.2.zip
+	zip -r $(HOME)/SDL-1.2.zip SDL-1.2
+	rm -rf SDL-1.2
diff -ruN SDL-1.2.13/Makefile.in SDL-1.2.13_OOx64/Makefile.in
--- SDL-1.2.13/Makefile.in	2007-12-31 05:09:33 +0000
+++ SDL-1.2.13_OOx64/Makefile.in	2017-12-18 11:47:34 +0000
@@ -42,7 +42,7 @@
 
 DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
 
-HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_haptic.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
 
 LT_AGE      = @LT_AGE@
 LT_CURRENT  = @LT_CURRENT@
diff -ruN SDL-1.2.13/Makefile.in.beforeHaptic SDL-1.2.13_OOx64/Makefile.in.beforeHaptic
--- SDL-1.2.13/Makefile.in.beforeHaptic	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile.in.beforeHaptic	2007-12-30 19:09:34 +0000
@@ -0,0 +1,182 @@
+# Makefile to build and install the SDL library
+
+top_builddir = .
+srcdir  = @srcdir@
+objects = build
+depend	= build-deps
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+bindir	= @bindir@
+libdir  = @libdir@
+includedir = @includedir@
+datarootdir = @datarootdir@
+datadir	= @datadir@
+mandir	= @mandir@
+auxdir	= @ac_aux_dir@
+distpath = $(srcdir)/..
+distdir = SDL-@SDL_VERSION@
+distfile = $(distdir).tar.gz
+
+@SET_MAKE@
+SHELL	= @SHELL@
+CC      = @CC@
+INCLUDE = @INCLUDE@
+CFLAGS  = @BUILD_CFLAGS@
+EXTRA_CFLAGS = @EXTRA_CFLAGS@
+LDFLAGS = @BUILD_LDFLAGS@
+EXTRA_LDFLAGS = @EXTRA_LDFLAGS@
+LIBTOOL = @LIBTOOL@
+INSTALL = @INSTALL@
+NASM	= @NASM@ @NASMFLAGS@
+AR	= @AR@
+RANLIB	= @RANLIB@
+WINDRES	= @WINDRES@
+
+TARGET  = libSDL.la
+SOURCES = @SOURCES@
+OBJECTS = @OBJECTS@
+
+SDLMAIN_TARGET = libSDLmain.a
+SDLMAIN_SOURCES = @SDLMAIN_SOURCES@
+SDLMAIN_OBJECTS = @SDLMAIN_OBJECTS@
+
+DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
+
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+
+LT_AGE      = @LT_AGE@
+LT_CURRENT  = @LT_CURRENT@
+LT_RELEASE  = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+
+$(srcdir)/configure: $(srcdir)/configure.in
+	@echo "Warning, configure.in is out of date"
+	#(cd $(srcdir) && sh autogen.sh && sh configure)
+	@sleep 3
+
+Makefile: $(srcdir)/Makefile.in
+	$(SHELL) config.status $@
+
+$(objects):
+	$(SHELL) $(auxdir)/mkinstalldirs $@
+
+.PHONY: all depend install install-bin install-hdrs install-lib install-data install-man uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man clean distclean dist
+depend:
+	@SOURCES="$(SOURCES)" INCLUDE="$(INCLUDE)" output="$(depend)" \
+	$(SHELL) $(auxdir)/makedep.sh
+	@for src in $(SDLMAIN_SOURCES); do \
+	    obj=`echo $$src | sed -e 's|.*/||' -e 's|\.[^\.]*$$|.o|'`; \
+	    echo "\$$(objects)/$$obj: $$src" >>$(depend); \
+	    echo "	\$$(CC) \$$(CFLAGS) \$$(EXTRA_CFLAGS) -c $$src -o \$$@" >>$(depend); \
+	done
+
+include $(depend)
+
+$(objects)/$(TARGET): $(OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+
+$(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
+	$(AR) cru $@ $(SDLMAIN_OBJECTS)
+	$(RANLIB) $@
+
+install: all install-bin install-hdrs install-lib install-data install-man
+install-bin:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(INSTALL) -m 755 sdl-config $(DESTDIR)$(bindir)/sdl-config
+install-hdrs:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(includedir)/SDL
+	for file in $(HDRS); do \
+	    $(INSTALL) -m 644 $(srcdir)/include/$$file $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	$(INSTALL) -m 644 include/SDL_config.h $(DESTDIR)$(includedir)/SDL/SDL_config.h
+install-lib: $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(DESTDIR)$(libdir)/$(TARGET)
+	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+install-data:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(datadir)/aclocal
+	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(DESTDIR)$(datadir)/aclocal/sdl.m4
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(DESTDIR)$(libdir)/pkgconfig
+install-man:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(mandir)/man3
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    $(INSTALL) -m 644 $$src $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+uninstall: uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man
+uninstall-bin:
+	rm -f $(DESTDIR)$(bindir)/sdl-config
+uninstall-hdrs:
+	for file in $(HDRS); do \
+	    rm -f $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	rm -f $(DESTDIR)$(includedir)/SDL/SDL_config.h
+	-rmdir $(DESTDIR)$(includedir)/SDL
+uninstall-lib:
+	$(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$(TARGET)
+	rm -f $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+uninstall-data:
+	rm -f $(DESTDIR)$(datadir)/aclocal/sdl.m4
+uninstall-man:
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    rm -f $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+clean:
+	rm -rf $(objects)
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+distclean: clean
+	rm -f Makefile include/SDL_config.h sdl-config
+	rm -f SDL.qpg
+	rm -f config.status config.cache config.log libtool $(depend)
+	rm -rf $(srcdir)/autom4te*
+	rm -rf $(srcdir)/test/autom4te*
+	find $(srcdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	cp $(srcdir)/include/SDL_config.h.default $(srcdir)/include/SDL_config.h
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+dist $(distfile):
+	$(SHELL) $(auxdir)/mkinstalldirs $(distdir)
+	tar cf - $(DIST) | (cd $(distdir); tar xf -)
+	cp $(distdir)/include/SDL_config.h.default $(distdir)/include/SDL_config.h
+	rm -rf `find $(distdir) -name .svn`
+	rm -rf $(distdir)/test/autom4te*
+	find $(distdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	if test -f $(distdir)/test/Makefile; then (cd $(distdir)/test && make distclean); fi
+	tar cvf - $(distdir) | gzip --best >$(distfile)
+	rm -rf $(distdir)
+
+rpm: $(distfile)
+	rpmbuild -ta $?
+
+# Create a SVN snapshot that people can run update on
+snapshot:
+	svn co http://svn.libsdl.org/branches/SDL-1.2
+	(cd SDL-1.2 && ./autogen.sh && rm -rf autom4te.cache)
+	cp SDL-1.2/include/SDL_config.h.default SDL-1.2/include/SDL_config.h
+	tar zcf $(HOME)/SDL-1.2.tar.gz SDL-1.2
+	rm -f $(HOME)/SDL-1.2.zip
+	zip -r $(HOME)/SDL-1.2.zip SDL-1.2
+	rm -rf SDL-1.2
diff -ruN SDL-1.2.13/Makefile.minimal SDL-1.2.13_OOx64/Makefile.minimal
--- SDL-1.2.13/Makefile.minimal	2007-12-31 04:48:39 +0000
+++ SDL-1.2.13_OOx64/Makefile.minimal	2017-12-20 15:18:45 +0000
@@ -15,6 +15,7 @@
 	src/events/*.c \
 	src/file/*.c \
 	src/joystick/*.c \
+	src/haptic/*.c \
 	src/stdlib/*.c \
 	src/thread/*.c \
 	src/timer/*.c \
@@ -22,6 +23,7 @@
 	src/audio/dummy/*.c \
 	src/video/dummy/*.c \
 	src/joystick/dummy/*.c \
+	src/haptic/dummy/*.c \
 	src/cdrom/dummy/*.c \
 	src/thread/generic/*.c \
 	src/timer/dummy/*.c \
diff -ruN SDL-1.2.13/Makefile.minimal.bak SDL-1.2.13_OOx64/Makefile.minimal.bak
--- SDL-1.2.13/Makefile.minimal.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile.minimal.bak	2007-12-30 18:48:40 +0000
@@ -0,0 +1,42 @@
+# Makefile to build the SDL library
+
+INCLUDE = -I./include
+CFLAGS  = -g -O2 $(INCLUDE)
+AR	= ar
+RANLIB	= ranlib
+
+CONFIG_H = include/SDL_config.h
+TARGET  = libSDL.a
+SOURCES = \
+	src/*.c \
+	src/audio/*.c \
+	src/cdrom/*.c \
+	src/cpuinfo/*.c \
+	src/events/*.c \
+	src/file/*.c \
+	src/joystick/*.c \
+	src/stdlib/*.c \
+	src/thread/*.c \
+	src/timer/*.c \
+	src/video/*.c \
+	src/audio/dummy/*.c \
+	src/video/dummy/*.c \
+	src/joystick/dummy/*.c \
+	src/cdrom/dummy/*.c \
+	src/thread/generic/*.c \
+	src/timer/dummy/*.c \
+	src/loadso/dummy/*.c \
+
+OBJECTS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g')
+
+all: $(TARGET)
+
+$(TARGET): $(CONFIG_H) $(OBJECTS)
+	$(AR) crv $@ $^
+	$(RANLIB) $@
+
+$(CONFIG_H):
+	cp $(CONFIG_H).default $(CONFIG_H)
+
+clean:
+	rm -f $(TARGET) $(OBJECTS)
diff -ruN SDL-1.2.13/Makefile.minimal.beforeHaptic SDL-1.2.13_OOx64/Makefile.minimal.beforeHaptic
--- SDL-1.2.13/Makefile.minimal.beforeHaptic	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile.minimal.beforeHaptic	2017-10-09 21:48:02 +0000
@@ -0,0 +1,42 @@
+# Makefile to build the SDL library
+
+INCLUDE = -I./include
+CFLAGS  = -g -O2 $(INCLUDE)
+AR	= ar
+RANLIB	= ranlib
+
+CONFIG_H = include/SDL_config.h
+TARGET  = libSDL.a
+SOURCES = \
+	src/*.c \
+	src/audio/*.c \
+	src/cdrom/*.c \
+	src/cpuinfo/*.c \
+	src/events/*.c \
+	src/file/*.c \
+	src/joystick/*.c \
+	src/stdlib/*.c \
+	src/thread/*.c \
+	src/timer/*.c \
+	src/video/*.c \
+	src/audio/dummy/*.c \
+	src/video/dummy/*.c \
+	src/joystick/dummy/*.c \
+	src/cdrom/dummy/*.c \
+	src/thread/generic/*.c \
+	src/timer/dummy/*.c \
+	src/loadso/dummy/*.c \
+
+OBJECTS = $(shell echo $(SOURCES) | sed -e 's,\.c,\.o,g')
+
+all: $(TARGET)
+
+$(TARGET): $(CONFIG_H) $(OBJECTS)
+	$(AR) crv $@ $^
+	$(RANLIB) $@
+
+$(CONFIG_H):
+	cp $(CONFIG_H).default $(CONFIG_H)
+
+clean:
+	rm -f $(TARGET) $(OBJECTS)
diff -ruN SDL-1.2.13/Makefile.original SDL-1.2.13_OOx64/Makefile.original
--- SDL-1.2.13/Makefile.original	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile.original	2009-02-08 10:09:34 +0000
@@ -0,0 +1,182 @@
+# Makefile to build and install the SDL library
+
+top_builddir = .
+srcdir  = .
+objects = build
+depend	= build-deps
+prefix = /usr/local
+exec_prefix = ${prefix}
+bindir	= ${exec_prefix}/bin
+libdir  = ${exec_prefix}/lib
+includedir = ${prefix}/include
+datarootdir = ${prefix}/share
+datadir	= ${datarootdir}
+mandir	= ${datarootdir}/man
+auxdir	= ./build-scripts
+distpath = $(srcdir)/..
+distdir = SDL-1.2.13
+distfile = $(distdir).tar.gz
+
+
+SHELL	= /bin/sh
+CC      = gcc
+INCLUDE = -I./include
+CFLAGS  = -g -O2 
+EXTRA_CFLAGS = -I./include -D_GNU_SOURCE=1
+LDFLAGS = 
+EXTRA_LDFLAGS =  -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+INSTALL = /bin/install -c
+NASM	= /mingw/bin/nasm -f win32 -I ./src/hermes/
+AR	= ar
+RANLIB	= ranlib
+WINDRES	= windres
+
+TARGET  = libSDL.la
+SOURCES =  ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc
+OBJECTS = $(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o
+
+SDLMAIN_TARGET = libSDLmain.a
+SDLMAIN_SOURCES = ./src/main/win32/*.c
+SDLMAIN_OBJECTS = $(objects)/SDL_win32_main.o
+
+DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
+
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+
+LT_AGE      = 11
+LT_CURRENT  = 11
+LT_RELEASE  = 1.2
+LT_REVISION = 2
+LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+
+$(srcdir)/configure: $(srcdir)/configure.in
+	@echo "Warning, configure.in is out of date"
+	#(cd $(srcdir) && sh autogen.sh && sh configure)
+	@sleep 3
+
+Makefile: $(srcdir)/Makefile.in
+	$(SHELL) config.status $@
+
+$(objects):
+	$(SHELL) $(auxdir)/mkinstalldirs $@
+
+.PHONY: all depend install install-bin install-hdrs install-lib install-data install-man uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man clean distclean dist
+depend:
+	@SOURCES="$(SOURCES)" INCLUDE="$(INCLUDE)" output="$(depend)" \
+	$(SHELL) $(auxdir)/makedep.sh
+	@for src in $(SDLMAIN_SOURCES); do \
+	    obj=`echo $$src | sed -e 's|.*/||' -e 's|\.[^\.]*$$|.o|'`; \
+	    echo "\$$(objects)/$$obj: $$src" >>$(depend); \
+	    echo "	\$$(CC) \$$(CFLAGS) \$$(EXTRA_CFLAGS) -c $$src -o \$$@" >>$(depend); \
+	done
+
+include $(depend)
+
+$(objects)/$(TARGET): $(OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+
+$(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
+	$(AR) cru $@ $(SDLMAIN_OBJECTS)
+	$(RANLIB) $@
+
+install: all install-bin install-hdrs install-lib install-data install-man
+install-bin:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(INSTALL) -m 755 sdl-config $(DESTDIR)$(bindir)/sdl-config
+install-hdrs:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(includedir)/SDL
+	for file in $(HDRS); do \
+	    $(INSTALL) -m 644 $(srcdir)/include/$$file $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	$(INSTALL) -m 644 include/SDL_config.h $(DESTDIR)$(includedir)/SDL/SDL_config.h
+install-lib: $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(DESTDIR)$(libdir)/$(TARGET)
+	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+install-data:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(datadir)/aclocal
+	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(DESTDIR)$(datadir)/aclocal/sdl.m4
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(DESTDIR)$(libdir)/pkgconfig
+install-man:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(mandir)/man3
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    $(INSTALL) -m 644 $$src $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+uninstall: uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man
+uninstall-bin:
+	rm -f $(DESTDIR)$(bindir)/sdl-config
+uninstall-hdrs:
+	for file in $(HDRS); do \
+	    rm -f $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	rm -f $(DESTDIR)$(includedir)/SDL/SDL_config.h
+	-rmdir $(DESTDIR)$(includedir)/SDL
+uninstall-lib:
+	$(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$(TARGET)
+	rm -f $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+uninstall-data:
+	rm -f $(DESTDIR)$(datadir)/aclocal/sdl.m4
+uninstall-man:
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    rm -f $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+clean:
+	rm -rf $(objects)
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+distclean: clean
+	rm -f Makefile include/SDL_config.h sdl-config
+	rm -f SDL.qpg
+	rm -f config.status config.cache config.log libtool $(depend)
+	rm -rf $(srcdir)/autom4te*
+	rm -rf $(srcdir)/test/autom4te*
+	find $(srcdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	cp $(srcdir)/include/SDL_config.h.default $(srcdir)/include/SDL_config.h
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+dist $(distfile):
+	$(SHELL) $(auxdir)/mkinstalldirs $(distdir)
+	tar cf - $(DIST) | (cd $(distdir); tar xf -)
+	cp $(distdir)/include/SDL_config.h.default $(distdir)/include/SDL_config.h
+	rm -rf `find $(distdir) -name .svn`
+	rm -rf $(distdir)/test/autom4te*
+	find $(distdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	if test -f $(distdir)/test/Makefile; then (cd $(distdir)/test && make distclean); fi
+	tar cvf - $(distdir) | gzip --best >$(distfile)
+	rm -rf $(distdir)
+
+rpm: $(distfile)
+	rpmbuild -ta $?
+
+# Create a SVN snapshot that people can run update on
+snapshot:
+	svn co http://svn.libsdl.org/branches/SDL-1.2
+	(cd SDL-1.2 && ./autogen.sh && rm -rf autom4te.cache)
+	cp SDL-1.2/include/SDL_config.h.default SDL-1.2/include/SDL_config.h
+	tar zcf $(HOME)/SDL-1.2.tar.gz SDL-1.2
+	rm -f $(HOME)/SDL-1.2.zip
+	zip -r $(HOME)/SDL-1.2.zip SDL-1.2
+	rm -rf SDL-1.2
diff -ruN SDL-1.2.13/Makefile____orig SDL-1.2.13_OOx64/Makefile____orig
--- SDL-1.2.13/Makefile____orig	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/Makefile____orig	2012-04-23 09:18:52 +0000
@@ -0,0 +1,182 @@
+# Makefile to build and install the SDL library
+
+top_builddir = .
+srcdir  = .
+objects = build
+depend	= build-deps
+prefix = /usr/local
+exec_prefix = ${prefix}
+bindir	= ${exec_prefix}/bin
+libdir  = ${exec_prefix}/lib
+includedir = ${prefix}/include
+datarootdir = ${prefix}/share
+datadir	= ${datarootdir}
+mandir	= ${datarootdir}/man
+auxdir	= ./build-scripts
+distpath = $(srcdir)/..
+distdir = SDL-1.2.13
+distfile = $(distdir).tar.gz
+
+
+SHELL	= /bin/sh
+CC      = gcc
+INCLUDE = -I./include
+CFLAGS  = -g -O2 
+EXTRA_CFLAGS = -I./include -D_GNU_SOURCE=1
+LDFLAGS = 
+EXTRA_LDFLAGS =  -L/usr/local/lib -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+INSTALL = /bin/install -c
+NASM	= /mingw/bin/nasm -f win32 -I ./src/hermes/
+AR	= ar
+RANLIB	= ranlib
+WINDRES	= windres
+
+TARGET  = libSDL.la
+SOURCES =  ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc
+OBJECTS = $(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o
+
+SDLMAIN_TARGET = libSDLmain.a
+SDLMAIN_SOURCES = ./src/main/win32/*.c
+SDLMAIN_OBJECTS = $(objects)/SDL_win32_main.o
+
+DIST = acinclude.m4 autogen.sh Borland.html Borland.zip BUGS build-scripts configure configure.in COPYING CREDITS CWprojects.sea.bin docs docs.html include INSTALL Makefile.dc Makefile.minimal Makefile.in MPWmake.sea.bin README* sdl-config.in sdl.m4 sdl.pc.in SDL.qpg.in SDL.spec SDL.spec.in src test TODO VisualCE.zip VisualC.html VisualC.zip Watcom-OS2.zip Watcom-Win32.zip symbian.zip WhatsNew Xcode.tar.gz
+
+HDRS = SDL.h SDL_active.h SDL_audio.h SDL_byteorder.h SDL_cdrom.h SDL_cpuinfo.h SDL_endian.h SDL_error.h SDL_events.h SDL_getenv.h SDL_joystick.h SDL_keyboard.h SDL_keysym.h SDL_loadso.h SDL_main.h SDL_mouse.h SDL_mutex.h SDL_name.h SDL_opengl.h SDL_platform.h SDL_quit.h SDL_rwops.h SDL_stdinc.h SDL_syswm.h SDL_thread.h SDL_timer.h SDL_types.h SDL_version.h SDL_video.h begin_code.h close_code.h
+
+LT_AGE      = 11
+LT_CURRENT  = 11
+LT_RELEASE  = 1.2
+LT_REVISION = 2
+LT_LDFLAGS  = -no-undefined -rpath $(DESTDIR)$(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+
+$(srcdir)/configure: $(srcdir)/configure.in
+	@echo "Warning, configure.in is out of date"
+	#(cd $(srcdir) && sh autogen.sh && sh configure)
+	@sleep 3
+
+Makefile: $(srcdir)/Makefile.in
+	$(SHELL) config.status $@
+
+$(objects):
+	$(SHELL) $(auxdir)/mkinstalldirs $@
+
+.PHONY: all depend install install-bin install-hdrs install-lib install-data install-man uninstall uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man clean distclean dist
+depend:
+	@SOURCES="$(SOURCES)" INCLUDE="$(INCLUDE)" output="$(depend)" \
+	$(SHELL) $(auxdir)/makedep.sh
+	@for src in $(SDLMAIN_SOURCES); do \
+	    obj=`echo $$src | sed -e 's|.*/||' -e 's|\.[^\.]*$$|.o|'`; \
+	    echo "\$$(objects)/$$obj: $$src" >>$(depend); \
+	    echo "	\$$(CC) \$$(CFLAGS) \$$(EXTRA_CFLAGS) -c $$src -o \$$@" >>$(depend); \
+	done
+
+include $(depend)
+
+$(objects)/$(TARGET): $(OBJECTS)
+	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
+
+$(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
+	$(AR) cru $@ $(SDLMAIN_OBJECTS)
+	$(RANLIB) $@
+
+install: all install-bin install-hdrs install-lib install-data install-man
+install-bin:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(INSTALL) -m 755 sdl-config $(DESTDIR)$(bindir)/sdl-config
+install-hdrs:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(includedir)/SDL
+	for file in $(HDRS); do \
+	    $(INSTALL) -m 644 $(srcdir)/include/$$file $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	$(INSTALL) -m 644 include/SDL_config.h $(DESTDIR)$(includedir)/SDL/SDL_config.h
+install-lib: $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(DESTDIR)$(libdir)/$(TARGET)
+	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+	$(RANLIB) $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+install-data:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(datadir)/aclocal
+	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(DESTDIR)$(datadir)/aclocal/sdl.m4
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(DESTDIR)$(libdir)/pkgconfig
+install-man:
+	$(SHELL) $(auxdir)/mkinstalldirs $(DESTDIR)$(mandir)/man3
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    $(INSTALL) -m 644 $$src $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+uninstall: uninstall-bin uninstall-hdrs uninstall-lib uninstall-data uninstall-man
+uninstall-bin:
+	rm -f $(DESTDIR)$(bindir)/sdl-config
+uninstall-hdrs:
+	for file in $(HDRS); do \
+	    rm -f $(DESTDIR)$(includedir)/SDL/$$file; \
+	done
+	rm -f $(DESTDIR)$(includedir)/SDL/SDL_config.h
+	-rmdir $(DESTDIR)$(includedir)/SDL
+uninstall-lib:
+	$(LIBTOOL) --mode=uninstall rm -f $(DESTDIR)$(libdir)/$(TARGET)
+	rm -f $(DESTDIR)$(libdir)/$(SDLMAIN_TARGET)
+uninstall-data:
+	rm -f $(DESTDIR)$(datadir)/aclocal/sdl.m4
+uninstall-man:
+	for src in $(srcdir)/docs/man3/*.3; do \
+	    file=`echo $$src | sed -e 's|^.*/||'`; \
+	    rm -f $(DESTDIR)$(mandir)/man3/$$file; \
+	done
+
+clean:
+	rm -rf $(objects)
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+distclean: clean
+	rm -f Makefile include/SDL_config.h sdl-config
+	rm -f SDL.qpg
+	rm -f config.status config.cache config.log libtool $(depend)
+	rm -rf $(srcdir)/autom4te*
+	rm -rf $(srcdir)/test/autom4te*
+	find $(srcdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	cp $(srcdir)/include/SDL_config.h.default $(srcdir)/include/SDL_config.h
+	if test -f test/Makefile; then (cd test; $(MAKE) $@); fi
+
+dist $(distfile):
+	$(SHELL) $(auxdir)/mkinstalldirs $(distdir)
+	tar cf - $(DIST) | (cd $(distdir); tar xf -)
+	cp $(distdir)/include/SDL_config.h.default $(distdir)/include/SDL_config.h
+	rm -rf `find $(distdir) -name .svn`
+	rm -rf $(distdir)/test/autom4te*
+	find $(distdir) \( \
+	    -name '*~' -o \
+	    -name '*.bak' -o \
+	    -name '*.old' -o \
+	    -name '*.rej' -o \
+	    -name '*.orig' -o \
+	    -name '.#*' \) \
+	    -exec rm -f {} \;
+	if test -f $(distdir)/test/Makefile; then (cd $(distdir)/test && make distclean); fi
+	tar cvf - $(distdir) | gzip --best >$(distfile)
+	rm -rf $(distdir)
+
+rpm: $(distfile)
+	rpmbuild -ta $?
+
+# Create a SVN snapshot that people can run update on
+snapshot:
+	svn co http://svn.libsdl.org/branches/SDL-1.2
+	(cd SDL-1.2 && ./autogen.sh && rm -rf autom4te.cache)
+	cp SDL-1.2/include/SDL_config.h.default SDL-1.2/include/SDL_config.h
+	tar zcf $(HOME)/SDL-1.2.tar.gz SDL-1.2
+	rm -f $(HOME)/SDL-1.2.zip
+	zip -r $(HOME)/SDL-1.2.zip SDL-1.2
+	rm -rf SDL-1.2
diff -ruN SDL-1.2.13/SDL.qpg SDL-1.2.13_OOx64/SDL.qpg
--- SDL-1.2.13/SDL.qpg	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/SDL.qpg	2013-10-03 18:42:36 +0000
@@ -0,0 +1,140 @@
+<QPG:Generation>
+   <QPG:Options>
+      <QPG:User unattended="yes" verbosity="0" listfiles="yes"/>
+      <QPG:Defaults type="qnx_package"/>
+      <QPG:Source></QPG:Source>
+      <QPG:Release date="today" number="+"/>
+      <QPG:Build></QPG:Build>
+      <QPG:FileSorting strip="yes"/>
+      <QPG:Package targets="standart"/>
+      <QPG:Repository generate="yes"/>
+      <QPG:FinalDir></QPG:FinalDir>
+      <QPG:Cleanup></QPG:Cleanup>
+   </QPG:Options>
+
+   <QPG:Responsible>
+      <QPG:Company>QNX.ORG.RU Community</QPG:Company>
+      <QPG:Department></QPG:Department>
+      <QPG:Group></QPG:Group>
+      <QPG:Team>QNX.ORG.RU Team</QPG:Team>
+      <QPG:Employee>Mike Gorchak</QPG:Employee>
+      <QPG:EmailAddress>mike@malva.ua</QPG:EmailAddress>
+   </QPG:Responsible>
+
+   <QPG:Values>
+      <QPG:Files>
+         <QPG:Add file="./COPYING" install="LicenseUrl/" handling="repdata"/>
+         <QPG:Add permissions="0755" file="./src/.libs/libSDL-1.2.so.11" install="/usr/lib/"/>
+         <QPG:Add filetype="symlink" file="libSDL.so" install="/usr/lib/" linkto="libSDL-1.2.so.11"/>
+         <QPG:Add permissions="0644" file="./src/.libs/libSDL.a" install="/usr/lib/"/>
+         <QPG:Add permissions="0644" file="./src/.libs/libSDL.lai" install="/usr/lib/libSDL.la"/>
+         <QPG:Add permissions="0644" file="./src/main/libSDLmain.a" install="/usr/lib/"/>
+         <QPG:Add permissions="0644" file="./include/*.h" install="/usr/include/SDL/"/>
+         <QPG:Add permissions="0755" file="./sdl-config" install="/usr/bin/"/>
+         <QPG:Add permissions="0644" file="./BUGS" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./COPYING" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./CREDITS" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./INSTALL" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./README" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./README-SDL.txt" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./README.CVS" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./README.QNX" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./TODO" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./WhatsNew" install="/usr/share/doc/SDL12/"/>
+         <QPG:Add permissions="0644" file="./docs.html" install="/usr/share/doc/SDL12/Changes.html"/>
+         <QPG:Add permissions="0644" file="./docs/index.html" install="/usr/share/doc/SDL12/docs/"/>
+         <QPG:Add permissions="0644" file="./docs/html/*.html" install="/usr/share/doc/SDL12/docs/html/"/>
+         <QPG:Add permissions="0644" file="./docs/man3/*.3" install="/usr/share/man/man3/"/>
+         <QPG:Add permissions="0644" file="./sdl.m4" install="/usr/share/aclocal/"/>
+      </QPG:Files>
+      <QPG:PackageFilter>
+         <QPM:PackageManifest>
+
+            <QPM:PackageDescription>
+               <QPM:PackageType>Library</QPM:PackageType>
+               <QPM:PackageName>SDL</QPM:PackageName>
+               <QPM:PackageReleaseNumber>1</QPM:PackageReleaseNumber>
+               <QPM:PackageRepository>http://qnx.org.ru/repository</QPM:PackageRepository>
+               <QPM:FileVersion>2.6</QPM:FileVersion>
+            </QPM:PackageDescription>
+
+            <QPM:ProductDescription>
+               <QPM:ProductName>Simple DirectMedia Layer (SDL)</QPM:ProductName>
+               <QPM:ProductIdentifier>SDL</QPM:ProductIdentifier>
+               <QPM:ProductEmail>slouken@libsdl.org</QPM:ProductEmail>
+               <QPM:VendorName>Public</QPM:VendorName>
+               <QPM:VendorInstallName>public</QPM:VendorInstallName>
+               <QPM:VendorURL>http://www.libsdl.org</QPM:VendorURL>
+               <QPM:VendorEmbedURL/>
+               <QPM:VendorEmail>slouken@libsdl.org</QPM:VendorEmail>
+               <QPM:AuthorName>Sam Lantinga</QPM:AuthorName>
+               <QPM:AuthorURL>http://www.libsdl.org</QPM:AuthorURL>
+               <QPM:AuthorEmbedURL/>
+               <QPM:AuthorEmail>slouken@libsdl.org</QPM:AuthorEmail>
+               <QPM:ProductIconSmall/>
+               <QPM:ProductIconLarge/>
+               <QPM:ProductDescriptionShort>This is the Simple DirectMedia Layer (SDL), a generic API that provides low level access to audio, keyboard, mouse, and display framebuffer across multiple platforms.</QPM:ProductDescriptionShort>
+               <QPM:ProductDescriptionLong>This is the Simple DirectMedia Layer (SDL), a generic API that provides low level access to audio, keyboard, mouse, and display framebuffer across multiple platforms. This is the libraries, include files and other resources you can use to develop and run SDL applications.</QPM:ProductDescriptionLong>
+               <QPM:ProductDescriptionURL>http://www.libsdl.org</QPM:ProductDescriptionURL>
+               <QPM:ProductDescriptionEmbedURL/>
+            </QPM:ProductDescription>
+
+            <QPM:ReleaseDescription>
+               <QPM:ReleaseVersion>@VERSION@</QPM:ReleaseVersion>
+               <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>
+               <QPM:ReleaseStability>Stable</QPM:ReleaseStability>
+               <QPM:ReleaseNoteMinor/>
+               <QPM:ReleaseNoteMajor/>
+               <QPM:ReleaseBuild>1</QPM:ReleaseBuild>
+               <QPM:CountryExclude/>
+               <QPM:ReleaseCopyright>GNU Lesser General Public License</QPM:ReleaseCopyright>
+            </QPM:ReleaseDescription>
+
+            <QPM:ContentDescription>
+               <QPM:ContentTopic xmlmultiple="true">Software Development/Libraries and Extensions/C Libraries</QPM:ContentTopic>
+               <QPM:ContentKeyword>SDL,audio,graphics,demos,games,emulators,direct,media,layer</QPM:ContentKeyword>
+               <QPM:TargetOS>qnx6</QPM:TargetOS>
+               <QPM:HostOS>none</QPM:HostOS>
+               <QPM:DisplayEnvironment xmlmultiple="true">Photon</QPM:DisplayEnvironment>
+               <QPM:DisplayEnvironment xmlmultiple="true">Console</QPM:DisplayEnvironment>
+               <QPM:TargetAudience xmlmultiple="true">Developer</QPM:TargetAudience>
+               <QPM:TargetAudience xmlmultiple="true">User</QPM:TargetAudience>
+            </QPM:ContentDescription>
+            <QPM:LicenseUrl>repdata://LicenseUrl/COPYING</QPM:LicenseUrl>
+         </QPM:PackageManifest>
+      </QPG:PackageFilter>
+
+      <QPG:PackageFilter proc="none" target="none">
+         <QPM:PackageManifest>
+            <QPM:ProductInstallationDependencies>
+               <QPM:ProductRequirements></QPM:ProductRequirements>
+            </QPM:ProductInstallationDependencies>
+         </QPM:PackageManifest>
+      </QPG:PackageFilter>
+
+      <QPG:PackageFilter proc="x86" target="none">
+         <QPM:PackageManifest>
+            <QPM:ProductInstallationDependencies>
+               <QPM:ProductRequirements></QPM:ProductRequirements>
+            </QPM:ProductInstallationDependencies>
+         </QPM:PackageManifest>
+      </QPG:PackageFilter>
+
+      <QPG:PackageFilter proc="none" target="x86">
+         <QPM:PackageManifest>
+            <QPM:ProductInstallationDependencies>
+               <QPM:ProductRequirements></QPM:ProductRequirements>
+            </QPM:ProductInstallationDependencies>
+         </QPM:PackageManifest>
+      </QPG:PackageFilter>
+
+      <QPG:PackageFilter proc="x86" target="x86">
+         <QPM:PackageManifest>
+            <QPM:ProductInstallationDependencies>
+               <QPM:ProductRequirements></QPM:ProductRequirements>
+            </QPM:ProductInstallationDependencies>
+         </QPM:PackageManifest>
+      </QPG:PackageFilter>
+
+   </QPG:Values>
+</QPG:Generation>
diff -ruN SDL-1.2.13/build-deps SDL-1.2.13_OOx64/build-deps
--- SDL-1.2.13/build-deps	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/build-deps	2017-12-20 12:21:32 +0000
@@ -0,0 +1,1537 @@
+$(objects)/SDL.lo: ./src/SDL.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL.c  -o $@
+
+
+$(objects)/SDL_HelperWindow.lo: ./src/SDL_HelperWindow.c \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL_HelperWindow.c  -o $@
+
+
+$(objects)/SDL_error.lo: ./src/SDL_error.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL_error.c  -o $@
+
+
+$(objects)/SDL_fatal.lo: ./src/SDL_fatal.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL_fatal.c  -o $@
+
+
+$(objects)/SDL_audio.lo: ./src/audio/SDL_audio.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audio.c  -o $@
+
+
+$(objects)/SDL_audiocvt.lo: ./src/audio/SDL_audiocvt.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audiocvt.c  -o $@
+
+
+$(objects)/SDL_audiodev.lo: ./src/audio/SDL_audiodev.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audiodev_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audiodev.c  -o $@
+
+
+$(objects)/SDL_mixer.lo: ./src/audio/SDL_mixer.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_mixer_MMX.h \
+	./src/audio/SDL_mixer_MMX_VC.h \
+	./src/audio/SDL_mixer_m68k.h \
+	./src/audio/SDL_sysaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer.c  -o $@
+
+
+$(objects)/SDL_mixer_MMX.lo: ./src/audio/SDL_mixer_MMX.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_MMX.c  -o $@
+
+
+$(objects)/SDL_mixer_MMX_VC.lo: ./src/audio/SDL_mixer_MMX_VC.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./src/audio/SDL_mixer_MMX_VC.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_MMX_VC.c  -o $@
+
+
+$(objects)/SDL_mixer_m68k.lo: ./src/audio/SDL_mixer_m68k.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_m68k.c  -o $@
+
+
+$(objects)/SDL_wave.lo: ./src/audio/SDL_wave.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_wave.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_wave.c  -o $@
+
+
+$(objects)/SDL_cdrom.lo: ./src/cdrom/SDL_cdrom.c \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/cdrom/SDL_syscdrom.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cdrom/SDL_cdrom.c  -o $@
+
+
+$(objects)/SDL_cpuinfo.lo: ./src/cpuinfo/SDL_cpuinfo.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cpuinfo/SDL_cpuinfo.c  -o $@
+
+
+$(objects)/SDL_active.lo: ./src/events/SDL_active.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_active.c  -o $@
+
+
+$(objects)/SDL_events.lo: ./src/events/SDL_events.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_events.c  -o $@
+
+
+$(objects)/SDL_expose.lo: ./src/events/SDL_expose.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_expose.c  -o $@
+
+
+$(objects)/SDL_keyboard.lo: ./src/events/SDL_keyboard.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_keyboard.c  -o $@
+
+
+$(objects)/SDL_mouse.lo: ./src/events/SDL_mouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_mouse.c  -o $@
+
+
+$(objects)/SDL_quit.lo: ./src/events/SDL_quit.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_quit.c  -o $@
+
+
+$(objects)/SDL_resize.lo: ./src/events/SDL_resize.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_resize.c  -o $@
+
+
+$(objects)/SDL_rwops.lo: ./src/file/SDL_rwops.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/file/SDL_rwops.c  -o $@
+
+
+$(objects)/SDL_getenv.lo: ./src/stdlib/SDL_getenv.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_getenv.c  -o $@
+
+
+$(objects)/SDL_iconv.lo: ./src/stdlib/SDL_iconv.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_iconv.c  -o $@
+
+
+$(objects)/SDL_malloc.lo: ./src/stdlib/SDL_malloc.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_malloc.c  -o $@
+
+
+$(objects)/SDL_qsort.lo: ./src/stdlib/SDL_qsort.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_qsort.c  -o $@
+
+
+$(objects)/SDL_stdlib.lo: ./src/stdlib/SDL_stdlib.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_stdlib.c  -o $@
+
+
+$(objects)/SDL_string.lo: ./src/stdlib/SDL_string.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_string.c  -o $@
+
+
+$(objects)/SDL_thread.lo: ./src/thread/SDL_thread.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+	./src/thread/SDL_systhread.h \
+	./src/thread/SDL_thread_c.h \
+	./src/thread/generic/SDL_systhread_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/SDL_thread.c  -o $@
+
+
+$(objects)/SDL_timer.lo: ./src/timer/SDL_timer.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/timer/SDL_systimer.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/timer/SDL_timer.c  -o $@
+
+
+$(objects)/SDL_RLEaccel.lo: ./src/video/SDL_RLEaccel.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_RLEaccel.c  -o $@
+
+
+$(objects)/SDL_blit.lo: ./src/video/SDL_blit.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit.c  -o $@
+
+
+$(objects)/SDL_blit_0.lo: ./src/video/SDL_blit_0.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_0.c  -o $@
+
+
+$(objects)/SDL_blit_1.lo: ./src/video/SDL_blit_1.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_1.c  -o $@
+
+
+$(objects)/SDL_blit_A.lo: ./src/video/SDL_blit_A.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_A.c  -o $@
+
+
+$(objects)/SDL_blit_N.lo: ./src/video/SDL_blit_N.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/../hermes/../hermes/HeadX86.h \
+	./src/video/../hermes/HeadMMX.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_N.c  -o $@
+
+
+$(objects)/SDL_bmp.lo: ./src/video/SDL_bmp.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_bmp.c  -o $@
+
+
+$(objects)/SDL_cursor.lo: ./src/video/SDL_cursor.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/default_cursor.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_cursor.c  -o $@
+
+
+$(objects)/SDL_gamma.lo: ./src/video/SDL_gamma.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_name.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/e_log.h \
+	./src/video/e_pow.h \
+	./src/video/e_sqrt.h \
+	./src/video/math_private.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_gamma.c  -o $@
+
+
+$(objects)/SDL_pixels.lo: ./src/video/SDL_pixels.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_pixels.c  -o $@
+
+
+$(objects)/SDL_stretch.lo: ./src/video/SDL_stretch.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_stretch.c  -o $@
+
+
+$(objects)/SDL_surface.lo: ./src/video/SDL_surface.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_surface.c  -o $@
+
+
+$(objects)/SDL_video.lo: ./src/video/SDL_video.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_video.c  -o $@
+
+
+$(objects)/SDL_yuv.lo: ./src/video/SDL_yuv.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_yuv_sw_c.h \
+	./src/video/SDL_yuvfuncs.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv.c  -o $@
+
+
+$(objects)/SDL_yuv_mmx.lo: ./src/video/SDL_yuv_mmx.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv_mmx.c  -o $@
+
+
+$(objects)/SDL_yuv_sw.lo: ./src/video/SDL_yuv_sw.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_stretch_c.h \
+	./src/video/SDL_yuv_sw_c.h \
+	./src/video/SDL_yuvfuncs.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv_sw.c  -o $@
+
+
+$(objects)/SDL_haptic.lo: ./src/haptic/SDL_haptic.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+	./src/haptic/SDL_syshaptic.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/haptic/SDL_haptic.c  -o $@
+
+
+$(objects)/SDL_joystick.lo: ./src/joystick/SDL_joystick.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+	./src/haptic/SDL_syshaptic.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/joystick/SDL_joystick.c  -o $@
+
+
+$(objects)/SDL_nullevents.lo: ./src/video/dummy/SDL_nullevents.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/dummy/SDL_nullevents_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullevents.c  -o $@
+
+
+$(objects)/SDL_nullmouse.lo: ./src/video/dummy/SDL_nullmouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/dummy/SDL_nullmouse_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullmouse.c  -o $@
+
+
+$(objects)/SDL_nullvideo.lo: ./src/video/dummy/SDL_nullvideo.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/dummy/SDL_nullevents_c.h \
+	./src/video/dummy/SDL_nullmouse_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullvideo.c  -o $@
+
+
+$(objects)/SDL_diskaudio.lo: ./src/audio/disk/SDL_diskaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiodev_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/disk/SDL_diskaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/disk/SDL_diskaudio.c  -o $@
+
+
+$(objects)/SDL_dummyaudio.lo: ./src/audio/dummy/SDL_dummyaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiodev_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/dummy/SDL_dummyaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/dummy/SDL_dummyaudio.c  -o $@
+
+
+$(objects)/SDL_sysevents.lo: ./src/video/wincommon/SDL_sysevents.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/../gapi/SDL_gapivideo.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/wmmsg.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_sysevents.c  -o $@
+
+
+$(objects)/SDL_sysmouse.lo: ./src/video/wincommon/SDL_sysmouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_sysmouse.c  -o $@
+
+
+$(objects)/SDL_syswm.lo: ./src/video/wincommon/SDL_syswm.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_loadso.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_syswm.c  -o $@
+
+
+$(objects)/SDL_wingl.lo: ./src/video/wincommon/SDL_wingl.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_wingl.c  -o $@
+
+
+$(objects)/SDL_dibevents.lo: ./src/video/windib/SDL_dibevents.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windib/SDL_dibvideo.h \
+	./src/video/windib/SDL_vkeys.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windib/SDL_dibevents.c  -o $@
+
+
+$(objects)/SDL_dibvideo.lo: ./src/video/windib/SDL_dibvideo.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+	./src/video/windib/SDL_dibevents_c.h \
+	./src/video/windib/SDL_dibvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windib/SDL_dibvideo.c  -o $@
+
+
+$(objects)/SDL_dx5events.lo: ./src/video/windx5/SDL_dx5events.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5events.c  -o $@
+
+
+$(objects)/SDL_dx5video.lo: ./src/video/windx5/SDL_dx5video.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+	./src/video/windx5/SDL_dx5events_c.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/SDL_dx5yuv_c.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5video.c  -o $@
+
+
+$(objects)/SDL_dx5yuv.lo: ./src/video/windx5/SDL_dx5yuv.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_yuvfuncs.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/SDL_dx5yuv_c.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5yuv.c  -o $@
+
+
+$(objects)/mmx_main.lo: ./src/hermes/mmx_main.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/mmx_main.asm -o $@
+
+
+$(objects)/mmxp2_32.lo: ./src/hermes/mmxp2_32.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/mmxp2_32.asm -o $@
+
+
+$(objects)/x86_main.lo: ./src/hermes/x86_main.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86_main.asm -o $@
+
+
+$(objects)/x86p_16.lo: ./src/hermes/x86p_16.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86p_16.asm -o $@
+
+
+$(objects)/x86p_32.lo: ./src/hermes/x86p_32.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86p_32.asm -o $@
+
+
+$(objects)/SDL_dibaudio.lo: ./src/audio/windib/SDL_dibaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/windib/SDL_dibaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/windib/SDL_dibaudio.c  -o $@
+
+
+$(objects)/SDL_dx5audio.lo: ./src/audio/windx5/SDL_dx5audio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/windx5/SDL_dx5audio.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/windx5/SDL_dx5audio.c  -o $@
+
+
+$(objects)/SDL_syshaptic.lo: ./src/haptic/win32/SDL_syshaptic.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/haptic/SDL_syshaptic.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/haptic/win32/SDL_syshaptic.c  -o $@
+
+
+$(objects)/SDL_mmjoystick.lo: ./src/joystick/win32/SDL_mmjoystick.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_haptic.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/haptic/SDL_syshaptic.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/joystick/win32/SDL_mmjoystick.c  -o $@
+
+
+$(objects)/SDL_syscdrom.lo: ./src/cdrom/win32/SDL_syscdrom.c \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/cdrom/SDL_syscdrom.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cdrom/win32/SDL_syscdrom.c  -o $@
+
+
+$(objects)/SDL_sysmutex.lo: ./src/thread/win32/SDL_sysmutex.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_sysmutex.c  -o $@
+
+
+$(objects)/SDL_syssem.lo: ./src/thread/win32/SDL_syssem.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_syssem.c  -o $@
+
+
+$(objects)/SDL_systhread.lo: ./src/thread/win32/SDL_systhread.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+	./src/thread/SDL_systhread.h \
+	./src/thread/SDL_thread_c.h \
+	./src/thread/generic/SDL_systhread_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_systhread.c  -o $@
+
+
+$(objects)/SDL_syscond.lo: ./src/thread/generic/SDL_syscond.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/generic/SDL_syscond.c  -o $@
+
+
+$(objects)/SDL_systimer.lo: ./src/timer/win32/SDL_systimer.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/timer/win32/SDL_systimer.c  -o $@
+
+
+$(objects)/SDL_sysloadso.lo: ./src/loadso/win32/SDL_sysloadso.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_loadso.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/loadso/win32/SDL_sysloadso.c  -o $@
+
+
+$(objects)/version.o: ./src/main/win32/version.rc \
+
+	$(WINDRES) ./src/main/win32/version.rc $@
+
+
+$(objects)/SDL_win32_main.o: ./src/main/win32/SDL_win32_main.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/main/win32/SDL_win32_main.c -o $@
diff -ruN SDL-1.2.13/build-deps.bak SDL-1.2.13_OOx64/build-deps.bak
--- SDL-1.2.13/build-deps.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/build-deps.bak	2013-10-03 18:44:02 +0000
@@ -0,0 +1,1459 @@
+$(objects)/SDL.lo: ./src/SDL.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL.c  -o $@
+
+
+$(objects)/SDL_error.lo: ./src/SDL_error.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL_error.c  -o $@
+
+
+$(objects)/SDL_fatal.lo: ./src/SDL_fatal.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/SDL_fatal.c  -o $@
+
+
+$(objects)/SDL_audio.lo: ./src/audio/SDL_audio.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audio.c  -o $@
+
+
+$(objects)/SDL_audiocvt.lo: ./src/audio/SDL_audiocvt.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audiocvt.c  -o $@
+
+
+$(objects)/SDL_audiodev.lo: ./src/audio/SDL_audiodev.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audiodev_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_audiodev.c  -o $@
+
+
+$(objects)/SDL_mixer.lo: ./src/audio/SDL_mixer.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_mixer_MMX.h \
+	./src/audio/SDL_mixer_MMX_VC.h \
+	./src/audio/SDL_mixer_m68k.h \
+	./src/audio/SDL_sysaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer.c  -o $@
+
+
+$(objects)/SDL_mixer_MMX.lo: ./src/audio/SDL_mixer_MMX.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_MMX.c  -o $@
+
+
+$(objects)/SDL_mixer_MMX_VC.lo: ./src/audio/SDL_mixer_MMX_VC.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./src/audio/SDL_mixer_MMX_VC.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_MMX_VC.c  -o $@
+
+
+$(objects)/SDL_mixer_m68k.lo: ./src/audio/SDL_mixer_m68k.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_mixer_m68k.c  -o $@
+
+
+$(objects)/SDL_wave.lo: ./src/audio/SDL_wave.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_wave.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/SDL_wave.c  -o $@
+
+
+$(objects)/SDL_cdrom.lo: ./src/cdrom/SDL_cdrom.c \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/cdrom/SDL_syscdrom.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cdrom/SDL_cdrom.c  -o $@
+
+
+$(objects)/SDL_cpuinfo.lo: ./src/cpuinfo/SDL_cpuinfo.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cpuinfo/SDL_cpuinfo.c  -o $@
+
+
+$(objects)/SDL_active.lo: ./src/events/SDL_active.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_active.c  -o $@
+
+
+$(objects)/SDL_events.lo: ./src/events/SDL_events.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_events.c  -o $@
+
+
+$(objects)/SDL_expose.lo: ./src/events/SDL_expose.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_expose.c  -o $@
+
+
+$(objects)/SDL_keyboard.lo: ./src/events/SDL_keyboard.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_keyboard.c  -o $@
+
+
+$(objects)/SDL_mouse.lo: ./src/events/SDL_mouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_mouse.c  -o $@
+
+
+$(objects)/SDL_quit.lo: ./src/events/SDL_quit.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_quit.c  -o $@
+
+
+$(objects)/SDL_resize.lo: ./src/events/SDL_resize.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/events/SDL_resize.c  -o $@
+
+
+$(objects)/SDL_rwops.lo: ./src/file/SDL_rwops.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/file/SDL_rwops.c  -o $@
+
+
+$(objects)/SDL_getenv.lo: ./src/stdlib/SDL_getenv.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_getenv.c  -o $@
+
+
+$(objects)/SDL_iconv.lo: ./src/stdlib/SDL_iconv.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_iconv.c  -o $@
+
+
+$(objects)/SDL_malloc.lo: ./src/stdlib/SDL_malloc.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_malloc.c  -o $@
+
+
+$(objects)/SDL_qsort.lo: ./src/stdlib/SDL_qsort.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_qsort.c  -o $@
+
+
+$(objects)/SDL_stdlib.lo: ./src/stdlib/SDL_stdlib.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_stdlib.c  -o $@
+
+
+$(objects)/SDL_string.lo: ./src/stdlib/SDL_string.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/stdlib/SDL_string.c  -o $@
+
+
+$(objects)/SDL_thread.lo: ./src/thread/SDL_thread.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+	./src/thread/SDL_systhread.h \
+	./src/thread/SDL_thread_c.h \
+	./src/thread/generic/SDL_systhread_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/SDL_thread.c  -o $@
+
+
+$(objects)/SDL_timer.lo: ./src/timer/SDL_timer.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/timer/SDL_systimer.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/timer/SDL_timer.c  -o $@
+
+
+$(objects)/SDL_RLEaccel.lo: ./src/video/SDL_RLEaccel.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_RLEaccel.c  -o $@
+
+
+$(objects)/SDL_blit.lo: ./src/video/SDL_blit.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit.c  -o $@
+
+
+$(objects)/SDL_blit_0.lo: ./src/video/SDL_blit_0.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_0.c  -o $@
+
+
+$(objects)/SDL_blit_1.lo: ./src/video/SDL_blit_1.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_1.c  -o $@
+
+
+$(objects)/SDL_blit_A.lo: ./src/video/SDL_blit_A.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_A.c  -o $@
+
+
+$(objects)/SDL_blit_N.lo: ./src/video/SDL_blit_N.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/../hermes/../hermes/HeadX86.h \
+	./src/video/../hermes/HeadMMX.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_blit_N.c  -o $@
+
+
+$(objects)/SDL_bmp.lo: ./src/video/SDL_bmp.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_bmp.c  -o $@
+
+
+$(objects)/SDL_cursor.lo: ./src/video/SDL_cursor.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/default_cursor.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_cursor.c  -o $@
+
+
+$(objects)/SDL_gamma.lo: ./src/video/SDL_gamma.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_name.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/e_log.h \
+	./src/video/e_pow.h \
+	./src/video/e_sqrt.h \
+	./src/video/math_private.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_gamma.c  -o $@
+
+
+$(objects)/SDL_pixels.lo: ./src/video/SDL_pixels.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_pixels.c  -o $@
+
+
+$(objects)/SDL_stretch.lo: ./src/video/SDL_stretch.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/SDL_blit.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_stretch.c  -o $@
+
+
+$(objects)/SDL_surface.lo: ./src/video/SDL_surface.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/video/SDL_RLEaccel_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_surface.c  -o $@
+
+
+$(objects)/SDL_video.lo: ./src/video/SDL_video.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_video.c  -o $@
+
+
+$(objects)/SDL_yuv.lo: ./src/video/SDL_yuv.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_yuv_sw_c.h \
+	./src/video/SDL_yuvfuncs.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv.c  -o $@
+
+
+$(objects)/SDL_yuv_mmx.lo: ./src/video/SDL_yuv_mmx.c \
+	./include/SDL_config.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/video/mmx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv_mmx.c  -o $@
+
+
+$(objects)/SDL_yuv_sw.lo: ./src/video/SDL_yuv_sw.c \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_stretch_c.h \
+	./src/video/SDL_yuv_sw_c.h \
+	./src/video/SDL_yuvfuncs.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/SDL_yuv_sw.c  -o $@
+
+
+$(objects)/SDL_joystick.lo: ./src/joystick/SDL_joystick.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/SDL_events_c.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/joystick/SDL_joystick.c  -o $@
+
+
+$(objects)/SDL_nullevents.lo: ./src/video/dummy/SDL_nullevents.c \
+	./include/SDL.h \
+	./include/SDL_active.h \
+	./include/SDL_audio.h \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_cpuinfo.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/dummy/SDL_nullevents_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullevents.c  -o $@
+
+
+$(objects)/SDL_nullmouse.lo: ./src/video/dummy/SDL_nullmouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/dummy/SDL_nullmouse_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullmouse.c  -o $@
+
+
+$(objects)/SDL_nullvideo.lo: ./src/video/dummy/SDL_nullvideo.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/dummy/SDL_nullevents_c.h \
+	./src/video/dummy/SDL_nullmouse_c.h \
+	./src/video/dummy/SDL_nullvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/dummy/SDL_nullvideo.c  -o $@
+
+
+$(objects)/SDL_diskaudio.lo: ./src/audio/disk/SDL_diskaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiodev_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/disk/SDL_diskaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/disk/SDL_diskaudio.c  -o $@
+
+
+$(objects)/SDL_dummyaudio.lo: ./src/audio/dummy/SDL_dummyaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_audiodev_c.h \
+	./src/audio/SDL_audiomem.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/dummy/SDL_dummyaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/dummy/SDL_dummyaudio.c  -o $@
+
+
+$(objects)/SDL_sysevents.lo: ./src/video/wincommon/SDL_sysevents.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_loadso.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/../gapi/SDL_gapivideo.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/wmmsg.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_sysevents.c  -o $@
+
+
+$(objects)/SDL_sysmouse.lo: ./src/video/wincommon/SDL_sysmouse.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_sysmouse.c  -o $@
+
+
+$(objects)/SDL_syswm.lo: ./src/video/wincommon/SDL_syswm.c \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_loadso.h \
+	./include/SDL_mouse.h \
+	./include/SDL_mutex.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/../video/SDL_cursor_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_syswm.c  -o $@
+
+
+$(objects)/SDL_wingl.lo: ./src/video/wincommon/SDL_wingl.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/wincommon/SDL_wingl.c  -o $@
+
+
+$(objects)/SDL_dibevents.lo: ./src/video/windib/SDL_dibevents.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windib/SDL_dibvideo.h \
+	./src/video/windib/SDL_vkeys.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windib/SDL_dibevents.c  -o $@
+
+
+$(objects)/SDL_dibvideo.lo: ./src/video/windib/SDL_dibvideo.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+	./src/video/windib/SDL_dibevents_c.h \
+	./src/video/windib/SDL_dibvideo.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windib/SDL_dibvideo.c  -o $@
+
+
+$(objects)/SDL_dx5events.lo: ./src/video/windx5/SDL_dx5events.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_main.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/events/SDL_events_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5events.c  -o $@
+
+
+$(objects)/SDL_dx5video.lo: ./src/video/windx5/SDL_dx5video.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_timer.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_blit.h \
+	./src/video/SDL_pixels_c.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/wincommon/SDL_sysmouse_c.h \
+	./src/video/wincommon/SDL_syswm_c.h \
+	./src/video/wincommon/SDL_wingl_c.h \
+	./src/video/windx5/SDL_dx5events_c.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/SDL_dx5yuv_c.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5video.c  -o $@
+
+
+$(objects)/SDL_dx5yuv.lo: ./src/video/windx5/SDL_dx5yuv.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mouse.h \
+	./include/SDL_opengl.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_syswm.h \
+	./include/SDL_version.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/events/../video/../video/SDL_sysvideo.h \
+	./src/video/SDL_yuvfuncs.h \
+	./src/video/wincommon/SDL_lowvideo.h \
+	./src/video/windx5/SDL_dx5video.h \
+	./src/video/windx5/SDL_dx5yuv_c.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/video/windx5/SDL_dx5yuv.c  -o $@
+
+
+$(objects)/mmx_main.lo: ./src/hermes/mmx_main.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/mmx_main.asm -o $@
+
+
+$(objects)/mmxp2_32.lo: ./src/hermes/mmxp2_32.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/mmxp2_32.asm -o $@
+
+
+$(objects)/x86_main.lo: ./src/hermes/x86_main.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86_main.asm -o $@
+
+
+$(objects)/x86p_16.lo: ./src/hermes/x86p_16.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86p_16.asm -o $@
+
+
+$(objects)/x86p_32.lo: ./src/hermes/x86p_32.asm \
+
+	$(LIBTOOL) --tag=CC --mode=compile $(auxdir)/strip_fPIC.sh $(NASM) ./src/hermes/x86p_32.asm -o $@
+
+
+$(objects)/SDL_dibaudio.lo: ./src/audio/windib/SDL_dibaudio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/windib/SDL_dibaudio.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/windib/SDL_dibaudio.c  -o $@
+
+
+$(objects)/SDL_dx5audio.lo: ./src/audio/windx5/SDL_dx5audio.c \
+	./include/SDL_audio.h \
+	./include/SDL_config.h \
+	./include/SDL_endian.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/audio/SDL_audio_c.h \
+	./src/audio/SDL_sysaudio.h \
+	./src/audio/windx5/SDL_dx5audio.h \
+	./src/video/windx5/directx.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/audio/windx5/SDL_dx5audio.c  -o $@
+
+
+$(objects)/SDL_mmjoystick.lo: ./src/joystick/win32/SDL_mmjoystick.c \
+	./include/SDL_active.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_events.h \
+	./include/SDL_joystick.h \
+	./include/SDL_keyboard.h \
+	./include/SDL_keysym.h \
+	./include/SDL_mouse.h \
+	./include/SDL_platform.h \
+	./include/SDL_quit.h \
+	./include/SDL_rwops.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_video.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/joystick/SDL_sysjoystick.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/joystick/win32/SDL_mmjoystick.c  -o $@
+
+
+$(objects)/SDL_syscdrom.lo: ./src/cdrom/win32/SDL_syscdrom.c \
+	./include/SDL_cdrom.h \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/cdrom/SDL_syscdrom.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/cdrom/win32/SDL_syscdrom.c  -o $@
+
+
+$(objects)/SDL_sysmutex.lo: ./src/thread/win32/SDL_sysmutex.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_sysmutex.c  -o $@
+
+
+$(objects)/SDL_syssem.lo: ./src/thread/win32/SDL_syssem.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_syssem.c  -o $@
+
+
+$(objects)/SDL_systhread.lo: ./src/thread/win32/SDL_systhread.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+	./src/SDL_error_c.h \
+	./src/thread/SDL_systhread.h \
+	./src/thread/SDL_thread_c.h \
+	./src/thread/generic/SDL_systhread_c.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/win32/SDL_systhread.c  -o $@
+
+
+$(objects)/SDL_syscond.lo: ./src/thread/generic/SDL_syscond.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_mutex.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_thread.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/thread/generic/SDL_syscond.c  -o $@
+
+
+$(objects)/SDL_systimer.lo: ./src/timer/win32/SDL_systimer.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/SDL_timer.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/timer/win32/SDL_systimer.c  -o $@
+
+
+$(objects)/SDL_sysloadso.lo: ./src/loadso/win32/SDL_sysloadso.c \
+	./include/SDL_config.h \
+	./include/SDL_error.h \
+	./include/SDL_loadso.h \
+	./include/SDL_platform.h \
+	./include/SDL_stdinc.h \
+	./include/begin_code.h \
+	./include/close_code.h \
+
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/loadso/win32/SDL_sysloadso.c  -o $@
+
+
+$(objects)/version.o: ./src/main/win32/version.rc \
+
+	$(WINDRES) ./src/main/win32/version.rc $@
+
+
+$(objects)/SDL_win32_main.o: ./src/main/win32/SDL_win32_main.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c ./src/main/win32/SDL_win32_main.c -o $@
diff -ruN SDL-1.2.13/config.log SDL-1.2.13_OOx64/config.log
--- SDL-1.2.13/config.log	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/config.log	2013-10-03 18:44:02 +0000
@@ -0,0 +1,2315 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  $ ./configure --prefix=/mingw/../devlibs
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = BHIG4NYZN1
+uname -m = i686
+uname -r = 1.0.11(0.46/3/2)
+uname -s = MINGW32_NT-6.1
+uname -v = 2009-07-11 17:46
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = unknown
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: .
+PATH: /usr/local/bin
+PATH: /mingw/bin
+PATH: /bin
+PATH: /mingw/../devlibs/bin
+PATH: /c/Program Files (x86)/CA/SC/CAWIN/
+PATH: /c/windows/system32
+PATH: /c/windows
+PATH: /c/windows/System32/Wbem
+PATH: /c/windows/System32/WindowsPowerShell/v1.0/
+PATH: /c/Program Files/Dell/Dell Data Protection/Access/Advanced/Wave/Gemalto/Access Client/v5/
+PATH: /c/Program Files (x86)/Security Innovation/SI TSS/bin/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/12.0/DLLShared/
+PATH: /c/Program Files (x86)/Roxio/OEM/AudioCore/
+PATH: /c/PROGRA~2/CA/SC/CAM/bin
+PATH: /c/Program Files (x86)/CA/SC/Csam/SockAdapter/bin
+PATH: /c/Program Files (x86)/CA/SC/CBB/
+PATH: /c/Program Files (x86)/CA/DSM/bin
+PATH: /svn/bin
+PATH: /nsis
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:2118: checking build system type
+configure:2136: result: i686-pc-mingw32
+configure:2158: checking host system type
+configure:2173: result: i686-pc-mingw32
+configure:2243: checking for gcc
+configure:2259: found /mingw/bin/gcc
+configure:2270: result: gcc
+configure:2508: checking for C compiler version
+configure:2515: gcc --version >&5
+gcc.exe (tdm64-1) 4.8.1
+Copyright (C) 2013 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:2518: $? = 0
+configure:2525: gcc -v >&5
+Using built-in specs.
+COLLECT_GCC=C:\DevelopmentEnvironment\gcc\Msys_x2\1.0\mingw\bin\gcc.exe
+COLLECT_LTO_WRAPPER=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.8.1/lto-wrapper.exe
+Target: x86_64-w64-mingw32
+Configured with: ../../../src/gcc-4.8.1/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs
+Thread model: posix
+gcc version 4.8.1 (tdm64-1) 
+configure:2528: $? = 0
+configure:2535: gcc -V >&5
+gcc.exe: error: unrecognized command line option '-V'
+gcc.exe: fatal error: no input files
+compilation terminated.
+configure:2538: $? = 1
+configure:2561: checking for C compiler default output file name
+configure:2588: gcc  -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  >&5
+configure:2591: $? = 0
+configure:2629: result: a.exe
+configure:2646: checking whether the C compiler works
+configure:2656: ./a.exe
+configure:2659: $? = 0
+configure:2676: result: yes
+configure:2683: checking whether we are cross compiling
+configure:2685: result: no
+configure:2688: checking for suffix of executables
+configure:2695: gcc -o conftest.exe  -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  >&5
+configure:2698: $? = 0
+configure:2722: result: .exe
+configure:2728: checking for suffix of object files
+configure:2754: gcc -c  -I/mingw/../devlibs/include conftest.c >&5
+configure:2757: $? = 0
+configure:2780: result: o
+configure:2784: checking whether we are using the GNU C compiler
+configure:2813: gcc -c  -I/mingw/../devlibs/include conftest.c >&5
+configure:2819: $? = 0
+configure:2836: result: yes
+configure:2841: checking whether gcc accepts -g
+configure:2871: gcc -c -g -I/mingw/../devlibs/include conftest.c >&5
+configure:2877: $? = 0
+configure:2976: result: yes
+configure:2993: checking for gcc option to accept ISO C89
+configure:3067: gcc  -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3073: $? = 0
+configure:3096: result: none needed
+configure:3120: checking how to run the C preprocessor
+configure:3160: gcc -E -I/mingw/../devlibs/include conftest.c
+configure:3166: $? = 0
+configure:3197: gcc -E -I/mingw/../devlibs/include conftest.c
+conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:3203: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3236: result: gcc -E
+configure:3265: gcc -E -I/mingw/../devlibs/include conftest.c
+configure:3271: $? = 0
+configure:3302: gcc -E -I/mingw/../devlibs/include conftest.c
+conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:3308: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3346: checking for grep that handles long lines and -e
+configure:3420: result: /bin/grep
+configure:3425: checking for egrep
+configure:3503: result: /bin/grep -E
+configure:3508: checking for ANSI C header files
+configure:3538: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3544: $? = 0
+configure:3643: gcc -o conftest.exe -g -O2 -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  >&5
+configure:3646: $? = 0
+configure:3652: ./conftest.exe
+configure:3655: $? = 0
+configure:3672: result: yes
+configure:3696: checking for sys/types.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for sys/stat.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for stdlib.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for string.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for memory.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for strings.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for inttypes.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for stdint.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3696: checking for unistd.h
+configure:3717: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3723: $? = 0
+configure:3739: result: yes
+configure:3751: checking whether byte ordering is bigendian
+configure:3784: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:3790: $? = 0
+configure:3822: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:26:2: error: unknown type name 'not'
+  not big endian
+  ^
+conftest.c:26:10: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'endian'
+  not big endian
+          ^
+configure:3828: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| /* end confdefs.h.  */
+| #include <sys/types.h>
+| #include <sys/param.h>
+| 
+| int
+| main ()
+| {
+| #if BYTE_ORDER != BIG_ENDIAN
+|  not big endian
+| #endif
+| 
+|   ;
+|   return 0;
+| }
+configure:3968: result: no
+configure:4112: checking for a sed that does not truncate output
+configure:4166: result: /bin/sed
+configure:4180: checking for ld used by gcc
+configure:4247: result: c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe
+configure:4256: checking if the linker (c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe) is GNU ld
+configure:4271: result: yes
+configure:4276: checking for c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe option to reload object files
+configure:4283: result: -r
+configure:4301: checking for BSD-compatible nm
+configure:4350: result: /mingw/bin/nm
+configure:4354: checking whether ln -s works
+configure:4358: result: yes
+configure:4365: checking how to recognise dependent libraries
+configure:4543: result: pass_all
+configure:4809: checking for dlltool
+configure:4825: found /mingw/bin/dlltool
+configure:4836: result: dlltool
+configure:4905: checking for as
+configure:4921: found /mingw/bin/as
+configure:4932: result: as
+configure:5001: checking for objdump
+configure:5017: found /mingw/bin/objdump
+configure:5028: result: objdump
+configure:5076: checking dlfcn.h usability
+configure:5093: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+conftest.c:53:19: fatal error: dlfcn.h: No such file or directory
+ #include <dlfcn.h>
+                   ^
+compilation terminated.
+configure:5099: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #ifdef HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #ifdef HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #ifdef STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # ifdef HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #ifdef HAVE_STRING_H
+| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #ifdef HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #ifdef HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #endif
+| #ifdef HAVE_STDINT_H
+| # include <stdint.h>
+| #endif
+| #ifdef HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| #include <dlfcn.h>
+configure:5113: result: no
+configure:5117: checking dlfcn.h presence
+configure:5132: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+conftest.c:20:19: fatal error: dlfcn.h: No such file or directory
+ #include <dlfcn.h>
+                   ^
+compilation terminated.
+configure:5138: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| /* end confdefs.h.  */
+| #include <dlfcn.h>
+configure:5152: result: no
+configure:5180: checking for dlfcn.h
+configure:5188: result: no
+configure:5259: checking for g++
+configure:5275: found /mingw/bin/g++
+configure:5286: result: g++
+configure:5317: checking for C++ compiler version
+configure:5324: g++ --version >&5
+g++.exe (tdm64-1) 4.8.1
+Copyright (C) 2013 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:5327: $? = 0
+configure:5334: g++ -v >&5
+Using built-in specs.
+COLLECT_GCC=C:\DevelopmentEnvironment\gcc\Msys_x2\1.0\mingw\bin\g++.exe
+COLLECT_LTO_WRAPPER=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.8.1/lto-wrapper.exe
+Target: x86_64-w64-mingw32
+Configured with: ../../../src/gcc-4.8.1/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs
+Thread model: posix
+gcc version 4.8.1 (tdm64-1) 
+configure:5337: $? = 0
+configure:5344: g++ -V >&5
+g++.exe: error: unrecognized command line option '-V'
+g++.exe: fatal error: no input files
+compilation terminated.
+configure:5347: $? = 1
+configure:5350: checking whether we are using the GNU C++ compiler
+configure:5379: g++ -c  -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp >&5
+configure:5385: $? = 0
+configure:5402: result: yes
+configure:5407: checking whether g++ accepts -g
+configure:5437: g++ -c -g -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp >&5
+configure:5443: $? = 0
+configure:5542: result: yes
+configure:5575: checking how to run the C++ preprocessor
+configure:5611: g++ -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp
+configure:5617: $? = 0
+configure:5648: g++ -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp
+conftest.cpp:20:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:5654: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:5687: result: g++ -E
+configure:5716: g++ -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp
+configure:5722: $? = 0
+configure:5753: g++ -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp
+conftest.cpp:20:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:5759: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:5852: checking for g77
+configure:5882: result: no
+configure:5852: checking for xlf
+configure:5882: result: no
+configure:5852: checking for f77
+configure:5882: result: no
+configure:5852: checking for frt
+configure:5882: result: no
+configure:5852: checking for pgf77
+configure:5882: result: no
+configure:5852: checking for cf77
+configure:5882: result: no
+configure:5852: checking for fort77
+configure:5882: result: no
+configure:5852: checking for fl32
+configure:5882: result: no
+configure:5852: checking for af77
+configure:5882: result: no
+configure:5852: checking for xlf90
+configure:5882: result: no
+configure:5852: checking for f90
+configure:5882: result: no
+configure:5852: checking for pgf90
+configure:5882: result: no
+configure:5852: checking for pghpf
+configure:5882: result: no
+configure:5852: checking for epcf90
+configure:5882: result: no
+configure:5852: checking for gfortran
+configure:5882: result: no
+configure:5852: checking for g95
+configure:5882: result: no
+configure:5852: checking for xlf95
+configure:5882: result: no
+configure:5852: checking for f95
+configure:5882: result: no
+configure:5852: checking for fort
+configure:5882: result: no
+configure:5852: checking for ifort
+configure:5882: result: no
+configure:5852: checking for ifc
+configure:5882: result: no
+configure:5852: checking for efc
+configure:5882: result: no
+configure:5852: checking for pgf95
+configure:5882: result: no
+configure:5852: checking for lf95
+configure:5882: result: no
+configure:5852: checking for ftn
+configure:5882: result: no
+configure:5909: checking for Fortran 77 compiler version
+configure:5916:  --version >&5
+./configure: line 5917: --version: command not found
+configure:5919: $? = 127
+configure:5926:  -v >&5
+./configure: line 5927: -v: command not found
+configure:5929: $? = 127
+configure:5936:  -V >&5
+./configure: line 5937: -V: command not found
+configure:5939: $? = 127
+configure:5947: checking whether we are using the GNU Fortran 77 compiler
+configure:5966:  -c  conftest.F >&5
+./configure: line 5967: -c: command not found
+configure:5972: $? = 127
+configure: failed program was:
+|       program main
+| #ifndef __GNUC__
+|        choke me
+| #endif
+| 
+|       end
+configure:5989: result: no
+configure:5995: checking whether  accepts -g
+configure:6012:  -c -g conftest.f >&5
+./configure: line 6013: -c: command not found
+configure:6018: $? = 127
+configure: failed program was:
+|       program main
+| 
+|       end
+configure:6034: result: no
+configure:6064: checking the maximum length of command line arguments
+configure:6179: result: 8192
+configure:6190: checking command to parse /mingw/bin/nm output from gcc object
+configure:6295: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:6298: $? = 0
+configure:6302: /mingw/bin/nm conftest.o \| sed -n -e 's/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)\{0,1\}$/\1 \2 \2/p' \> conftest.nm
+configure:6305: $? = 0
+configure:6357: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c conftstm.o >&5
+configure:6360: $? = 0
+configure:6398: result: ok
+configure:6402: checking for objdir
+configure:6417: result: .libs
+configure:6509: checking for ar
+configure:6525: found /mingw/bin/ar
+configure:6536: result: ar
+configure:6605: checking for ranlib
+configure:6621: found /mingw/bin/ranlib
+configure:6632: result: ranlib
+configure:6701: checking for strip
+configure:6717: found /mingw/bin/strip
+configure:6728: result: strip
+configure:7018: checking if gcc supports -fno-rtti -fno-exceptions
+configure:7036: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -fno-rtti -fno-exceptions conftest.c >&5
+cc1.exe: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
+configure:7040: $? = 0
+configure:7053: result: no
+configure:7068: checking for gcc option to produce PIC
+configure:7278: result: -DDLL_EXPORT
+configure:7286: checking if gcc PIC flag -DDLL_EXPORT works
+configure:7304: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -DDLL_EXPORT -DPIC conftest.c >&5
+configure:7308: $? = 0
+configure:7321: result: yes
+configure:7349: checking if gcc static flag -static works
+configure:7377: result: yes
+configure:7387: checking if gcc supports -c -o file.o
+configure:7408: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -o out/conftest2.o conftest.c >&5
+configure:7412: $? = 0
+configure:7434: result: yes
+configure:7460: checking whether the gcc linker (c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe) supports shared libraries
+configure:8414: result: yes
+configure:8435: checking whether -lc should be explicitly linked in
+configure:8440: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:8443: $? = 0
+configure:8458: gcc -shared conftest.o  -v -o ./conftest -Wl,--enable-auto-image-base -Xlinker --out-implib -Xlinker conftest 2\>\&1 \| grep  -lc  \>/dev/null 2\>\&1
+configure:8461: $? = 1
+configure:8473: result: yes
+configure:8481: checking dynamic linker characteristics
+configure:9071: result: Win32 ld.exe
+configure:9080: checking how to hardcode library paths into programs
+configure:9105: result: immediate
+configure:9119: checking whether stripping libraries is possible
+configure:9124: result: yes
+configure:9925: checking if libtool supports shared libraries
+configure:9927: result: yes
+configure:9930: checking whether to build shared libraries
+configure:9951: result: yes
+configure:9954: checking whether to build static libraries
+configure:9958: result: yes
+configure:10050: creating libtool
+configure:10638: checking for ld used by g++
+configure:10705: result: c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe
+configure:10714: checking if the linker (c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe) is GNU ld
+configure:10729: result: yes
+configure:10780: checking whether the g++ linker (c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe) supports shared libraries
+configure:11714: result: yes
+configure:11736: g++ -c -g -O2 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.cpp >&5
+configure:11739: $? = 0
+configure:11858: checking for g++ option to produce PIC
+configure:12132: result: -DDLL_EXPORT
+configure:12140: checking if g++ PIC flag -DDLL_EXPORT works
+configure:12158: g++ -c -g -O2 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -DDLL_EXPORT -DPIC conftest.cpp >&5
+configure:12162: $? = 0
+configure:12175: result: yes
+configure:12203: checking if g++ static flag -static works
+configure:12231: result: yes
+configure:12241: checking if g++ supports -c -o file.o
+configure:12262: g++ -c -g -O2 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -o out/conftest2.o conftest.cpp >&5
+configure:12266: $? = 0
+configure:12288: result: yes
+configure:12314: checking whether the g++ linker (c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe) supports shared libraries
+configure:12339: result: yes
+configure:12406: checking dynamic linker characteristics
+configure:12996: result: Win32 ld.exe
+configure:13005: checking how to hardcode library paths into programs
+configure:13030: result: immediate
+configure:19226: checking for gcc
+configure:19253: result: gcc
+configure:19491: checking for C compiler version
+configure:19498: gcc --version >&5
+gcc.exe (tdm64-1) 4.8.1
+Copyright (C) 2013 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:19501: $? = 0
+configure:19508: gcc -v >&5
+Using built-in specs.
+COLLECT_GCC=C:\DevelopmentEnvironment\gcc\Msys_x2\1.0\mingw\bin\gcc.exe
+COLLECT_LTO_WRAPPER=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.8.1/lto-wrapper.exe
+Target: x86_64-w64-mingw32
+Configured with: ../../../src/gcc-4.8.1/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs
+Thread model: posix
+gcc version 4.8.1 (tdm64-1) 
+configure:19511: $? = 0
+configure:19518: gcc -V >&5
+gcc.exe: error: unrecognized command line option '-V'
+gcc.exe: fatal error: no input files
+compilation terminated.
+configure:19521: $? = 1
+configure:19524: checking whether we are using the GNU C compiler
+configure:19576: result: yes
+configure:19581: checking whether gcc accepts -g
+configure:19716: result: yes
+configure:19733: checking for gcc option to accept ISO C89
+configure:19836: result: none needed
+configure:19970: checking for C++ compiler version
+configure:19977: g++ --version >&5
+g++.exe (tdm64-1) 4.8.1
+Copyright (C) 2013 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:19980: $? = 0
+configure:19987: g++ -v >&5
+Using built-in specs.
+COLLECT_GCC=C:\DevelopmentEnvironment\gcc\Msys_x2\1.0\mingw\bin\g++.exe
+COLLECT_LTO_WRAPPER=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.8.1/lto-wrapper.exe
+Target: x86_64-w64-mingw32
+Configured with: ../../../src/gcc-4.8.1/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs
+Thread model: posix
+gcc version 4.8.1 (tdm64-1) 
+configure:19990: $? = 0
+configure:19997: g++ -V >&5
+g++.exe: error: unrecognized command line option '-V'
+g++.exe: fatal error: no input files
+compilation terminated.
+configure:20000: $? = 1
+configure:20003: checking whether we are using the GNU C++ compiler
+configure:20055: result: yes
+configure:20060: checking whether g++ accepts -g
+configure:20195: result: yes
+configure:20231: checking for a BSD-compatible install
+configure:20287: result: /bin/install -c
+configure:20298: checking whether make sets $(MAKE)
+configure:20319: result: yes
+configure:20337: checking for windres
+configure:20353: found /mingw/bin/windres
+configure:20364: result: windres
+configure:20376: checking for an ANSI C-conforming const
+configure:20451: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20457: $? = 0
+configure:20472: result: yes
+configure:20482: checking for inline
+configure:20508: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20514: $? = 0
+configure:20532: result: inline
+configure:20551: checking for working volatile
+configure:20580: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20586: $? = 0
+configure:20601: result: yes
+configure:20625: checking for ANSI C header files
+configure:20789: result: yes
+configure:20818: checking for sys/types.h
+configure:20824: result: yes
+configure:20828: checking stdio.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking stdio.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for stdio.h
+configure:20940: result: yes
+configure:20818: checking for stdlib.h
+configure:20824: result: yes
+configure:20828: checking stddef.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking stddef.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for stddef.h
+configure:20940: result: yes
+configure:20828: checking stdarg.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking stdarg.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for stdarg.h
+configure:20940: result: yes
+configure:20828: checking malloc.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking malloc.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for malloc.h
+configure:20940: result: yes
+configure:20818: checking for memory.h
+configure:20824: result: yes
+configure:20818: checking for string.h
+configure:20824: result: yes
+configure:20818: checking for strings.h
+configure:20824: result: yes
+configure:20818: checking for inttypes.h
+configure:20824: result: yes
+configure:20818: checking for stdint.h
+configure:20824: result: yes
+configure:20828: checking ctype.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking ctype.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for ctype.h
+configure:20940: result: yes
+configure:20828: checking math.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking math.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for math.h
+configure:20940: result: yes
+configure:20828: checking iconv.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking iconv.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for iconv.h
+configure:20940: result: yes
+configure:20828: checking signal.h usability
+configure:20845: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20851: $? = 0
+configure:20865: result: yes
+configure:20869: checking signal.h presence
+configure:20884: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:20890: $? = 0
+configure:20904: result: yes
+configure:20932: checking for signal.h
+configure:20940: result: yes
+configure:20954: checking for size_t
+configure:20984: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:20990: $? = 0
+configure:21005: result: yes
+configure:21018: checking for int64_t
+configure:21048: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:21054: $? = 0
+configure:21069: result: yes
+configure:21447: checking for working memcmp
+configure:21500: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:21503: $? = 0
+configure:21509: ./conftest.exe
+configure:21512: $? = 0
+configure:21528: result: yes
+configure:21543: checking for working strtod
+configure:21594: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:21597: $? = 0
+configure:21603: ./conftest.exe
+configure:21606: $? = 0
+configure:21622: result: yes
+configure:21792: checking for mprotect
+configure:21848: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:21854: $? = 0
+configure:21871: result: yes
+configure:21899: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+conftest.c:42:32: fatal error: sys/mman.h: No such file or directory
+           #include <sys/mman.h>
+                                ^
+compilation terminated.
+configure:21905: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| /* end confdefs.h.  */
+| 
+|           #include <sys/types.h>
+|           #include <sys/mman.h>
+| 
+| int
+| main ()
+| {
+| 
+| 
+|   ;
+|   return 0;
+| }
+configure:21977: checking for malloc
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:63:6: warning: conflicting types for built-in function 'malloc' [enabled by default]
+ char malloc ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for calloc
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:64:6: warning: conflicting types for built-in function 'calloc' [enabled by default]
+ char calloc ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for realloc
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:65:6: warning: conflicting types for built-in function 'realloc' [enabled by default]
+ char realloc ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for free
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:66:6: warning: conflicting types for built-in function 'free' [enabled by default]
+ char free ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for getenv
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for putenv
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for unsetenv
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\cciACoxr.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:80: undefined reference to `unsetenv'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| /* end confdefs.h.  */
+| /* Define unsetenv to an innocuous variant, in case <limits.h> declares unsetenv.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define unsetenv innocuous_unsetenv
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char unsetenv (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef unsetenv
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char unsetenv ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_unsetenv || defined __stub___unsetenv
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return unsetenv ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for qsort
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for abs
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:70:6: warning: conflicting types for built-in function 'abs' [enabled by default]
+ char abs ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for bcopy
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:71:6: warning: conflicting types for built-in function 'bcopy' [enabled by default]
+ char bcopy ();
+      ^
+C:\Users\barknikk\AppData\Local\Temp\ccwWlK7e.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:82: undefined reference to `bcopy'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| /* end confdefs.h.  */
+| /* Define bcopy to an innocuous variant, in case <limits.h> declares bcopy.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define bcopy innocuous_bcopy
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char bcopy (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef bcopy
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char bcopy ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_bcopy || defined __stub___bcopy
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return bcopy ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for memset
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:71:6: warning: conflicting types for built-in function 'memset' [enabled by default]
+ char memset ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for memcpy
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:72:6: warning: conflicting types for built-in function 'memcpy' [enabled by default]
+ char memcpy ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for memmove
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:73:6: warning: conflicting types for built-in function 'memmove' [enabled by default]
+ char memmove ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strlen
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:74:6: warning: conflicting types for built-in function 'strlen' [enabled by default]
+ char strlen ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strlcpy
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\cc6Xr9I7.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:86: undefined reference to `strlcpy'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| #define HAVE_MEMSET 1
+| #define HAVE_MEMCPY 1
+| #define HAVE_MEMMOVE 1
+| #define HAVE_STRLEN 1
+| /* end confdefs.h.  */
+| /* Define strlcpy to an innocuous variant, in case <limits.h> declares strlcpy.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcpy innocuous_strlcpy
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcpy (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef strlcpy
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char strlcpy ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_strlcpy || defined __stub___strlcpy
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return strlcpy ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for strlcat
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\ccgsvhNr.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:86: undefined reference to `strlcat'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| #define HAVE_MEMSET 1
+| #define HAVE_MEMCPY 1
+| #define HAVE_MEMMOVE 1
+| #define HAVE_STRLEN 1
+| /* end confdefs.h.  */
+| /* Define strlcat to an innocuous variant, in case <limits.h> declares strlcat.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcat innocuous_strlcat
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcat (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef strlcat
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char strlcat ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_strlcat || defined __stub___strlcat
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return strlcat ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for strdup
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:75:6: warning: conflicting types for built-in function 'strdup' [enabled by default]
+ char strdup ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _strrev
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _strupr
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _strlwr
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strchr
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:79:6: warning: conflicting types for built-in function 'strchr' [enabled by default]
+ char strchr ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strrchr
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:80:6: warning: conflicting types for built-in function 'strrchr' [enabled by default]
+ char strrchr ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strstr
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:81:6: warning: conflicting types for built-in function 'strstr' [enabled by default]
+ char strstr ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for itoa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _ltoa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _uitoa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\ccUrLLA7.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:95: undefined reference to `_uitoa'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| #define HAVE_MEMSET 1
+| #define HAVE_MEMCPY 1
+| #define HAVE_MEMMOVE 1
+| #define HAVE_STRLEN 1
+| #define HAVE_STRDUP 1
+| #define HAVE__STRREV 1
+| #define HAVE__STRUPR 1
+| #define HAVE__STRLWR 1
+| #define HAVE_STRCHR 1
+| #define HAVE_STRRCHR 1
+| #define HAVE_STRSTR 1
+| #define HAVE_ITOA 1
+| #define HAVE__LTOA 1
+| /* end confdefs.h.  */
+| /* Define _uitoa to an innocuous variant, in case <limits.h> declares _uitoa.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define _uitoa innocuous__uitoa
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char _uitoa (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef _uitoa
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char _uitoa ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub__uitoa || defined __stub____uitoa
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return _uitoa ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for _ultoa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strtol
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strtoul
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _i64toa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _ui64toa
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strtoll
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strtoull
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for atoi
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for atof
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strcmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:93:6: warning: conflicting types for built-in function 'strcmp' [enabled by default]
+ char strcmp ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strncmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:94:6: warning: conflicting types for built-in function 'strncmp' [enabled by default]
+ char strncmp ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _stricmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strcasecmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:96:6: warning: conflicting types for built-in function 'strcasecmp' [enabled by default]
+ char strcasecmp ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for _strnicmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for strncasecmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:98:6: warning: conflicting types for built-in function 'strncasecmp' [enabled by default]
+ char strncasecmp ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for sscanf
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:99:6: warning: conflicting types for built-in function 'sscanf' [enabled by default]
+ char sscanf ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for snprintf
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:100:6: warning: conflicting types for built-in function 'snprintf' [enabled by default]
+ char snprintf ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for vsnprintf
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+conftest.c:101:6: warning: conflicting types for built-in function 'vsnprintf' [enabled by default]
+ char vsnprintf ();
+      ^
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for iconv
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\ccIVfYFj.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:113: undefined reference to `iconv'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| #define HAVE_MEMSET 1
+| #define HAVE_MEMCPY 1
+| #define HAVE_MEMMOVE 1
+| #define HAVE_STRLEN 1
+| #define HAVE_STRDUP 1
+| #define HAVE__STRREV 1
+| #define HAVE__STRUPR 1
+| #define HAVE__STRLWR 1
+| #define HAVE_STRCHR 1
+| #define HAVE_STRRCHR 1
+| #define HAVE_STRSTR 1
+| #define HAVE_ITOA 1
+| #define HAVE__LTOA 1
+| #define HAVE__ULTOA 1
+| #define HAVE_STRTOL 1
+| #define HAVE_STRTOUL 1
+| #define HAVE__I64TOA 1
+| #define HAVE__UI64TOA 1
+| #define HAVE_STRTOLL 1
+| #define HAVE_STRTOULL 1
+| #define HAVE_ATOI 1
+| #define HAVE_ATOF 1
+| #define HAVE_STRCMP 1
+| #define HAVE_STRNCMP 1
+| #define HAVE__STRICMP 1
+| #define HAVE_STRCASECMP 1
+| #define HAVE__STRNICMP 1
+| #define HAVE_STRNCASECMP 1
+| #define HAVE_SSCANF 1
+| #define HAVE_SNPRINTF 1
+| #define HAVE_VSNPRINTF 1
+| /* end confdefs.h.  */
+| /* Define iconv to an innocuous variant, in case <limits.h> declares iconv.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define iconv innocuous_iconv
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char iconv (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef iconv
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char iconv ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_iconv || defined __stub___iconv
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return iconv ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for sigaction
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+C:\Users\barknikk\AppData\Local\Temp\cc8GfnwV.o: In function `main':
+c:\DriveD\devlibs\SDL-1.2.13/conftest.c:113: undefined reference to `sigaction'
+collect2.exe: error: ld returned 1 exit status
+configure:22039: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define _GNU_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SDL_BYTEORDER 1234
+| #define HAVE_LIBC 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_STDIO_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STDDEF_H 1
+| #define HAVE_STDARG_H 1
+| #define HAVE_MALLOC_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_CTYPE_H 1
+| #define HAVE_MATH_H 1
+| #define HAVE_ICONV_H 1
+| #define HAVE_SIGNAL_H 1
+| #define SDL_HAS_64BIT_TYPE 1
+| #define HAVE_MEMCMP 1
+| #define HAVE_STRTOD 1
+| #define HAVE_MALLOC 1
+| #define HAVE_CALLOC 1
+| #define HAVE_REALLOC 1
+| #define HAVE_FREE 1
+| #define HAVE_GETENV 1
+| #define HAVE_PUTENV 1
+| #define HAVE_QSORT 1
+| #define HAVE_ABS 1
+| #define HAVE_MEMSET 1
+| #define HAVE_MEMCPY 1
+| #define HAVE_MEMMOVE 1
+| #define HAVE_STRLEN 1
+| #define HAVE_STRDUP 1
+| #define HAVE__STRREV 1
+| #define HAVE__STRUPR 1
+| #define HAVE__STRLWR 1
+| #define HAVE_STRCHR 1
+| #define HAVE_STRRCHR 1
+| #define HAVE_STRSTR 1
+| #define HAVE_ITOA 1
+| #define HAVE__LTOA 1
+| #define HAVE__ULTOA 1
+| #define HAVE_STRTOL 1
+| #define HAVE_STRTOUL 1
+| #define HAVE__I64TOA 1
+| #define HAVE__UI64TOA 1
+| #define HAVE_STRTOLL 1
+| #define HAVE_STRTOULL 1
+| #define HAVE_ATOI 1
+| #define HAVE_ATOF 1
+| #define HAVE_STRCMP 1
+| #define HAVE_STRNCMP 1
+| #define HAVE__STRICMP 1
+| #define HAVE_STRCASECMP 1
+| #define HAVE__STRNICMP 1
+| #define HAVE_STRNCASECMP 1
+| #define HAVE_SSCANF 1
+| #define HAVE_SNPRINTF 1
+| #define HAVE_VSNPRINTF 1
+| /* end confdefs.h.  */
+| /* Define sigaction to an innocuous variant, in case <limits.h> declares sigaction.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define sigaction innocuous_sigaction
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char sigaction (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef sigaction
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char sigaction ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_sigaction || defined __stub___sigaction
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return sigaction ();
+|   ;
+|   return 0;
+| }
+configure:22057: result: no
+configure:21977: checking for setjmp
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:21977: checking for nanosleep
+configure:22033: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c  >&5
+configure:22039: $? = 0
+configure:22057: result: yes
+configure:22068: checking for libiconv_open in -liconv
+configure:22103: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c -liconv   >&5
+configure:22109: $? = 0
+configure:22127: result: yes
+configure:22133: checking for pow in -lm
+configure:22168: gcc -o conftest.exe -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 -L/mingw/../devlibs/lib  conftest.c -lm   >&5
+conftest.c:88:6: warning: conflicting types for built-in function 'pow' [enabled by default]
+ char pow ();
+      ^
+configure:22174: $? = 0
+configure:22192: result: yes
+configure:31284: checking Win32 compiler
+configure:31311: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:31317: $? = 0
+configure:31333: result: yes
+configure:31388: checking ddraw.h usability
+configure:31405: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:31411: $? = 0
+configure:31425: result: yes
+configure:31429: checking ddraw.h presence
+configure:31444: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:31450: $? = 0
+configure:31464: result: yes
+configure:31492: checking for ddraw.h
+configure:31499: result: yes
+configure:31518: checking dsound.h usability
+configure:31535: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:31541: $? = 0
+configure:31555: result: yes
+configure:31559: checking dsound.h presence
+configure:31574: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:31580: $? = 0
+configure:31594: result: yes
+configure:31622: checking for dsound.h
+configure:31629: result: yes
+configure:31648: checking dinput.h usability
+configure:31665: gcc -c -g -O2 -I./include -D_GNU_SOURCE=1 -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c >&5
+configure:31671: $? = 0
+configure:31685: result: yes
+configure:31689: checking dinput.h presence
+configure:31704: gcc -E -I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1 conftest.c
+configure:31710: $? = 0
+configure:31724: result: yes
+configure:31752: checking for dinput.h
+configure:31759: result: yes
+configure:26350: checking for yasm
+configure:26383: result: no
+configure:26318: checking to see if  supports unquoted-sections
+./configure: line 26320: -f: command not found
+configure:26326: result: no
+configure:26397: checking for nasm
+configure:26415: found /mingw/bin/nasm
+configure:26427: result: /mingw/bin/nasm
+configure:26318: checking to see if /mingw/bin/nasm supports symbol-visibility
+symbol-visibility:2: error: COFF format does not support any special symbol types
+configure:26326: result: no
+configure:34367: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by config.status, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on BHIG4NYZN1
+
+config.status:681: creating Makefile
+config.status:681: creating sdl-config
+config.status:681: creating SDL.spec
+config.status:681: creating SDL.qpg
+config.status:681: creating sdl.pc
+config.status:681: creating include/SDL_config.h
+config.status:986: include/SDL_config.h is unchanged
+config.status:999: executing default commands
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=i686-pc-mingw32
+ac_cv_c_bigendian=no
+ac_cv_c_compiler_gnu=yes
+ac_cv_c_const=yes
+ac_cv_c_inline=inline
+ac_cv_c_volatile=yes
+ac_cv_cxx_compiler_gnu=yes
+ac_cv_env_CCC_set=
+ac_cv_env_CCC_value=
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=set
+ac_cv_env_CPPFLAGS_value=-I/mingw/../devlibs/include
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_CXXCPP_set=
+ac_cv_env_CXXCPP_value=
+ac_cv_env_CXXFLAGS_set=
+ac_cv_env_CXXFLAGS_value=
+ac_cv_env_CXX_set=
+ac_cv_env_CXX_value=
+ac_cv_env_F77_set=
+ac_cv_env_F77_value=
+ac_cv_env_FFLAGS_set=
+ac_cv_env_FFLAGS_value=
+ac_cv_env_LDFLAGS_set=set
+ac_cv_env_LDFLAGS_value=-L/mingw/../devlibs/lib
+ac_cv_env_LIBS_set=
+ac_cv_env_LIBS_value=
+ac_cv_env_XMKMF_set=
+ac_cv_env_XMKMF_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_exeext=.exe
+ac_cv_f77_compiler_gnu=no
+ac_cv_func__i64toa=yes
+ac_cv_func__ltoa=yes
+ac_cv_func__stricmp=yes
+ac_cv_func__strlwr=yes
+ac_cv_func__strnicmp=yes
+ac_cv_func__strrev=yes
+ac_cv_func__strupr=yes
+ac_cv_func__ui64toa=yes
+ac_cv_func__uitoa=no
+ac_cv_func__ultoa=yes
+ac_cv_func_abs=yes
+ac_cv_func_atof=yes
+ac_cv_func_atoi=yes
+ac_cv_func_bcopy=no
+ac_cv_func_calloc=yes
+ac_cv_func_free=yes
+ac_cv_func_getenv=yes
+ac_cv_func_iconv=no
+ac_cv_func_itoa=yes
+ac_cv_func_malloc=yes
+ac_cv_func_memcmp_working=yes
+ac_cv_func_memcpy=yes
+ac_cv_func_memmove=yes
+ac_cv_func_memset=yes
+ac_cv_func_mprotect=yes
+ac_cv_func_nanosleep=yes
+ac_cv_func_putenv=yes
+ac_cv_func_qsort=yes
+ac_cv_func_realloc=yes
+ac_cv_func_setjmp=yes
+ac_cv_func_sigaction=no
+ac_cv_func_snprintf=yes
+ac_cv_func_sscanf=yes
+ac_cv_func_strcasecmp=yes
+ac_cv_func_strchr=yes
+ac_cv_func_strcmp=yes
+ac_cv_func_strdup=yes
+ac_cv_func_strlcat=no
+ac_cv_func_strlcpy=no
+ac_cv_func_strlen=yes
+ac_cv_func_strncasecmp=yes
+ac_cv_func_strncmp=yes
+ac_cv_func_strrchr=yes
+ac_cv_func_strstr=yes
+ac_cv_func_strtod=yes
+ac_cv_func_strtol=yes
+ac_cv_func_strtoll=yes
+ac_cv_func_strtoul=yes
+ac_cv_func_strtoull=yes
+ac_cv_func_unsetenv=no
+ac_cv_func_vsnprintf=yes
+ac_cv_header_ctype_h=yes
+ac_cv_header_ddraw_h=yes
+ac_cv_header_dinput_h=yes
+ac_cv_header_dlfcn_h=no
+ac_cv_header_dsound_h=yes
+ac_cv_header_iconv_h=yes
+ac_cv_header_inttypes_h=yes
+ac_cv_header_malloc_h=yes
+ac_cv_header_math_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_signal_h=yes
+ac_cv_header_stdarg_h=yes
+ac_cv_header_stdc=yes
+ac_cv_header_stddef_h=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdio_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_unistd_h=yes
+ac_cv_host=i686-pc-mingw32
+ac_cv_lib_iconv_libiconv_open=yes
+ac_cv_lib_m_pow=yes
+ac_cv_objext=o
+ac_cv_path_EGREP='/bin/grep -E'
+ac_cv_path_GREP=/bin/grep
+ac_cv_path_NASM=/mingw/bin/nasm
+ac_cv_path_install='/bin/install -c'
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_CXXCPP='g++ -E'
+ac_cv_prog_WINDRES=windres
+ac_cv_prog_ac_ct_AR=ar
+ac_cv_prog_ac_ct_AS=as
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_ac_ct_CXX=g++
+ac_cv_prog_ac_ct_DLLTOOL=dlltool
+ac_cv_prog_ac_ct_OBJDUMP=objdump
+ac_cv_prog_ac_ct_RANLIB=ranlib
+ac_cv_prog_ac_ct_STRIP=strip
+ac_cv_prog_cc_c89=
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cxx_g=yes
+ac_cv_prog_f77_g=no
+ac_cv_prog_make_make_set=yes
+ac_cv_type_int64_t=yes
+ac_cv_type_size_t=yes
+lt_cv_deplibs_check_method=pass_all
+lt_cv_file_magic_cmd='$OBJDUMP -f'
+lt_cv_file_magic_test_file=
+lt_cv_ld_reload_flag=-r
+lt_cv_objdir=.libs
+lt_cv_path_LD=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe
+lt_cv_path_LDCXX=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe
+lt_cv_path_NM=/mingw/bin/nm
+lt_cv_path_SED=/bin/sed
+lt_cv_prog_compiler_c_o=yes
+lt_cv_prog_compiler_c_o_CXX=yes
+lt_cv_prog_compiler_rtti_exceptions=no
+lt_cv_prog_gnu_ld=yes
+lt_cv_prog_gnu_ldcxx=yes
+lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)\{0,1\}$/\1 \2 \2/p'\'''
+lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \([^ ]*\) \([^ ]*\)$/  {"\2", (lt_ptr) \&\2},/p'\'''
+lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^. .* \(.*\)$/extern int \1;/p'\'''
+lt_cv_sys_max_cmd_len=8192
+lt_lt_cv_prog_compiler_c_o='"yes"'
+lt_lt_cv_prog_compiler_c_o_CXX='"yes"'
+lt_lt_cv_sys_global_symbol_pipe='"sed -n -e '\''s/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)\\{0,1\\}\$/\\1 \\2 \\2/p'\''"'
+lt_lt_cv_sys_global_symbol_to_c_name_address='"sed -n -e '\''s/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'\''"'
+lt_lt_cv_sys_global_symbol_to_cdecl='"sed -n -e '\''s/^. .* \\(.*\\)\$/extern int \\1;/p'\''"'
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+ALLOCA=''
+ALSA_CFLAGS=''
+ALSA_LIBS=''
+AR='ar'
+ARTSCONFIG=''
+AS='as'
+BUILD_CFLAGS='-g -O2 -I/mingw/../devlibs/include'
+BUILD_LDFLAGS='-L/mingw/../devlibs/lib'
+CC='gcc'
+CFLAGS='-g -O2 -I./include -D_GNU_SOURCE=1'
+CPP='gcc -E'
+CPPFLAGS='-I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1'
+CXX='g++'
+CXXCPP='g++ -E'
+CXXFLAGS='-g -O2'
+DEFS='-DHAVE_CONFIG_H'
+DIRECTFBCONFIG=''
+DLLTOOL='dlltool'
+ECHO='echo'
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+EGREP='/bin/grep -E'
+ENABLE_SHARED_FALSE='#'
+ENABLE_SHARED_TRUE=''
+ENABLE_STATIC_FALSE='#'
+ENABLE_STATIC_TRUE=''
+ESD_CFLAGS=''
+ESD_CONFIG=''
+ESD_LIBS=''
+EXEEXT='.exe'
+EXTRA_CFLAGS='-I./include -D_GNU_SOURCE=1'
+EXTRA_LDFLAGS=' -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid'
+F77=''
+FFLAGS=''
+GREP='/bin/grep'
+INCLUDE='-I./include'
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+LDFLAGS='-L/mingw/../devlibs/lib '
+LIBOBJS=''
+LIBS=''
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+LN_S='ln -s'
+LTLIBOBJS=''
+LT_AGE='11'
+LT_CURRENT='11'
+LT_RELEASE='1.2'
+LT_REVISION='2'
+NASM='/mingw/bin/nasm'
+NASMFLAGS='-f win32 -I ./src/hermes/'
+OBJDUMP='objdump'
+OBJECTS='$(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o'
+OBJEXT='o'
+OSMESA_CONFIG=''
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+PKG_CONFIG=''
+POW_LIB=''
+PTH_CONFIG=''
+RANLIB='ranlib'
+SDLMAIN_OBJECTS='$(objects)/SDL_win32_main.o'
+SDLMAIN_SOURCES='./src/main/win32/*.c'
+SDL_BINARY_AGE='13'
+SDL_CFLAGS='-D_GNU_SOURCE=1 -Dmain=SDL_main'
+SDL_INTERFACE_AGE='2'
+SDL_LIBS='-lmingw32 -lSDLmain -lSDL  -mwindows'
+SDL_MAJOR_VERSION='1'
+SDL_MICRO_VERSION='13'
+SDL_MINOR_VERSION='2'
+SDL_RLD_FLAGS=''
+SDL_STATIC_LIBS='-lmingw32 -lSDLmain -lSDL  -mwindows'
+SDL_VERSION='1.2.13'
+SET_MAKE=''
+SHELL='/bin/sh'
+SOURCES=' ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc'
+STRIP='strip'
+WINDRES='windres'
+XMKMF=''
+X_CFLAGS=''
+X_EXTRA_LIBS=''
+X_LIBS=''
+X_PRE_LIBS=''
+ac_aux_dir='./build-scripts'
+ac_ct_CC='gcc'
+ac_ct_CXX='g++'
+ac_ct_F77=''
+bindir='${exec_prefix}/bin'
+build='i686-pc-mingw32'
+build_alias=''
+build_cpu='i686'
+build_os='mingw32'
+build_vendor='pc'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+docdir='${datarootdir}/doc/${PACKAGE}'
+dvidir='${docdir}'
+exec_prefix='${prefix}'
+host='i686-pc-mingw32'
+host_alias=''
+host_cpu='i686'
+host_os='mingw32'
+host_vendor='pc'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${datarootdir}/info'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localedir='${datarootdir}/locale'
+localstatedir='${prefix}/var'
+mandir='${datarootdir}/man'
+oldincludedir='/usr/include'
+pdfdir='${docdir}'
+prefix='/mingw/../devlibs'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+sbindir='${exec_prefix}/sbin'
+sharedstatedir='${prefix}/com'
+sysconfdir='${prefix}/etc'
+target_alias=''
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define PACKAGE_NAME ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define PACKAGE_STRING ""
+#define PACKAGE_BUGREPORT ""
+#define _GNU_SOURCE 1
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_UNISTD_H 1
+#define SDL_BYTEORDER 1234
+#define HAVE_LIBC 1
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STDDEF_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_SIGNAL_H 1
+#define SDL_HAS_64BIT_TYPE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRTOD 1
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_STRLEN 1
+#define HAVE_STRDUP 1
+#define HAVE__STRREV 1
+#define HAVE__STRUPR 1
+#define HAVE__STRLWR 1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_ITOA 1
+#define HAVE__LTOA 1
+#define HAVE__ULTOA 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+#define HAVE__I64TOA 1
+#define HAVE__UI64TOA 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE__STRICMP 1
+#define HAVE_STRCASECMP 1
+#define HAVE__STRNICMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP 1
+#define SDL_ASSEMBLY_ROUTINES 1
+#define SDL_VIDEO_DRIVER_DUMMY 1
+#define SDL_AUDIO_DRIVER_DISK 1
+#define SDL_AUDIO_DRIVER_DUMMY 1
+#define SDL_VIDEO_DRIVER_WINDIB 1
+#define SDL_VIDEO_OPENGL 1
+#define SDL_VIDEO_OPENGL_WGL 1
+#define SDL_VIDEO_DRIVER_DDRAW 1
+#define SDL_HERMES_BLITTERS 1
+#define SDL_AUDIO_DRIVER_WAVEOUT 1
+#define SDL_AUDIO_DRIVER_DSOUND 1
+#define SDL_JOYSTICK_WINMM 1
+#define SDL_CDROM_WIN32 1
+#define SDL_THREAD_WIN32 1
+#define SDL_TIMER_WIN32 1
+#define SDL_LOADSO_WIN32 1
+
+configure: exit 0
diff -ruN SDL-1.2.13/config.status SDL-1.2.13_OOx64/config.status
--- SDL-1.2.13/config.status	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/config.status	2013-10-03 18:42:32 +0000
@@ -0,0 +1,1015 @@
+#! /bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=${CONFIG_SHELL-/bin/sh}
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+# Files that config.status was made for.
+config_files=" Makefile sdl-config SDL.spec SDL.qpg sdl.pc"
+config_headers=" include/SDL_config.h"
+config_commands=" default"
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+  --header=FILE[:TEMPLATE]
+		   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+ac_cs_version="\
+config.status
+configured by ./configure, generated by GNU Autoconf 2.61,
+  with options \"'--prefix=/mingw/../devlibs' 'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include'\"
+
+Copyright (C) 2006 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='/c/DriveD/devlibs/SDL-1.2.13'
+srcdir='.'
+INSTALL='/bin/install -c'
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    { echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+if $ac_cs_recheck; then
+  echo "running CONFIG_SHELL=/bin/sh /bin/sh ./configure " '--prefix=/mingw/../devlibs' 'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include' $ac_configure_extra_args " --no-create --no-recursion" >&6
+  CONFIG_SHELL=/bin/sh
+  export CONFIG_SHELL
+  exec /bin/sh "./configure" '--prefix=/mingw/../devlibs' 'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include' $ac_configure_extra_args --no-create --no-recursion
+fi
+
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  echo "$ac_log"
+} >&5
+
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "include/SDL_config.h") CONFIG_HEADERS="$CONFIG_HEADERS include/SDL_config.h" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "sdl-config") CONFIG_FILES="$CONFIG_FILES sdl-config" ;;
+    "SDL.spec") CONFIG_FILES="$CONFIG_FILES SDL.spec" ;;
+    "SDL.qpg") CONFIG_FILES="$CONFIG_FILES SDL.qpg" ;;
+    "sdl.pc") CONFIG_FILES="$CONFIG_FILES sdl.pc" ;;
+    "default") CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
+
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+#
+# Set up the sed scripts for CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+
+cat >"$tmp/subs-1.sed" <<\CEOF
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@SHELL@,|#_!!_#|/bin/sh,g
+s,@PATH_SEPARATOR@,|#_!!_#|:,g
+s,@PACKAGE_NAME@,|#_!!_#|,g
+s,@PACKAGE_TARNAME@,|#_!!_#|,g
+s,@PACKAGE_VERSION@,|#_!!_#|,g
+s,@PACKAGE_STRING@,|#_!!_#|,g
+s,@PACKAGE_BUGREPORT@,|#_!!_#|,g
+s,@exec_prefix@,|#_!!_#|${prefix},g
+s,@prefix@,|#_!!_#|/mingw/../devlibs,g
+s,@program_transform_name@,|#_!!_#|s\,x\,x\,,g
+s,@bindir@,|#_!!_#|${exec_prefix}/bin,g
+s,@sbindir@,|#_!!_#|${exec_prefix}/sbin,g
+s,@libexecdir@,|#_!!_#|${exec_prefix}/libexec,g
+s,@datarootdir@,|#_!!_#|${prefix}/share,g
+s,@datadir@,|#_!!_#|${datarootdir},g
+s,@sysconfdir@,|#_!!_#|${prefix}/etc,g
+s,@sharedstatedir@,|#_!!_#|${prefix}/com,g
+s,@localstatedir@,|#_!!_#|${prefix}/var,g
+s,@includedir@,|#_!!_#|${prefix}/include,g
+s,@oldincludedir@,|#_!!_#|/usr/include,g
+s,@docdir@,|#_!!_#|${datarootdir}/doc/${PACKAGE},g
+s,@infodir@,|#_!!_#|${datarootdir}/info,g
+s,@htmldir@,|#_!!_#|${docdir},g
+s,@dvidir@,|#_!!_#|${docdir},g
+s,@pdfdir@,|#_!!_#|${docdir},g
+s,@psdir@,|#_!!_#|${docdir},g
+s,@libdir@,|#_!!_#|${exec_prefix}/lib,g
+s,@localedir@,|#_!!_#|${datarootdir}/locale,g
+s,@mandir@,|#_!!_#|${datarootdir}/man,g
+s,@DEFS@,|#_!!_#|-DHAVE_CONFIG_H,g
+s,@ECHO_C@,|#_!!_#|,g
+s,@ECHO_N@,|#_!!_#|-n,g
+s,@ECHO_T@,|#_!!_#|,g
+s,@LIBS@,|#_!!_#|,g
+s,@build_alias@,|#_!!_#|,g
+s,@host_alias@,|#_!!_#|,g
+s,@target_alias@,|#_!!_#|,g
+s,@SDL_MAJOR_VERSION@,|#_!!_#|1,g
+s,@SDL_MINOR_VERSION@,|#_!!_#|2,g
+s,@SDL_MICRO_VERSION@,|#_!!_#|13,g
+s,@SDL_INTERFACE_AGE@,|#_!!_#|2,g
+s,@SDL_BINARY_AGE@,|#_!!_#|13,g
+s,@SDL_VERSION@,|#_!!_#|1.2.13,g
+s,@LT_RELEASE@,|#_!!_#|1.2,g
+s,@LT_CURRENT@,|#_!!_#|11,g
+s,@LT_REVISION@,|#_!!_#|2,g
+s,@LT_AGE@,|#_!!_#|11,g
+s,@build@,|#_!!_#|i686-pc-mingw32,g
+s,@build_cpu@,|#_!!_#|i686,g
+s,@build_vendor@,|#_!!_#|pc,g
+s,@build_os@,|#_!!_#|mingw32,g
+s,@host@,|#_!!_#|i686-pc-mingw32,g
+s,@host_cpu@,|#_!!_#|i686,g
+s,@host_vendor@,|#_!!_#|pc,g
+s,@host_os@,|#_!!_#|mingw32,g
+s,@CC@,|#_!!_#|gcc,g
+s,@CFLAGS@,|#_!!_#|-g -O2 -I./include -D_GNU_SOURCE=1,g
+s,@LDFLAGS@,|#_!!_#|-L/mingw/../devlibs/lib ,g
+s,@CPPFLAGS@,|#_!!_#|-I/mingw/../devlibs/include -I./include -D_GNU_SOURCE=1,g
+s,@ac_ct_CC@,|#_!!_#|gcc,g
+s,@EXEEXT@,|#_!!_#|.exe,g
+s,@OBJEXT@,|#_!!_#|o,g
+s,@CPP@,|#_!!_#|gcc -E,g
+s,@GREP@,|#_!!_#|/bin/grep,g
+s,@EGREP@,|#_!!_#|/bin/grep -E,g
+s,@LN_S@,|#_!!_#|ln -s,g
+s,@ECHO@,|#_!!_#|echo,g
+s,@AR@,|#_!!_#|ar,g
+s,@RANLIB@,|#_!!_#|ranlib,g
+s,@STRIP@,|#_!!_#|strip,g
+s,@DLLTOOL@,|#_!!_#|dlltool,g
+s,@AS@,|#_!!_#|as,g
+s,@OBJDUMP@,|#_!!_#|objdump,g
+s,@CXX@,|#_!!_#|g++,g
+s,@CXXFLAGS@,|#_!!_#|-g -O2,g
+s,@ac_ct_CXX@,|#_!!_#|g++,g
+s,@CXXCPP@,|#_!!_#|g++ -E,g
+s,@F77@,|#_!!_#|,g
+s,@FFLAGS@,|#_!!_#|,g
+s,@ac_ct_F77@,|#_!!_#|,g
+s,@LIBTOOL@,|#_!!_#|$(SHELL) $(top_builddir)/libtool,g
+s,@INSTALL_PROGRAM@,|#_!!_#|${INSTALL},g
+s,@INSTALL_SCRIPT@,|#_!!_#|${INSTALL},g
+s,@INSTALL_DATA@,|#_!!_#|${INSTALL} -m 644,g
+s,@SET_MAKE@,|#_!!_#|,g
+s,@WINDRES@,|#_!!_#|windres,g
+s,@ALLOCA@,|#_!!_#|,g
+s,@LIBOBJS@,|#_!!_#|,g
+s,@POW_LIB@,|#_!!_#|,g
+s,@ALSA_CFLAGS@,|#_!!_#|,g
+s,@ALSA_LIBS@,|#_!!_#|,g
+s,@ESD_CONFIG@,|#_!!_#|,g
+s,@ESD_CFLAGS@,|#_!!_#|,g
+s,@ESD_LIBS@,|#_!!_#|,g
+s,@PKG_CONFIG@,|#_!!_#|,g
+s,@ARTSCONFIG@,|#_!!_#|,g
+s,@NASM@,|#_!!_#|/mingw/bin/nasm,g
+CEOF
+cat >"$tmp/subs-2.sed" <<\CEOF
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
+s,@NASMFLAGS@,|#_!!_#|-f win32 -I ./src/hermes/,g
+s,@XMKMF@,|#_!!_#|,g
+s,@X_CFLAGS@,|#_!!_#|,g
+s,@X_PRE_LIBS@,|#_!!_#|,g
+s,@X_LIBS@,|#_!!_#|,g
+s,@X_EXTRA_LIBS@,|#_!!_#|,g
+s,@DIRECTFBCONFIG@,|#_!!_#|,g
+s,@OSMESA_CONFIG@,|#_!!_#|,g
+s,@PTH_CONFIG@,|#_!!_#|,g
+s,@SDL_CFLAGS@,|#_!!_#|-D_GNU_SOURCE=1 -Dmain=SDL_main,g
+s,@SDL_LIBS@,|#_!!_#|-lmingw32 -lSDLmain -lSDL  -mwindows,g
+s,@SDL_STATIC_LIBS@,|#_!!_#|-lmingw32 -lSDLmain -lSDL  -mwindows,g
+s,@SDL_RLD_FLAGS@,|#_!!_#|,g
+s,@ENABLE_SHARED_TRUE@,|#_!!_#|,g
+s,@ENABLE_SHARED_FALSE@,|#_!!_#|#,g
+s,@ENABLE_STATIC_TRUE@,|#_!!_#|,g
+s,@ENABLE_STATIC_FALSE@,|#_!!_#|#,g
+s,@ac_aux_dir@,|#_!!_#|./build-scripts,g
+s,@INCLUDE@,|#_!!_#|-I./include,g
+s,@SOURCES@,|#_!!_#| ./src/*.c ./src/audio/*.c ./src/cdrom/*.c ./src/cpuinfo/*.c ./src/events/*.c ./src/file/*.c ./src/stdlib/*.c ./src/thread/*.c ./src/timer/*.c ./src/video/*.c ./src/joystick/*.c ./src/video/dummy/*.c ./src/audio/disk/*.c ./src/audio/dummy/*.c ./src/video/wincommon/*.c ./src/video/windib/*.c ./src/video/windx5/*.c ./src/hermes/*.asm ./src/audio/windib/*.c ./src/audio/windx5/*.c ./src/joystick/win32/*.c ./src/cdrom/win32/*.c ./src/thread/win32/SDL_sysmutex.c ./src/thread/win32/SDL_syssem.c ./src/thread/win32/SDL_systhread.c ./src/thread/generic/SDL_syscond.c ./src/timer/win32/*.c ./src/loadso/win32/*.c ./src/main/win32/*.rc,g
+s,@OBJECTS@,|#_!!_#|$(objects)/SDL.lo $(objects)/SDL_error.lo $(objects)/SDL_fatal.lo $(objects)/SDL_audio.lo $(objects)/SDL_audiocvt.lo $(objects)/SDL_audiodev.lo $(objects)/SDL_mixer.lo $(objects)/SDL_mixer_MMX.lo $(objects)/SDL_mixer_MMX_VC.lo $(objects)/SDL_mixer_m68k.lo $(objects)/SDL_wave.lo $(objects)/SDL_cdrom.lo $(objects)/SDL_cpuinfo.lo $(objects)/SDL_active.lo $(objects)/SDL_events.lo $(objects)/SDL_expose.lo $(objects)/SDL_keyboard.lo $(objects)/SDL_mouse.lo $(objects)/SDL_quit.lo $(objects)/SDL_resize.lo $(objects)/SDL_rwops.lo $(objects)/SDL_getenv.lo $(objects)/SDL_iconv.lo $(objects)/SDL_malloc.lo $(objects)/SDL_qsort.lo $(objects)/SDL_stdlib.lo $(objects)/SDL_string.lo $(objects)/SDL_thread.lo $(objects)/SDL_timer.lo $(objects)/SDL_RLEaccel.lo $(objects)/SDL_blit.lo $(objects)/SDL_blit_0.lo $(objects)/SDL_blit_1.lo $(objects)/SDL_blit_A.lo $(objects)/SDL_blit_N.lo $(objects)/SDL_bmp.lo $(objects)/SDL_cursor.lo $(objects)/SDL_gamma.lo $(objects)/SDL_pixels.lo $(objects)/SDL_stretch.lo $(objects)/SDL_surface.lo $(objects)/SDL_video.lo $(objects)/SDL_yuv.lo $(objects)/SDL_yuv_mmx.lo $(objects)/SDL_yuv_sw.lo $(objects)/SDL_joystick.lo $(objects)/SDL_nullevents.lo $(objects)/SDL_nullmouse.lo $(objects)/SDL_nullvideo.lo $(objects)/SDL_diskaudio.lo $(objects)/SDL_dummyaudio.lo $(objects)/SDL_sysevents.lo $(objects)/SDL_sysmouse.lo $(objects)/SDL_syswm.lo $(objects)/SDL_wingl.lo $(objects)/SDL_dibevents.lo $(objects)/SDL_dibvideo.lo $(objects)/SDL_dx5events.lo $(objects)/SDL_dx5video.lo $(objects)/SDL_dx5yuv.lo $(objects)/mmx_main.lo $(objects)/mmxp2_32.lo $(objects)/x86_main.lo $(objects)/x86p_16.lo $(objects)/x86p_32.lo $(objects)/SDL_dibaudio.lo $(objects)/SDL_dx5audio.lo $(objects)/SDL_mmjoystick.lo $(objects)/SDL_syscdrom.lo $(objects)/SDL_sysmutex.lo $(objects)/SDL_syssem.lo $(objects)/SDL_systhread.lo $(objects)/SDL_syscond.lo $(objects)/SDL_systimer.lo $(objects)/SDL_sysloadso.lo $(objects)/version.o,g
+s,@SDLMAIN_SOURCES@,|#_!!_#|./src/main/win32/*.c,g
+s,@SDLMAIN_OBJECTS@,|#_!!_#|$(objects)/SDL_win32_main.o,g
+s,@BUILD_CFLAGS@,|#_!!_#|-g -O2 -I/mingw/../devlibs/include,g
+s,@EXTRA_CFLAGS@,|#_!!_#|-I./include -D_GNU_SOURCE=1,g
+s,@BUILD_LDFLAGS@,|#_!!_#|-L/mingw/../devlibs/lib,g
+s,@EXTRA_LDFLAGS@,|#_!!_#| -liconv -lm -luser32 -lgdi32 -lwinmm -ldxguid,g
+s,@LTLIBOBJS@,|#_!!_#|,g
+:end
+s/|#_!!_#|//g
+CEOF
+fi # test -n "$CONFIG_FILES"
+
+
+for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
+echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      ac_file_inputs="$ac_file_inputs $ac_f"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input="Generated from "`IFS=:
+	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    fi
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin";;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+case `sed -n '/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+' $ac_file_inputs` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  ac_datarootdir_hack='
+  s&@datadir@&${datarootdir}&g
+  s&@docdir@&${datarootdir}/doc/${PACKAGE}&g
+  s&@infodir@&${datarootdir}/info&g
+  s&@localedir@&${datarootdir}/locale&g
+  s&@mandir@&${datarootdir}/man&g
+    s&\${datarootdir}&${prefix}/share&g' ;;
+esac
+  sed "/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}
+
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s&@configure_input@&$configure_input&;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+" $ac_file_inputs | sed -f "$tmp/subs-1.sed" | sed -f "$tmp/subs-2.sed" >$tmp/out
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out"; rm -f "$tmp/out";;
+  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
+  esac
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+    # First, check the format of the line:
+    cat >"$tmp/defines.sed" <<\CEOF
+/^[	 ]*#[	 ]*undef[	 ][	 ]*[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*[	 ]*$/b def
+/^[	 ]*#[	 ]*define[	 ][	 ]*[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*[(	 ]/b def
+b
+:def
+s/$/ /
+s,^\([	 #]*\)[^	 ]*\([	 ]*PACKAGE_NAME\)[	 (].*,\1define\2 "" ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*PACKAGE_TARNAME\)[	 (].*,\1define\2 "" ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*PACKAGE_VERSION\)[	 (].*,\1define\2 "" ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*PACKAGE_STRING\)[	 (].*,\1define\2 "" ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*PACKAGE_BUGREPORT\)[	 (].*,\1define\2 "" ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*_GNU_SOURCE\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*STDC_HEADERS\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SYS_TYPES_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SYS_STAT_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDLIB_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRING_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMORY_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRINGS_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_INTTYPES_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDINT_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_UNISTD_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_BYTEORDER\)[	 (].*,\1define\2 1234 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_LIBC\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*STDC_HEADERS\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SYS_TYPES_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDIO_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDLIB_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDDEF_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDARG_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MALLOC_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMORY_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRING_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRINGS_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_INTTYPES_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STDINT_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_CTYPE_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MATH_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_ICONV_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SIGNAL_H\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_HAS_64BIT_TYPE\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMCMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRTOD\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MALLOC\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_CALLOC\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_REALLOC\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_FREE\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_GETENV\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_PUTENV\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_QSORT\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_ABS\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMSET\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMCPY\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_MEMMOVE\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRLEN\)[	 (].*,\1define\2 1 ,
+CEOF
+    sed -f "$tmp/defines.sed" $ac_file_inputs >"$tmp/out1"
+    # First, check the format of the line:
+    cat >"$tmp/defines.sed" <<\CEOF
+/^[	 ]*#[	 ]*undef[	 ][	 ]*[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*[	 ]*$/b def
+/^[	 ]*#[	 ]*define[	 ][	 ]*[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*[(	 ]/b def
+b
+:def
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRDUP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__STRREV\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__STRUPR\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__STRLWR\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRCHR\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRRCHR\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRSTR\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_ITOA\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__LTOA\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__ULTOA\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRTOL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRTOUL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__I64TOA\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__UI64TOA\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRTOLL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRTOULL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_ATOI\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_ATOF\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRCMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRNCMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__STRICMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRCASECMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE__STRNICMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_STRNCASECMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SSCANF\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SNPRINTF\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_VSNPRINTF\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_SETJMP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*HAVE_NANOSLEEP\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_ASSEMBLY_ROUTINES\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_VIDEO_DRIVER_DUMMY\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_AUDIO_DRIVER_DISK\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_AUDIO_DRIVER_DUMMY\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_VIDEO_DRIVER_WINDIB\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_VIDEO_OPENGL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_VIDEO_OPENGL_WGL\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_VIDEO_DRIVER_DDRAW\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_HERMES_BLITTERS\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_AUDIO_DRIVER_WAVEOUT\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_AUDIO_DRIVER_DSOUND\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_JOYSTICK_WINMM\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_CDROM_WIN32\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_THREAD_WIN32\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_TIMER_WIN32\)[	 (].*,\1define\2 1 ,
+s,^\([	 #]*\)[^	 ]*\([	 ]*SDL_LOADSO_WIN32\)[	 (].*,\1define\2 1 ,
+s/ $//
+s,^[	 #]*u.*,/* & */,
+CEOF
+    sed -f "$tmp/defines.sed" "$tmp/out1" >"$tmp/out2"
+ac_result="$tmp/out2"
+  if test x"$ac_file" != x-; then
+    echo "/* $configure_input  */" >"$tmp/config.h"
+    cat "$ac_result" >>"$tmp/config.h"
+    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
+      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f $ac_file
+      mv "$tmp/config.h" $ac_file
+    fi
+  else
+    echo "/* $configure_input  */"
+    cat "$ac_result"
+  fi
+  rm -f "$tmp/out12"
+ ;;
+
+  :C)  { echo "$as_me:$LINENO: executing $ac_file commands" >&5
+echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "default":C)
+    : >build-deps
+    if test x"$MAKE" = x; then MAKE=make; fi; $MAKE depend
+ ;;
+
+  esac
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
diff -ruN SDL-1.2.13/configure.in SDL-1.2.13_OOx64/configure.in
--- SDL-1.2.13/configure.in	2007-12-31 04:48:39 +0000
+++ SDL-1.2.13_OOx64/configure.in	2017-12-18 15:21:36 +0000
@@ -244,6 +244,14 @@
 else
     SOURCES="$SOURCES $srcdir/src/joystick/*.c"
 fi
+AC_ARG_ENABLE(haptic,
+AC_HELP_STRING([--enable-haptic], [Enable the haptic (force feedback) subsystem [[default=yes]]]),
+              , enable_haptic=yes)
+if test x$enable_haptic != xyes; then
+    AC_DEFINE(SDL_HAPTIC_DISABLED)
+else
+    SOURCES="$SOURCES $srcdir/src/haptic/*.c"
+fi
 AC_ARG_ENABLE(cdrom,
 AC_HELP_STRING([--enable-cdrom], [Enable the cdrom subsystem [[default=yes]]]),
               , enable_cdrom=yes)
@@ -1970,8 +1978,8 @@
         have_directx=no
         AC_CHECK_HEADER(ddraw.h, have_ddraw=yes)
         AC_CHECK_HEADER(dsound.h, have_dsound=yes)
-        AC_CHECK_HEADER(dinput.h, use_dinput=yes)
-        if test x$have_ddraw = xyes -a x$have_dsound = xyes -a x$use_dinput = xyes; then
+        AC_CHECK_HEADER(dinput.h, have_dinput=yes)
+        if test x$have_ddraw = xyes -a x$have_dsound = xyes -a x$have_dinput = xyes; then
             have_directx=yes
         fi
         if test x$enable_video = xyes -a x$have_directx = xyes; then
@@ -2302,6 +2310,18 @@
             ;;
           esac
         fi
+        # Set up files for the haptic library
+        if test x$enable_haptic = xyes; then
+           if test x$use_input_events = xyes; then
+             case $ARCH in
+               linux)
+                   AC_DEFINE(SDL_HAPTIC_LINUX)
+                   SOURCES="$SOURCES $srcdir/src/haptic/linux/*.c"
+                   have_haptic=yes
+               ;;
+             esac
+           fi
+        fi
         # Set up files for the cdrom library
         if test x$enable_cdrom = xyes; then
           case $ARCH in
@@ -2414,10 +2434,17 @@
         fi
         # Set up files for the joystick library
         if test x$enable_joystick = xyes; then
-            AC_DEFINE(SDL_JOYSTICK_WINMM)
+			AC_DEFINE(SDL_JOYSTICK_WINMM)
             SOURCES="$SOURCES $srcdir/src/joystick/win32/*.c"
             have_joystick=yes
         fi
+        if test x$enable_haptic = xyes; then
+            if test x$have_dinput = xyes; then
+                AC_DEFINE(SDL_HAPTIC_DINPUT)
+                SOURCES="$SOURCES $srcdir/src/haptic/win32/SDL_syshaptic.c"
+                have_haptic=yes
+            fi
+        fi
         # Set up files for the cdrom library
         if test x$enable_cdrom = xyes; then
             AC_DEFINE(SDL_CDROM_WIN32)
@@ -2477,6 +2504,13 @@
             SOURCES="$SOURCES $srcdir/src/joystick/beos/*.cc"
             have_joystick=yes
         fi
+        # Set up files for the haptic library
+        if test x$enable_haptic = xyes; then
+            AC_DEFINE(SDL_HAPTIC_IOKIT)
+            SOURCES="$SOURCES $srcdir/src/haptic/darwin/*.c"
+            have_haptic=yes
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,ForceFeedback"
+        fi
         # Set up files for the cdrom library
         if test x$enable_cdrom = xyes; then
             AC_DEFINE(SDL_CDROM_BEOS)
@@ -2685,6 +2719,12 @@
     SOURCES="$SOURCES $srcdir/src/joystick/dummy/*.c"
   fi
 fi
+if test x$have_haptic != xyes; then
+    if test x$enable_haptic = xyes; then
+        AC_DEFINE(SDL_HAPTIC_DISABLED)
+    fi
+    SOURCES="$SOURCES $srcdir/src/haptic/dummy/*.c"
+fi
 if test x$have_cdrom != xyes; then
     if test x$enable_cdrom = xyes; then
         AC_DEFINE(SDL_CDROM_DISABLED)
diff -ruN SDL-1.2.13/configure.in.beforeHaptic SDL-1.2.13_OOx64/configure.in.beforeHaptic
--- SDL-1.2.13/configure.in.beforeHaptic	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/configure.in.beforeHaptic	2007-12-30 18:48:40 +0000
@@ -0,0 +1,2798 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT(README)
+AC_CONFIG_HEADER(include/SDL_config.h)
+AC_GNU_SOURCE
+
+dnl Set various version strings - taken gratefully from the GTk sources
+#
+# Making releases:
+# Edit include/SDL/SDL_version.h and change the version, then:
+#   SDL_MICRO_VERSION += 1;
+#   SDL_INTERFACE_AGE += 1;
+#   SDL_BINARY_AGE += 1;
+# if any functions have been added, set SDL_INTERFACE_AGE to 0.
+# if backwards compatibility has been broken,
+# set SDL_BINARY_AGE and SDL_INTERFACE_AGE to 0.
+#
+SDL_MAJOR_VERSION=1
+SDL_MINOR_VERSION=2
+SDL_MICRO_VERSION=13
+SDL_INTERFACE_AGE=2
+SDL_BINARY_AGE=13
+SDL_VERSION=$SDL_MAJOR_VERSION.$SDL_MINOR_VERSION.$SDL_MICRO_VERSION
+
+AC_SUBST(SDL_MAJOR_VERSION)
+AC_SUBST(SDL_MINOR_VERSION)
+AC_SUBST(SDL_MICRO_VERSION)
+AC_SUBST(SDL_INTERFACE_AGE)
+AC_SUBST(SDL_BINARY_AGE)
+AC_SUBST(SDL_VERSION)
+
+# libtool versioning
+LT_RELEASE=$SDL_MAJOR_VERSION.$SDL_MINOR_VERSION
+LT_CURRENT=`expr $SDL_MICRO_VERSION - $SDL_INTERFACE_AGE`
+LT_REVISION=$SDL_INTERFACE_AGE
+LT_AGE=`expr $SDL_BINARY_AGE - $SDL_INTERFACE_AGE`
+
+AC_SUBST(LT_RELEASE)
+AC_SUBST(LT_CURRENT)
+AC_SUBST(LT_REVISION)
+AC_SUBST(LT_AGE)
+
+dnl Detect the canonical build and host environments
+AC_CONFIG_AUX_DIRS($srcdir/build-scripts)
+AC_CANONICAL_HOST
+AC_C_BIGENDIAN
+if test x$ac_cv_c_bigendian = xyes; then
+    AC_DEFINE(SDL_BYTEORDER, 4321)
+else
+    AC_DEFINE(SDL_BYTEORDER, 1234)
+fi
+
+dnl Set up the compiler and linker flags
+INCLUDE="-I$srcdir/include"
+if test x$srcdir != x.; then
+    # Remove SDL_config.h from the source directory, since it's the
+    # default one, and we want to include the one that we generate.
+    if test -f $srcdir/include/SDL_config.h; then
+        rm $srcdir/include/SDL_config.h
+    fi
+    INCLUDE="-Iinclude $INCLUDE"
+fi
+case "$host" in
+    *-*-cygwin*)
+        # We build SDL on cygwin without the UNIX emulation layer
+        BASE_CFLAGS="-I/usr/include/mingw -mno-cygwin"
+        BASE_LDFLAGS="-mno-cygwin"
+        ;;
+    *)
+        BASE_CFLAGS="-D_GNU_SOURCE=1"
+        BASE_LDFLAGS=""
+        ;;
+esac
+BUILD_CFLAGS="$CFLAGS $CPPFLAGS"
+EXTRA_CFLAGS="$INCLUDE $BASE_CFLAGS"
+BUILD_LDFLAGS="$LDFLAGS"
+EXTRA_LDFLAGS="$BASE_LDFLAGS"
+## These are common directories to find software packages
+#for path in /usr/freeware /usr/pkg /usr/X11R6 /usr/local; do
+#    if test -d $path/include; then
+#        EXTRA_CFLAGS="$EXTRA_CFLAGS -I$path/include"
+#    fi
+#    if test -d $path/lib; then
+#        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -L$path/lib"
+#    fi
+#done
+SDL_CFLAGS="$BASE_CFLAGS"
+SDL_LIBS="-lSDL $BASE_LDFLAGS"
+CPPFLAGS="$CPPFLAGS $EXTRA_CFLAGS"
+CFLAGS="$CFLAGS $EXTRA_CFLAGS"
+LDFLAGS="$LDFLAGS $EXTRA_LDFLAGS"
+
+dnl Check for tools
+AC_LIBTOOL_WIN32_DLL
+AC_PROG_LIBTOOL
+AC_PROG_CC
+AC_PROG_CXX
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+if test -z "$host_alias"; then
+    hostaliaswindres=
+else
+    hostaliaswindres="$host_alias-windres"
+fi
+AC_CHECK_PROGS(WINDRES, [windres $hostaliaswindres $host_os-windres])
+
+dnl Check for compiler characteristics
+AC_C_CONST
+AC_C_INLINE
+AC_C_VOLATILE
+
+dnl See whether we are allowed to use the system C library
+AC_ARG_ENABLE(libc,
+AC_HELP_STRING([--enable-libc], [Use the system C library [[default=yes]]]),
+              , enable_libc=yes)
+if test x$enable_libc = xyes; then
+    AC_DEFINE(HAVE_LIBC)
+
+    dnl Check for C library headers
+    AC_HEADER_STDC
+    AC_CHECK_HEADERS(sys/types.h stdio.h stdlib.h stddef.h stdarg.h malloc.h memory.h string.h strings.h inttypes.h stdint.h ctype.h math.h iconv.h signal.h)
+
+    dnl Check for typedefs, structures, etc.
+    AC_TYPE_SIZE_T
+    if test x$ac_cv_header_inttypes_h = xyes -o x$ac_cv_header_stdint_h = xyes; then
+        AC_CHECK_TYPE(int64_t)
+        if test x$ac_cv_type_int64_t = xyes; then
+            AC_DEFINE(SDL_HAS_64BIT_TYPE)
+        fi
+        have_inttypes=yes
+    fi
+
+    dnl Checks for library functions.
+    case "$host" in
+    *-*-cygwin* | *-*-mingw32*)
+        ;;
+    *)
+        AC_FUNC_ALLOCA
+        ;;
+    esac
+
+    AC_FUNC_MEMCMP
+    if test x$ac_cv_func_memcmp_working = xyes; then
+        AC_DEFINE(HAVE_MEMCMP)
+    fi
+    AC_FUNC_STRTOD
+    if test x$ac_cv_func_strtod = xyes; then
+        AC_DEFINE(HAVE_STRTOD)
+    fi
+    AC_CHECK_FUNC(mprotect,
+        AC_TRY_COMPILE([
+          #include <sys/types.h>
+          #include <sys/mman.h>
+        ],[
+        ],[
+        AC_DEFINE(HAVE_MPROTECT)
+        ]),
+    )
+    AC_CHECK_FUNCS(malloc calloc realloc free getenv putenv unsetenv qsort abs bcopy memset memcpy memmove strlen strlcpy strlcat strdup _strrev _strupr _strlwr strchr strrchr strstr itoa _ltoa _uitoa _ultoa strtol strtoul _i64toa _ui64toa strtoll strtoull atoi atof strcmp strncmp _stricmp strcasecmp _strnicmp strncasecmp sscanf snprintf vsnprintf iconv sigaction setjmp nanosleep)
+
+    AC_CHECK_LIB(iconv, libiconv_open, [EXTRA_LDFLAGS="$EXTRA_LDFLAGS -liconv"])
+    AC_CHECK_LIB(m, pow, [EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lm"])
+fi
+
+if test x$have_inttypes != xyes; then
+    AC_CHECK_SIZEOF(char, 1)
+    AC_CHECK_SIZEOF(short, 2)
+    AC_CHECK_SIZEOF(int, 4)
+    AC_CHECK_SIZEOF(long, 4)
+    AC_CHECK_SIZEOF(long long, 8)
+    if test x$ac_cv_sizeof_char = x1; then
+        AC_DEFINE(int8_t, signed char)
+        AC_DEFINE(uint8_t, unsigned char)
+    fi
+    if test x$ac_cv_sizeof_short = x2; then
+        AC_DEFINE(int16_t, signed short)
+        AC_DEFINE(uint16_t, unsigned short)
+    else
+        if test x$ac_cv_sizeof_int = x2; then
+            AC_DEFINE(int16_t, signed int)
+            AC_DEFINE(uint16_t, unsigned int)
+        fi
+    fi
+    if test x$ac_cv_sizeof_int = x4; then
+        AC_DEFINE(int32_t, signed int)
+        AC_DEFINE(uint32_t, unsigned int)
+    else
+        if test x$ac_cv_sizeof_long = x4; then
+            AC_DEFINE(int32_t, signed long)
+            AC_DEFINE(uint32_t, unsigned long)
+        fi
+    fi
+    if test x$ac_cv_sizeof_long = x8; then
+        AC_DEFINE(int64_t, signed long)
+        AC_DEFINE(uint64_t, unsigned long)
+        AC_DEFINE(SDL_HAS_64BIT_TYPE)
+    else
+        if test x$ac_cv_sizeof_long_long = x8; then
+            AC_DEFINE(int64_t, signed long long)
+            AC_DEFINE(uint64_t, unsigned long long)
+            AC_DEFINE(SDL_HAS_64BIT_TYPE)
+        fi
+    fi
+    AC_DEFINE(size_t, unsigned int)
+    AC_DEFINE(uintptr_t, unsigned long)
+fi
+
+# Standard C sources
+SOURCES="$SOURCES $srcdir/src/*.c"
+SOURCES="$SOURCES $srcdir/src/audio/*.c"
+SOURCES="$SOURCES $srcdir/src/cdrom/*.c"
+SOURCES="$SOURCES $srcdir/src/cpuinfo/*.c"
+SOURCES="$SOURCES $srcdir/src/events/*.c"
+SOURCES="$SOURCES $srcdir/src/file/*.c"
+SOURCES="$SOURCES $srcdir/src/stdlib/*.c"
+SOURCES="$SOURCES $srcdir/src/thread/*.c"
+SOURCES="$SOURCES $srcdir/src/timer/*.c"
+SOURCES="$SOURCES $srcdir/src/video/*.c"
+
+dnl Enable/disable various subsystems of the SDL library
+
+AC_ARG_ENABLE(audio,
+AC_HELP_STRING([--enable-audio], [Enable the audio subsystem [[default=yes]]]),
+              , enable_audio=yes)
+if test x$enable_audio != xyes; then
+    AC_DEFINE(SDL_AUDIO_DISABLED)
+fi
+AC_ARG_ENABLE(video,
+AC_HELP_STRING([--enable-video], [Enable the video subsystem [[default=yes]]]),
+              , enable_video=yes)
+if test x$enable_video != xyes; then
+    AC_DEFINE(SDL_VIDEO_DISABLED)
+fi
+AC_ARG_ENABLE(events,
+AC_HELP_STRING([--enable-events], [Enable the events subsystem [[default=yes]]]),
+              , enable_events=yes)
+if test x$enable_events != xyes; then
+    AC_DEFINE(SDL_EVENTS_DISABLED)
+fi
+AC_ARG_ENABLE(joystick,
+AC_HELP_STRING([--enable-joystick], [Enable the joystick subsystem [[default=yes]]]),
+              , enable_joystick=yes)
+if test x$enable_joystick != xyes; then
+    AC_DEFINE(SDL_JOYSTICK_DISABLED)
+else
+    SOURCES="$SOURCES $srcdir/src/joystick/*.c"
+fi
+AC_ARG_ENABLE(cdrom,
+AC_HELP_STRING([--enable-cdrom], [Enable the cdrom subsystem [[default=yes]]]),
+              , enable_cdrom=yes)
+if test x$enable_cdrom != xyes; then
+    AC_DEFINE(SDL_CDROM_DISABLED)
+fi
+AC_ARG_ENABLE(threads,
+AC_HELP_STRING([--enable-threads], [Enable the threading subsystem [[default=yes]]]),
+              , enable_threads=yes)
+if test x$enable_threads != xyes; then
+    AC_DEFINE(SDL_THREADS_DISABLED)
+fi
+AC_ARG_ENABLE(timers,
+AC_HELP_STRING([--enable-timers], [Enable the timer subsystem [[default=yes]]]),
+              , enable_timers=yes)
+if test x$enable_timers != xyes; then
+    AC_DEFINE(SDL_TIMERS_DISABLED)
+fi
+AC_ARG_ENABLE(file,
+AC_HELP_STRING([--enable-file], [Enable the file subsystem [[default=yes]]]),
+              , enable_file=yes)
+if test x$enable_file != xyes; then
+    AC_DEFINE(SDL_FILE_DISABLED)
+fi
+AC_ARG_ENABLE(loadso,
+AC_HELP_STRING([--enable-loadso], [Enable the shared object loading subsystem [[default=yes]]]),
+              , enable_loadso=yes)
+if test x$enable_loadso != xyes; then
+    AC_DEFINE(SDL_LOADSO_DISABLED)
+fi
+AC_ARG_ENABLE(cpuinfo,
+AC_HELP_STRING([--enable-cpuinfo], [Enable the cpuinfo subsystem [[default=yes]]]),
+              , enable_cpuinfo=yes)
+if test x$enable_cpuinfo != xyes; then
+    AC_DEFINE(SDL_CPUINFO_DISABLED)
+fi
+AC_ARG_ENABLE(assembly,
+AC_HELP_STRING([--enable-assembly], [Enable assembly routines [[default=yes]]]),
+              , enable_assembly=yes)
+if test x$enable_assembly = xyes; then
+    AC_DEFINE(SDL_ASSEMBLY_ROUTINES)
+fi
+
+dnl See if the OSS audio interface is supported
+CheckOSS()
+{
+    AC_ARG_ENABLE(oss,
+AC_HELP_STRING([--enable-oss], [support the OSS audio API [[default=yes]]]),
+                  , enable_oss=yes)
+    if test x$enable_audio = xyes -a x$enable_oss = xyes; then
+        AC_MSG_CHECKING(for OSS audio support)
+        have_oss=no
+        if test x$have_oss != xyes; then
+            AC_TRY_COMPILE([
+              #include <sys/soundcard.h>
+            ],[
+              int arg = SNDCTL_DSP_SETFRAGMENT;
+            ],[
+            have_oss=yes
+            ])
+        fi
+        if test x$have_oss != xyes; then
+            AC_TRY_COMPILE([
+              #include <soundcard.h>
+            ],[
+              int arg = SNDCTL_DSP_SETFRAGMENT;
+            ],[
+            have_oss=yes
+            AC_DEFINE(SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H)
+            ])
+        fi
+        AC_MSG_RESULT($have_oss)
+        if test x$have_oss = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_OSS)
+            SOURCES="$SOURCES $srcdir/src/audio/dsp/*.c"
+            SOURCES="$SOURCES $srcdir/src/audio/dma/*.c"
+            have_audio=yes
+
+            # We may need to link with ossaudio emulation library
+            case "$host" in
+                *-*-openbsd*|*-*-netbsd*)
+                    EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lossaudio";;
+            esac
+        fi
+    fi
+}
+
+dnl See if the ALSA audio interface is supported
+CheckALSA()
+{
+    AC_ARG_ENABLE(alsa,
+AC_HELP_STRING([--enable-alsa], [support the ALSA audio API [[default=yes]]]),
+                  , enable_alsa=yes)
+    if test x$enable_audio = xyes -a x$enable_alsa = xyes; then
+        AM_PATH_ALSA(0.9.0, have_alsa=yes, have_alsa=no)
+        # Restore all flags from before the ALSA detection runs
+        CFLAGS="$alsa_save_CFLAGS"
+        LDFLAGS="$alsa_save_LDFLAGS"
+        LIBS="$alsa_save_LIBS"
+        if test x$have_alsa = xyes; then
+            AC_ARG_ENABLE(alsa-shared,
+AC_HELP_STRING([--enable-alsa-shared], [dynamically load ALSA audio support [[default=yes]]]),
+                          , enable_alsa_shared=yes)
+            if test "x`echo $ALSA_LIBS | grep -- -L`" = "x"; then
+                if test "x`ls /lib/libasound.so.* 2> /dev/null`" != "x"; then
+                    ALSA_LIBS="-L/lib $ALSA_LIBS"
+                elif test "x`ls /usr/lib/libasound.so.* 2> /dev/null`" != "x"; then
+                    ALSA_LIBS="-L/usr/lib $ALSA_LIBS"
+                elif test "x`ls /usr/local/lib/libasound.so.* 2> /dev/null`" != "x"; then
+                    ALSA_LIBS="-L/usr/local/lib $ALSA_LIBS"
+                fi
+            fi
+            alsa_lib_spec=`echo $ALSA_LIBS | sed 's/.*-L\([[^ ]]*\).*/\1\/libasound.so.*/'`
+            alsa_lib=`ls -- $alsa_lib_spec | sed 's/.*\/\(.*\)/\1/; q'`
+            echo "-- $alsa_lib_spec -> $alsa_lib"
+
+            AC_DEFINE(SDL_AUDIO_DRIVER_ALSA)
+            SOURCES="$SOURCES $srcdir/src/audio/alsa/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $ALSA_CFLAGS"
+            if test x$have_loadso != xyes && \
+               test x$enable_alsa_shared = xyes; then
+                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic ALSA loading])
+            fi
+            if test x$have_loadso = xyes && \
+               test x$enable_alsa_shared = xyes && test x$alsa_lib != x; then
+                AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_ALSA_DYNAMIC, "$alsa_lib")
+            else
+                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ALSA_LIBS"
+            fi
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl Check whether we want to use IRIX 6.5+ native audio or not
+CheckDMEDIA()
+{
+    if test x$enable_audio = xyes; then
+        AC_MSG_CHECKING(for dmedia audio support)
+        have_dmedia=no
+        AC_TRY_COMPILE([
+          #include <dmedia/audio.h>
+        ],[
+          ALport audio_port;
+        ],[
+        have_dmedia=yes
+        ])
+        AC_MSG_RESULT($have_dmedia)
+        # Set up files for the audio library
+        if test x$have_dmedia = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_DMEDIA)
+            SOURCES="$SOURCES $srcdir/src/audio/dmedia/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -laudio"
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl Check whether we want to use Tru64 UNIX native audio or not
+CheckMME()
+{
+    dnl Make sure we are running on an Tru64 UNIX
+    case $ARCH in
+        osf)
+            ;;
+        *)
+            return
+            ;;
+    esac
+    if test x$enable_audio = xyes; then
+        AC_MSG_CHECKING(for MME audio support)
+        MME_CFLAGS="-I/usr/include/mme"
+        MME_LIBS="-lmme"
+        have_mme=no
+        save_CFLAGS="$CFLAGS"
+        CFLAGS="$CFLAGS $MME_CFLAGS"
+        AC_TRY_COMPILE([
+          #include <mme_api.h>
+        ],[
+          HWAVEOUT sound;
+        ],[
+        have_mme=yes
+        ])
+        CFLAGS="$save_CFLAGS"
+        AC_MSG_RESULT($have_mme)
+        # Set up files for the audio library
+        if test x$have_mme = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_MMEAUDIO)
+            SOURCES="$SOURCES $srcdir/src/audio/mme/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $MME_CFLAGS"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS $MME_LIBS"
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl Find the ESD includes and libraries
+CheckESD()
+{
+    AC_ARG_ENABLE(esd,
+AC_HELP_STRING([--enable-esd], [support the Enlightened Sound Daemon [[default=yes]]]),
+                  , enable_esd=yes)
+    if test x$enable_audio = xyes -a x$enable_esd = xyes; then
+        AM_PATH_ESD(0.2.8, have_esd=yes, have_esd=no)
+        if test x$have_esd = xyes; then
+            AC_ARG_ENABLE(esd-shared,
+AC_HELP_STRING([--enable-esd-shared], [dynamically load ESD audio support [[default=yes]]]),
+                          , enable_esd_shared=yes)
+            esd_lib_spec=`echo $ESD_LIBS | sed 's/.*-L\([[^ ]]*\).*/\1\/libesd.so.*/'`
+            esd_lib=`ls -- $esd_lib_spec | sed 's/.*\/\(.*\)/\1/; q'`
+            echo "-- $esd_lib_spec -> $esd_lib"
+
+            AC_DEFINE(SDL_AUDIO_DRIVER_ESD)
+            SOURCES="$SOURCES $srcdir/src/audio/esd/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $ESD_CFLAGS"
+            if test x$have_loadso != xyes && \
+               test x$enable_esd_shared = xyes; then
+                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic ESD loading])
+            fi
+            if test x$have_loadso = xyes && \
+               test x$enable_esd_shared = xyes && test x$esd_lib != x; then
+                AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_ESD_DYNAMIC, "$esd_lib")
+            else
+                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ESD_LIBS"
+            fi
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl Find PulseAudio
+CheckPulseAudio()
+{
+    AC_ARG_ENABLE(pulseaudio,
+AC_HELP_STRING([--enable-pulseaudio], [use PulseAudio [[default=yes]]]),
+                  , enable_pulse=yes)
+    if test x$enable_audio = xyes -a x$enable_pulse = xyes; then
+        audio_pulse=no
+
+        PULSE_REQUIRED_VERSION=0.9
+
+        AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+        AC_MSG_CHECKING(for PulseAudio $PULSE_REQUIRED_VERSION support)
+        if test x$PKG_CONFIG != xno; then
+        if $PKG_CONFIG --atleast-pkgconfig-version 0.7 && $PKG_CONFIG --atleast-version $PULSE_REQUIRED_VERSION libpulse-simple; then
+                PULSE_CFLAGS=`$PKG_CONFIG --cflags libpulse-simple`
+                PULSE_LIBS=`$PKG_CONFIG --libs libpulse-simple`
+                audio_pulse=yes
+        fi
+        fi
+        AC_MSG_RESULT($audio_pulse)
+
+        if test x$audio_pulse = xyes; then
+            AC_ARG_ENABLE(pulseaudio-shared,
+AC_HELP_STRING([--enable-pulseaudio-shared], [dynamically load PulseAudio support [[default=yes]]]),
+                          , enable_pulse_shared=yes)
+            if test "x`echo $PULSE_LIBS | grep -- -L`" = "x"; then
+                if test "x`ls /lib/libpulse-simple.so.* 2> /dev/null`" != "x"; then
+                    PULSE_LIBS="-L/lib $PULSE_LIBS"
+                elif test "x`ls /usr/lib/libpulse-simple.so.* 2> /dev/null`" != "x"; then
+                    PULSE_LIBS="-L/usr/lib $PULSE_LIBS"
+                elif test "x`ls /usr/local/lib/libpulse-simple.so.* 2> /dev/null`" != "x"; then
+                    PULSE_LIBS="-L/usr/local/lib $PULSE_LIBS"
+                fi
+            fi
+            pulse_lib_spec=`echo $PULSE_LIBS | sed 's/.*-L\([[^ ]]*\).*/\1\/libpulse-simple.so.*/'`
+            pulse_lib=`ls -- $pulse_lib_spec | sed 's/.*\/\(.*\)/\1/; q'`
+            echo "-- $pulse_lib_spec -> $pulse_lib"
+
+            AC_DEFINE(SDL_AUDIO_DRIVER_PULSE)
+            SOURCES="$SOURCES $srcdir/src/audio/pulse/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $PULSE_CFLAGS"
+            if test x$have_loadso != xyes && \
+               test x$enable_pulse_shared = xyes; then
+                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic PulseAudio loading])
+            fi
+            if test x$have_loadso = xyes && \
+               test x$enable_pulse_shared = xyes && test x$pulse_lib != x; then
+                AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_PULSE_DYNAMIC, "$pulse_lib")
+            else
+                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $PULSE_LIBS"
+            fi
+            have_audio=yes
+        fi
+    fi
+}
+
+CheckARTSC()
+{
+    AC_ARG_ENABLE(arts,
+AC_HELP_STRING([--enable-arts], [support the Analog Real Time Synthesizer [[default=yes]]]),
+                  , enable_arts=yes)
+    if test x$enable_audio = xyes -a x$enable_arts = xyes; then
+        AC_PATH_PROG(ARTSCONFIG, artsc-config)
+        if test x$ARTSCONFIG = x -o x$ARTSCONFIG = x'"$ARTSCONFIG"'; then
+            : # arts isn't installed
+        else
+            ARTS_CFLAGS=`$ARTSCONFIG --cflags`
+            ARTS_LIBS=`$ARTSCONFIG --libs`
+            ARTS_PREFIX=`$ARTSCONFIG --arts-prefix`
+            AC_MSG_CHECKING(for aRts development environment)
+            audio_arts=no
+            save_CFLAGS="$CFLAGS"
+            CFLAGS="$CFLAGS $ARTS_CFLAGS"
+            AC_TRY_COMPILE([
+             #include <artsc.h>
+            ],[
+             arts_stream_t stream;
+            ],[
+            audio_arts=yes
+            ])
+            CFLAGS="$save_CFLAGS"
+            AC_MSG_RESULT($audio_arts)
+            if test x$audio_arts = xyes; then
+                AC_ARG_ENABLE(arts-shared,
+AC_HELP_STRING([--enable-arts-shared], [dynamically load aRts audio support [[default=yes]]]),
+                              , enable_arts_shared=yes)
+                arts_lib_spec="$ARTS_PREFIX/lib/libartsc.so.*"
+                arts_lib=`ls -- $arts_lib_spec | sed 's/.*\/\(.*\)/\1/; q'`
+                echo "-- $arts_lib_spec -> $arts_lib"
+
+                AC_DEFINE(SDL_AUDIO_DRIVER_ARTS)
+                SOURCES="$SOURCES $srcdir/src/audio/arts/*.c"
+                EXTRA_CFLAGS="$EXTRA_CFLAGS $ARTS_CFLAGS"
+                if test x$have_loadso != xyes && \
+                   test x$enable_arts_shared = xyes; then
+                    AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic ARTS loading])
+                fi
+                if test x$have_loadso = xyes && \
+                   test x$enable_arts_shared = xyes && test x$arts_lib != x; then
+                    AC_DEFINE_UNQUOTED(SDL_AUDIO_DRIVER_ARTS_DYNAMIC, "$arts_lib")
+                else
+                    EXTRA_LDFLAGS="$EXTRA_LDFLAGS $ARTS_LIBS"
+                fi
+                have_audio=yes
+            fi
+        fi
+    fi
+}
+
+dnl See if the NAS audio interface is supported
+CheckNAS()
+{
+    AC_ARG_ENABLE(nas,
+AC_HELP_STRING([--enable-nas], [support the NAS audio API [[default=yes]]]),
+                  , enable_nas=yes)
+    if test x$enable_audio = xyes -a x$enable_nas = xyes; then
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -lXt -lm"
+        AC_CHECK_HEADER(audio/audiolib.h, have_audio_hdr=yes)
+        AC_CHECK_LIB(audio, AuOpenServer, have_audio_lib=yes)
+        AC_CHECK_HEADER(nas/audiolib.h, have_nas_hdr=yes)
+        AC_CHECK_LIB(nas, AuOpenServer, have_nas_lib=yes)
+        LDFLAGS="$save_LDFLAGS"
+
+        AC_MSG_CHECKING(for NAS audio support)
+        have_nas=no
+        if test x$have_audio_hdr = xyes -a x$have_audio_lib = xyes; then
+            have_nas=yes
+            NAS_LIBS="-laudio -lXt"
+        elif test x$have_nas_hdr = xyes -a x$have_nas_lib = xyes; then
+            have_nas=yes
+            NAS_LIBS="-lnas -lXt"
+	fi
+        AC_MSG_RESULT($have_nas)
+
+        if test x$have_nas = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_NAS)
+            SOURCES="$SOURCES $srcdir/src/audio/nas/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $NAS_CFLAGS"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS $NAS_LIBS"
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl rcg07142001 See if the user wants the disk writer audio driver...
+CheckDiskAudio()
+{
+    AC_ARG_ENABLE(diskaudio,
+AC_HELP_STRING([--enable-diskaudio], [support the disk writer audio driver [[default=yes]]]),
+                  , enable_diskaudio=yes)
+    if test x$enable_audio = xyes -a x$enable_diskaudio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_DISK)
+        SOURCES="$SOURCES $srcdir/src/audio/disk/*.c"
+    fi
+}
+
+dnl rcg03142006 See if the user wants the dummy audio driver...
+CheckDummyAudio()
+{
+    AC_ARG_ENABLE(dummyaudio,
+AC_HELP_STRING([--enable-dummyaudio], [support the dummy audio driver [[default=yes]]]),
+                  , enable_dummyaudio=yes)
+    if test x$enable_audio = xyes -a x$enable_dummyaudio = xyes; then
+        AC_DEFINE(SDL_AUDIO_DRIVER_DUMMY)
+        SOURCES="$SOURCES $srcdir/src/audio/dummy/*.c"
+    fi
+}
+
+dnl Set up the Atari Audio driver
+CheckAtariAudio()
+{
+    AC_ARG_ENABLE(mintaudio,
+AC_HELP_STRING([--enable-mintaudio], [support Atari audio driver [[default=yes]]]),
+                  , enable_mintaudio=yes)
+    if test x$enable_audio = xyes -a x$enable_mintaudio = xyes; then
+        mintaudio=no
+        AC_CHECK_HEADER(mint/falcon.h, have_mint_falcon_hdr=yes)
+        if test x$have_mint_falcon_hdr = xyes; then
+            mintaudio=yes
+            AC_DEFINE(SDL_AUDIO_DRIVER_MINT)
+            SOURCES="$SOURCES $srcdir/src/audio/mint/*.c"
+            SOURCES="$SOURCES $srcdir/src/audio/mint/*.S"
+            have_audio=yes
+        fi
+    fi
+}
+
+dnl See if we can use x86 assembly blitters
+# NASM is available from: http://nasm.sourceforge.net
+CheckNASM()
+{
+    dnl Make sure we are running on an x86 platform
+    case $host in
+        i?86*)
+            ;;
+        *)
+        # Nope, bail early.
+            return
+            ;;
+    esac
+    dnl Check for NASM (for assembly blit routines)
+    AC_ARG_ENABLE(nasm,
+AC_HELP_STRING([--enable-nasm], [use nasm assembly blitters on x86 [[default=yes]]]),
+                  , enable_nasm=yes)
+    if test x$enable_video = xyes -a x$enable_assembly = xyes -a x$enable_nasm = xyes; then
+        CompileNASM()
+        {
+            # Usage: CompileNASM <filename>
+            AC_MSG_CHECKING(to see if $NASM supports $1)
+            if $NASM $NASMFLAGS $1 -o $1.o >&AS_MESSAGE_LOG_FD 2>&1; then
+                CompileNASM_ret="yes"
+            else
+                CompileNASM_ret="no"
+            fi
+            rm -f $1 $1.o
+            AC_MSG_RESULT($CompileNASM_ret)
+            test "$CompileNASM_ret" = "yes"
+        }
+
+        if test x"$NASMFLAGS" = x; then
+            case $ARCH in
+              win32)
+                  NASMFLAGS="-f win32"
+                  ;;
+              openbsd)
+                  NASMFLAGS="-f aoutb"
+                  ;;
+              macosx)
+                  NASMFLAGS="-f macho"
+                  ;;
+              *)
+                  NASMFLAGS="-f elf"
+                  ;;
+            esac
+        fi
+
+        AC_PATH_PROG(NASM, yasm)
+        echo "%ifidn __OUTPUT_FORMAT__,elf" > unquoted-sections
+        echo "section .note.GNU-stack noalloc noexec nowrite progbits" >> unquoted-sections
+        echo "%endif" >> unquoted-sections
+        CompileNASM unquoted-sections || NASM=""
+
+        if test "x$NASM" = x -o "x$NASM" = x'"$NASM"'; then
+            $as_unset ac_cv_path_NASM
+            AC_PATH_PROG(NASM, nasm)
+        fi
+        if test "x$NASM" != x -a "x$NASM" != x'"$NASM"'; then
+            AC_DEFINE(SDL_HERMES_BLITTERS)
+            SOURCES="$SOURCES $srcdir/src/hermes/*.asm"
+            NASMFLAGS="$NASMFLAGS -I $srcdir/src/hermes/"
+
+            dnl See if hidden visibility is supported
+            echo "GLOBAL _bar:function hidden" > symbol-visibility
+            echo "_bar:" >> symbol-visibility
+            CompileNASM symbol-visibility && NASMFLAGS="$NASMFLAGS -DHIDDEN_VISIBILITY"
+
+            AC_SUBST(NASM)
+            AC_SUBST(NASMFLAGS)
+
+            case "$host" in
+                # this line is needed for QNX, because it's not defined the __ELF__
+                *-*-qnx*)
+                     EXTRA_CFLAGS="$EXTRA_CFLAGS -D__ELF__";;
+                *-*-solaris*)
+                     EXTRA_CFLAGS="$EXTRA_CFLAGS -D__ELF__";;
+            esac
+        fi
+    fi
+}
+
+dnl Check for altivec instruction support using gas syntax
+CheckAltivec()
+{
+    AC_ARG_ENABLE(altivec,
+AC_HELP_STRING([--enable-altivec], [use altivec assembly blitters on PPC [[default=yes]]]),
+                  , enable_altivec=yes)
+    if test x$enable_video = xyes -a x$enable_assembly = xyes -a x$enable_altivec = xyes; then
+        have_altivec_h_hdr=no
+        AC_CHECK_HEADER(altivec.h, have_altivec_h_hdr=yes)
+
+        save_CFLAGS="$CFLAGS"
+        have_gcc_altivec=no
+        AC_MSG_CHECKING(for Altivec with GCC -maltivec option)
+        altivec_CFLAGS="-maltivec"
+        CFLAGS="$save_CFLAGS $altivec_CFLAGS"
+
+        if test x$have_altivec_h_hdr = xyes; then
+          AC_TRY_COMPILE([
+          #include <altivec.h>
+          vector unsigned int vzero() {
+              return vec_splat_u32(0);
+          }
+          ],[
+          ],[
+          have_gcc_altivec=yes
+          ])
+          AC_MSG_RESULT($have_gcc_altivec)
+        else
+          AC_TRY_COMPILE([
+          vector unsigned int vzero() {
+              return vec_splat_u32(0);
+          }
+          ],[
+          ],[
+          have_gcc_altivec=yes
+          ])
+          AC_MSG_RESULT($have_gcc_altivec)
+        fi
+
+        if test x$have_gcc_altivec = xno; then
+            AC_MSG_CHECKING(for Altivec with GCC -faltivec option)
+            altivec_CFLAGS="-faltivec"
+            CFLAGS="$save_CFLAGS $altivec_CFLAGS"
+            if test x$have_altivec_h_hdr = xyes; then
+              AC_TRY_COMPILE([
+              #include <altivec.h>
+              vector unsigned int vzero() {
+                  return vec_splat_u32(0);
+              }
+              ],[
+              ],[
+              have_gcc_altivec=yes
+              ])
+              AC_MSG_RESULT($have_gcc_altivec)
+            else
+              AC_TRY_COMPILE([
+              vector unsigned int vzero() {
+                  return vec_splat_u32(0);
+              }
+              ],[
+              ],[
+              have_gcc_altivec=yes
+              ])
+              AC_MSG_RESULT($have_gcc_altivec)
+            fi
+        fi
+        CFLAGS="$save_CFLAGS"
+
+        if test x$have_gcc_altivec = xyes; then
+            AC_DEFINE(SDL_ALTIVEC_BLITTERS)
+            if test x$have_altivec_h_hdr = xyes; then
+              AC_DEFINE(HAVE_ALTIVEC_H)
+            fi
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $altivec_CFLAGS"
+        fi
+    fi
+}
+
+dnl See if GCC's -fvisibility=hidden is supported (gcc4 and later, usually).
+dnl  Details of this flag are here: http://gcc.gnu.org/wiki/Visibility
+CheckVisibilityHidden()
+{
+    AC_MSG_CHECKING(for GCC -fvisibility=hidden option)
+    have_gcc_fvisibility=no
+
+    visibility_CFLAGS="-fvisibility=hidden"
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$save_CFLAGS $visibility_CFLAGS -Werror"
+    AC_TRY_COMPILE([
+    #if !defined(__GNUC__) || __GNUC__ < 4
+    #error SDL only uses visibility attributes in GCC 4 or newer
+    #endif
+    ],[
+    ],[
+    have_gcc_fvisibility=yes
+    ])
+    AC_MSG_RESULT($have_gcc_fvisibility)
+    CFLAGS="$save_CFLAGS"
+
+    if test x$have_gcc_fvisibility = xyes; then
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $visibility_CFLAGS"
+    fi
+}
+
+
+dnl Do the iPod thing
+CheckIPod()
+{
+    AC_ARG_ENABLE(ipod,
+AC_HELP_STRING([--enable-ipod], [configure SDL to work with iPodLinux [default=yes on arm-elf]]),
+        , enable_ipod=yes)
+
+    if test x$enable_ipod = xyes; then
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DIPOD"
+        AC_DEFINE(SDL_VIDEO_DRIVER_IPOD)
+        SOURCES="$SOURCES $srcdir/src/video/ipod/*.c"
+    fi
+}
+
+dnl Find the nanox include and library directories
+CheckNANOX()
+{
+    AC_ARG_ENABLE(video-nanox,
+        AC_HELP_STRING([--enable-video-nanox], [use nanox video driver [[default=no]]]),
+        , enable_video_nanox=no)
+
+    if test x$enable_video = xyes -a x$enable_video_nanox = xyes; then
+        AC_ARG_ENABLE(nanox-debug,  
+            AC_HELP_STRING([--enable-nanox-debug], [print debug messages [[default=no]]]),
+            , enable_nanox_debug=no)
+        if test x$enable_nanox_debug = xyes; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -DENABLE_NANOX_DEBUG"
+        fi
+
+        AC_ARG_ENABLE(nanox-share-memory,  
+            AC_HELP_STRING([--enable-nanox-share-memory], [use share memory [[default=no]]]),
+            , enable_nanox_share_memory=no)
+        if test x$enable_nanox_share_memory = xyes; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -DNANOX_SHARE_MEMORY"
+        fi
+
+        AC_ARG_ENABLE(nanox_direct_fb, 
+            AC_HELP_STRING([--enable-nanox-direct-fb], [use direct framebuffer access [[default=no]]]),
+            , enable_nanox_direct_fb=no)
+        if test x$enable_nanox_direct_fb = xyes; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -DENABLE_NANOX_DIRECT_FB"
+        fi
+
+        AC_DEFINE(SDL_VIDEO_DRIVER_NANOX)
+        SOURCES="$SOURCES $srcdir/src/video/nanox/*.c"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lnano-X"
+        have_video=yes
+    fi
+}
+
+dnl Find the X11 include and library directories
+CheckX11()
+{
+    AC_ARG_ENABLE(video-x11,
+AC_HELP_STRING([--enable-video-x11], [use X11 video driver [[default=yes]]]),
+                  , enable_video_x11=yes)
+    if test x$enable_video = xyes -a x$enable_video_x11 = xyes; then
+        case "$host" in
+            *-*-darwin*)
+                # This isn't necessary for X11, but fixes GLX detection
+                if test "x$x_includes" = xNONE && test "x$x_libraries" = xNONE; then
+                    x_includes="/usr/X11R6/include"
+                    x_libraries="/usr/X11R6/lib"
+                fi
+                ;;
+        esac
+        AC_PATH_X
+        AC_PATH_XTRA
+        if test x$have_x = xyes; then
+            # Only allow dynamically loaded X11 if the X11 function pointers
+            # will not end up in the global namespace, which causes problems
+            # with other libraries calling X11 functions.
+            x11_symbols_private=$have_gcc_fvisibility
+
+            AC_ARG_ENABLE(x11-shared,
+AC_HELP_STRING([--enable-x11-shared], [dynamically load X11 support [[default=maybe]]]),
+                          , enable_x11_shared=maybe)
+
+            case "$host" in
+                *-*-darwin*) # Latest Mac OS X actually ships with Xrandr/Xrender libs...
+                    x11_symbols_private=yes
+                    x11_lib='/usr/X11R6/lib/libX11.6.dylib'
+                    x11ext_lib='/usr/X11R6/lib/libXext.6.dylib'
+                    xrender_lib='/usr/X11R6/lib/libXrender.1.dylib'
+                    xrandr_lib='/usr/X11R6/lib/libXrandr.2.dylib'
+                    ;;
+                *-*-osf*)
+                    x11_lib='libX11.so'
+                    x11ext_lib='libXext.so'
+                    ;;
+                *-*-irix*) # IRIX 6.5 requires that we use /usr/lib32
+                    x11_lib='libX11.so'
+                    x11ext_lib='libXext.so'
+                    ;;
+                *)
+                    x11_lib_path=[`echo $X_LIBS | sed 's/.*-L\([^ ]*\).*/\1/'`]
+                    for path in $x11_lib_path /usr/lib /usr/X11/lib /usr/X11R6/lib; do
+                        if test "x$x11_lib" = "x"; then
+                            x11_lib=[`ls -- $path/libX11.so.[0-9] 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            if test "x$x11_lib" = "x"; then
+                                x11_lib=[`ls -- $path/libX11.so.[0-9]* 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            fi
+                        fi
+                        if test "x$x11ext_lib" = "x"; then
+                            x11ext_lib=[`ls -- $path/libXext.so.[0-9] 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            if test "x$x11ext_lib" = "x"; then
+                                x11ext_lib=[`ls -- $path/libXext.so.[0-9]* 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            fi
+                        fi
+                        if test "x$xrender_lib" = "x"; then
+                            xrender_lib=[`ls -- $path/libXrender.so.[0-9] 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            if test "x$xrender_lib" = "x"; then
+                                xrender_lib=[`ls -- $path/libXrender.so.[0-9]* 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            fi
+                        fi
+                        if test "x$xrandr_lib" = "x"; then
+                            xrandr_lib=[`ls -- $path/libXrandr.so.[0-9] 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            if test "x$xrandr_lib" = "x"; then
+                                xrandr_lib=[`ls -- $path/libXrandr.so.[0-9]* 2>/dev/null | sort -r | sed 's/.*\/\(.*\)/\1/; q'`]
+                            fi
+                        fi
+                    done
+                    ;;
+            esac
+
+            X_CFLAGS="$X_CFLAGS -DXTHREADS"
+            if test x$ac_cv_func_shmat != xyes; then
+                X_CFLAGS="$X_CFLAGS -DNO_SHARED_MEMORY"
+            fi
+            CFLAGS="$CFLAGS $X_CFLAGS"
+            LDFLAGS="$LDFLAGS $X_LIBS"
+
+            AC_DEFINE(SDL_VIDEO_DRIVER_X11)
+            SOURCES="$SOURCES $srcdir/src/video/x11/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $X_CFLAGS"
+
+            if test x$enable_x11_shared = xmaybe; then
+                enable_x11_shared=$x11_symbols_private
+            fi
+            if test x$have_loadso != xyes && \
+               test x$enable_x11_shared = xyes; then
+                AC_MSG_WARN([You must have SDL_LoadObject() support for dynamic X11 loading])
+                enable_x11_shared=no
+            fi
+            if test x$x11_symbols_private != xyes && \
+               test x$enable_x11_shared = xyes; then
+                AC_MSG_WARN([You must have gcc4 (-fvisibility=hidden) for dynamic X11 loading])
+                enable_x11_shared=no
+            fi
+
+            if test x$have_loadso = xyes && \
+               test x$enable_x11_shared = xyes && test x$x11_lib != x && test x$x11ext_lib != x; then
+                echo "-- dynamic libX11 -> $x11_lib"
+                echo "-- dynamic libX11ext -> $x11ext_lib"
+                AC_DEFINE_UNQUOTED(SDL_VIDEO_DRIVER_X11_DYNAMIC, "$x11_lib")
+                AC_DEFINE_UNQUOTED(SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT, "$x11ext_lib")
+            else
+                enable_x11_shared=no
+                EXTRA_LDFLAGS="$EXTRA_LDFLAGS $X_LIBS -lX11 -lXext"
+            fi
+            have_video=yes
+
+            AC_ARG_ENABLE(dga,
+AC_HELP_STRING([--enable-dga], [allow use of X11 DGA code [[default=yes]]]),
+                          , enable_dga=yes)
+            if test x$enable_dga = xyes; then
+                SOURCES="$SOURCES $srcdir/src/video/Xext/Xxf86dga/*.c"
+            fi
+            AC_ARG_ENABLE(video-dga,
+AC_HELP_STRING([--enable-video-dga], [use DGA 2.0 video driver [[default=yes]]]),
+                  , enable_video_dga=yes)
+            if test x$enable_dga = xyes -a x$enable_video_dga = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_DGA)
+                SOURCES="$SOURCES $srcdir/src/video/dga/*.c"
+            fi
+            AC_ARG_ENABLE(video-x11-dgamouse,
+AC_HELP_STRING([--enable-video-x11-dgamouse], [use X11 DGA for mouse events [[default=yes]]]),
+                          , enable_video_x11_dgamouse=yes)
+            if test x$enable_dga = xyes -a x$enable_video_x11_dgamouse = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_DGAMOUSE)
+            fi
+            AC_ARG_ENABLE(video-x11-vm,
+AC_HELP_STRING([--enable-video-x11-vm], [use X11 VM extension for fullscreen [[default=yes]]]),
+                          , enable_video_x11_vm=yes)
+            if test x$enable_video_x11_vm = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_VIDMODE)
+                SOURCES="$SOURCES $srcdir/src/video/Xext/Xxf86vm/*.c"
+            fi
+            AC_ARG_ENABLE(video-x11-xv,
+AC_HELP_STRING([--enable-video-x11-xv], [use X11 XvImage extension for video [[default=yes]]]),
+                          , enable_video_x11_xv=yes)
+            if test x$enable_video_x11_xv = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_XV)
+                SOURCES="$SOURCES $srcdir/src/video/Xext/Xv/*.c"
+            fi
+            AC_ARG_ENABLE(video-x11-xinerama,
+AC_HELP_STRING([--enable-video-x11-xinerama], [enable X11 Xinerama support [[default=yes]]]),
+                            , enable_video_x11_xinerama=yes)
+            if test x$enable_video_x11_xinerama = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_XINERAMA)
+                SOURCES="$SOURCES $srcdir/src/video/Xext/Xinerama/*.c"
+            fi
+            AC_ARG_ENABLE(video-x11-xme,
+AC_HELP_STRING([--enable-video-x11-xme], [enable Xi Graphics XME for fullscreen [[default=yes]]]),
+                            , enable_video_x11_xme=yes)
+            if test x$enable_video_x11_xme = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_XME)
+                SOURCES="$SOURCES $srcdir/src/video/Xext/XME/*.c"
+            fi
+            AC_ARG_ENABLE(video-x11-xrandr,
+AC_HELP_STRING([--enable-video-x11-xrandr], [enable X11 Xrandr extension for fullscreen [[default=yes]]]),
+                            , enable_video_x11_xrandr=yes)
+            if test x$enable_video_x11_xrandr = xyes; then
+                definitely_enable_video_x11_xrandr=no
+                AC_CHECK_HEADER(X11/extensions/Xrandr.h,
+                                have_xrandr_h_hdr=yes,
+                                have_xrandr_h_hdr=no,
+                                [#include <X11/Xlib.h>
+                                ])
+                if test x$have_xrandr_h_hdr = xyes; then
+                    if test x$enable_x11_shared = xyes && test x$xrandr_lib != x ; then
+                        echo "-- dynamic libXrender -> $xrender_lib"
+                        echo "-- dynamic libXrandr -> $xrandr_lib"
+                        AC_DEFINE_UNQUOTED(SDL_VIDEO_DRIVER_X11_DYNAMIC_XRENDER, "$xrender_lib")
+                        AC_DEFINE_UNQUOTED(SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR, "$xrandr_lib")
+                        definitely_enable_video_x11_xrandr=yes
+                    else
+                        AC_CHECK_LIB(Xrender, XRenderQueryExtension, have_xrender_lib=yes)
+                        AC_CHECK_LIB(Xrandr, XRRQueryExtension, have_xrandr_lib=yes)
+                        if test x$have_xrender_lib = xyes && test x$have_xrandr_lib = xyes ; then
+                            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lXrandr -lXrender"
+                            definitely_enable_video_x11_xrandr=yes
+                        fi
+                    fi
+                fi
+            fi
+            if test x$definitely_enable_video_x11_xrandr = xyes; then
+                AC_DEFINE(SDL_VIDEO_DRIVER_X11_XRANDR)
+            fi
+            AC_ARG_ENABLE(video-x11-dpms,
+AC_HELP_STRING([--enable-video-x11-dpms], [enable X11 DPMS extension [[default=yes]]]),
+                            , enable_video_x11_dpms=yes)
+            if test x$enable_video_x11_dpms = xyes; then
+                AC_CHECK_HEADER(X11/extensions/dpms.h,
+                                have_dpms_h_hdr=yes,
+                                have_dpms_h_hdr=no,
+                                [#include <X11/Xlib.h>
+                                ])
+                if test x$have_dpms_h_hdr = xyes; then
+                    AC_DEFINE(SDL_VIDEO_DRIVER_X11_DPMS)
+                fi
+            fi
+        fi
+    fi
+}
+
+dnl Check for QNX photon video driver
+CheckPHOTON()
+{
+    AC_ARG_ENABLE(video-photon,
+AC_HELP_STRING([--enable-video-photon], [use QNX Photon video driver [[default=yes]]]),
+                  , enable_video_photon=yes)
+    if test x$enable_video = xyes -a x$enable_video_photon = xyes; then
+        AC_MSG_CHECKING(for QNX Photon support)
+        video_photon=no
+        AC_TRY_COMPILE([
+          #include <Ph.h>
+          #include <Pt.h>
+          #include <photon/Pg.h>
+          #include <photon/PdDirect.h>
+        ],[
+         PgDisplaySettings_t *visual;
+        ],[
+        video_photon=yes
+        ])
+        AC_MSG_RESULT($video_photon)
+        if test x$video_photon = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_PHOTON)
+            SOURCES="$SOURCES $srcdir/src/video/photon/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lph"
+            have_video=yes
+
+            CheckOpenGLQNX
+        fi
+    fi
+}
+
+dnl Set up the BWindow video driver if enabled
+CheckBWINDOW()
+{
+    if test x$enable_video = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_BWINDOW)
+        SOURCES="$SOURCES $srcdir/src/video/bwindow/*.cc"
+        have_video=yes
+    fi
+}
+
+dnl Set up the Carbon/QuickDraw video driver for Mac OS X (but not Darwin)
+CheckCARBON()
+{
+    AC_ARG_ENABLE(video-carbon,
+AC_HELP_STRING([--enable-video-carbon], [use Carbon/QuickDraw video driver [[default=no]]]),
+                  , enable_video_carbon=no)
+    if test x$enable_video = xyes -a x$enable_video_carbon = xyes; then
+        AC_MSG_CHECKING(for Carbon framework)
+        have_carbon=no
+        AC_TRY_COMPILE([
+          #include <Carbon/Carbon.h>
+        ],[
+        ],[
+        have_carbon=yes
+        ])
+        AC_MSG_RESULT($have_carbon)
+        if test x$have_carbon = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_TOOLBOX)
+            SOURCES="$SOURCES $srcdir/src/video/maccommon/*.c"
+            SOURCES="$SOURCES $srcdir/src/video/macrom/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Set up the Cocoa/Quartz video driver for Mac OS X (but not Darwin)
+CheckCOCOA()
+{
+    AC_ARG_ENABLE(video-cocoa,
+AC_HELP_STRING([--enable-video-cocoa], [use Cocoa/Quartz video driver [[default=yes]]]),
+                  , enable_video_cocoa=yes)
+    if test x$enable_video = xyes -a x$enable_video_cocoa = xyes; then
+        save_CFLAGS="$CFLAGS"
+        dnl work around that we don't have Objective-C support in autoconf
+        CFLAGS="$CFLAGS -x objective-c"
+        AC_MSG_CHECKING(for Cocoa framework)
+        have_cocoa=no
+        AC_TRY_COMPILE([
+          #import <Cocoa/Cocoa.h>
+        ],[
+        ],[
+        have_cocoa=yes
+        ])
+        AC_MSG_RESULT($have_cocoa)
+        CFLAGS="$save_CFLAGS"
+        if test x$have_cocoa = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_QUARTZ)
+            SOURCES="$SOURCES $srcdir/src/video/quartz/*.m"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Find the framebuffer console includes
+CheckFBCON()
+{
+    AC_ARG_ENABLE(video-fbcon,
+AC_HELP_STRING([--enable-video-fbcon], [use framebuffer console video driver [[default=yes]]]),
+                  , enable_video_fbcon=yes)
+    if test x$enable_video = xyes -a x$enable_video_fbcon = xyes; then
+        AC_MSG_CHECKING(for framebuffer console support)
+        video_fbcon=no
+        AC_TRY_COMPILE([
+         #include <linux/fb.h>
+         #include <linux/kd.h>
+         #include <linux/keyboard.h>
+        ],[
+        ],[
+        video_fbcon=yes
+        ])
+        AC_MSG_RESULT($video_fbcon)
+        if test x$video_fbcon = xyes; then
+            AC_CHECK_FUNCS(getpagesize)
+            AC_DEFINE(SDL_VIDEO_DRIVER_FBCON)
+            SOURCES="$SOURCES $srcdir/src/video/fbcon/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Find DirectFB
+CheckDirectFB()
+{
+    AC_ARG_ENABLE(video-directfb,
+AC_HELP_STRING([--enable-video-directfb], [use DirectFB video driver [[default=yes]]]),
+                  , enable_video_directfb=yes)
+    if test x$enable_video = xyes -a x$enable_video_directfb = xyes; then
+        video_directfb=no
+
+        DIRECTFB_REQUIRED_VERSION=0.9.15
+
+        AC_PATH_PROG(DIRECTFBCONFIG, directfb-config, no)
+        if test x$DIRECTFBCONFIG = xno; then
+            AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+            AC_MSG_CHECKING(for DirectFB $DIRECTFB_REQUIRED_VERSION support)
+            if test x$PKG_CONFIG != xno; then
+                if $PKG_CONFIG --atleast-pkgconfig-version 0.7 && $PKG_CONFIG --atleast-version $DIRECTFB_REQUIRED_VERSION directfb; then
+                    DIRECTFB_CFLAGS=`$PKG_CONFIG --cflags directfb`
+                    DIRECTFB_LIBS=`$PKG_CONFIG --libs directfb`
+                    video_directfb=yes
+                fi
+            fi
+            AC_MSG_RESULT($video_directfb)
+        else
+            AC_MSG_CHECKING(for DirectFB $DIRECTFB_REQUIRED_VERSION support)
+            set -- `echo $DIRECTFB_REQUIRED_VERSION | sed 's/\./ /g'`
+            NEED_VERSION=`expr $1 \* 10000 + $2 \* 100 + $3`
+            set -- `directfb-config --version | sed 's/\./ /g'`
+            HAVE_VERSION=`expr $1 \* 10000 + $2 \* 100 + $3`
+            if test $HAVE_VERSION -ge $NEED_VERSION; then
+                DIRECTFB_CFLAGS=`$DIRECTFBCONFIG --cflags`
+                DIRECTFB_LIBS=`$DIRECTFBCONFIG --libs`
+                video_directfb=yes
+            fi
+            AC_MSG_RESULT($video_directfb)
+        fi
+
+        if test x$video_directfb = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_DIRECTFB)
+            SOURCES="$SOURCES $srcdir/src/video/directfb/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $DIRECTFB_CFLAGS"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS $DIRECTFB_LIBS"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl See if we're running on PlayStation 2 hardware
+CheckPS2GS()
+{
+    AC_ARG_ENABLE(video-ps2gs,
+AC_HELP_STRING([--enable-video-ps2gs], [use PlayStation 2 GS video driver [[default=yes]]]),
+                  , enable_video_ps2gs=yes)
+    if test x$enable_video = xyes -a x$enable_video_ps2gs = xyes; then
+        AC_MSG_CHECKING(for PlayStation 2 GS support)
+        video_ps2gs=no
+        AC_TRY_COMPILE([
+         #include <linux/ps2/dev.h>
+         #include <linux/ps2/gs.h>
+        ],[
+        ],[
+        video_ps2gs=yes
+        ])
+        AC_MSG_RESULT($video_ps2gs)
+        if test x$video_ps2gs = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_PS2GS)
+            SOURCES="$SOURCES $srcdir/src/video/ps2gs/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Find the GGI includes
+CheckGGI()
+{
+    AC_ARG_ENABLE(video-ggi,
+AC_HELP_STRING([--enable-video-ggi], [use GGI video driver [[default=no]]]),
+                  , enable_video_ggi=no)
+    if test x$enable_video = xyes -a x$enable_video_ggi = xyes; then
+        AC_MSG_CHECKING(for GGI support)
+        video_ggi=no
+        AC_TRY_COMPILE([
+         #include <ggi/ggi.h>
+         #include <ggi/gii.h>
+        ],[
+        ],[
+        video_ggi=yes
+        ])
+        AC_MSG_RESULT($video_ggi)
+        if test x$video_ggi = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_GGI)
+            SOURCES="$SOURCES $srcdir/src/video/ggi/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lggi -lgii -lgg"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Find the SVGAlib includes and libraries
+CheckSVGA()
+{
+    AC_ARG_ENABLE(video-svga,
+AC_HELP_STRING([--enable-video-svga], [use SVGAlib video driver [[default=yes]]]),
+                  , enable_video_svga=yes)
+    if test x$enable_video = xyes -a x$enable_video_svga = xyes; then
+        AC_MSG_CHECKING(for SVGAlib (1.4.0+) support)
+        video_svga=no
+        AC_TRY_COMPILE([
+         #include <vga.h>
+         #include <vgamouse.h>
+         #include <vgakeyboard.h>
+        ],[
+         if ( SCANCODE_RIGHTWIN && SCANCODE_LEFTWIN ) {
+             exit(0);
+         }
+        ],[
+        video_svga=yes
+        ])
+        AC_MSG_RESULT($video_svga)
+        if test x$video_svga = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_SVGALIB)
+            SOURCES="$SOURCES $srcdir/src/video/svga/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lvga"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Find the VGL includes and libraries
+CheckVGL()
+{
+    AC_ARG_ENABLE(video-vgl,
+AC_HELP_STRING([--enable-video-vgl], [use VGL video driver [[default=yes]]]),
+                  , enable_video_vgl=yes)
+    if test x$enable_video = xyes -a x$enable_video_vgl = xyes; then
+        AC_MSG_CHECKING(for libVGL support)
+        video_vgl=no
+        AC_TRY_COMPILE([
+         #include <sys/fbio.h>
+         #include <sys/consio.h>
+         #include <sys/kbio.h>
+         #include <vgl.h>
+        ],[
+         VGLBitmap bitmap;
+         bitmap.Type = VIDBUF32;
+         bitmap.PixelBytes = 4;
+         exit(bitmap.Bitmap);
+        ],[
+        video_vgl=yes
+        ])
+        AC_MSG_RESULT($video_vgl)
+        if test x$video_vgl = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_VGL)
+            SOURCES="$SOURCES $srcdir/src/video/vgl/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lvgl"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Set up the wscons video driver if enabled
+CheckWscons()
+{
+    AC_ARG_ENABLE(video-wscons,
+AC_HELP_STRING([--enable-video-wscons], [use wscons video driver [[default=yes]]]),
+                  , enable_video_wscons=yes)
+    if test x$enable_video = xyes -a x$enable_video_wscons = xyes; then
+        AC_MSG_CHECKING(for wscons support)
+        video_wscons=no
+        AC_TRY_COMPILE([
+         #include <sys/time.h>
+         #include <dev/wscons/wsconsio.h>
+         #include <dev/wscons/wsdisplay_usl_io.h>
+        ],[
+         int wsmode = WSDISPLAYIO_MODE_DUMBFB;
+        ],[
+        video_wscons=yes
+        ])
+        AC_MSG_RESULT($video_wscons)
+        if test x$video_wscons = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_WSCONS)
+            SOURCES="$SOURCES $srcdir/src/video/wscons/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
+
+dnl Find the AAlib includes
+CheckAAlib()
+{
+    AC_ARG_ENABLE(video-aalib,
+AC_HELP_STRING([--enable-video-aalib], [use AAlib video driver [[default=no]]]),
+                  , enable_video_aalib=no)
+    if test x$enable_video = xyes -a x$enable_video_aalib = xyes; then
+        AC_MSG_CHECKING(for AAlib support)
+        video_aalib=no
+        AC_TRY_COMPILE([
+         #include <aalib.h>
+        ],[
+        ],[
+        video_aalib=yes
+        ])
+        AC_MSG_RESULT($video_aalib)
+        if test x$video_aalib = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_AALIB)
+            SOURCES="$SOURCES $srcdir/src/video/aalib/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -laa"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Set up the QTopia video driver if enabled
+CheckQtopia()
+{
+    AC_ARG_ENABLE(video-qtopia,
+AC_HELP_STRING([--enable-video-qtopia], [use Qtopia video driver [[default=no]]]),
+                  , enable_video_qtopia=no)
+    if test x$enable_video = xyes -a x$enable_video_qtopia = xyes; then
+        AC_MSG_CHECKING(for Qtopia support)
+        video_qtopia=no
+        QTOPIA_FLAGS="-DQT_QWS_EBX -DQT_QWS_CUSTOM -DQWS -I${QPEDIR}/include -I${QTDIR}/include/ -DNO_DEBUG -fno-rtti -fno-exceptions"
+        AC_LANG_CPLUSPLUS
+        OLD_CXX="$CXXFLAGS"
+        CXXFLAGS="$QTOPIA_FLAGS"
+        AC_TRY_COMPILE([
+         #include <qpe/qpeapplication.h>
+        ],[
+        ],[
+        video_qtopia=yes
+        ])
+        CXXFLAGS="$OLD_CXX"
+        AC_MSG_RESULT($video_qtopia)
+        if test x$video_qtopia = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_QTOPIA)
+            SOURCES="$SOURCES $srcdir/src/video/qtopia/*.cc"
+            SDLMAIN_SOURCES="$srcdir/src/main/qtopia/*.cc"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $QTOPIA_FLAGS"
+            SDL_CFLAGS="$SDL_CFLAGS -DQWS -Dmain=SDL_main"
+            SDL_LIBS="-lSDLmain $SDL_LIBS -L${QPEDIR}/lib -L${QTDIR}/lib/ -lqpe -lqte"
+            have_video=yes
+        fi
+        AC_LANG_C
+    fi
+}
+
+dnl Set up the PicoGUI video driver if enabled
+CheckPicoGUI()
+{
+    AC_ARG_ENABLE(video-picogui,
+AC_HELP_STRING([--enable-video-picogui], [use PicoGUI video driver [[default=no]]]),
+                  , enable_video_picogui=no)
+    if test x$enable_video = xyes -a x$enable_video_picogui = xyes; then
+        AC_MSG_CHECKING(for PicoGUI support)
+        video_picogui=no
+        AC_TRY_COMPILE([
+         #include <picogui.h>
+        ],[
+        ],[
+        video_picogui=yes
+        ])
+        AC_MSG_RESULT($video_picogui)
+        if test x$video_picogui = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_PICOGUI)
+            SOURCES="$SOURCES $srcdir/src/video/picogui/*.c"
+            SDL_LIBS="$SDL_LIBS -lpgui"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Set up the Atari Bios keyboard driver
+CheckAtariBiosEvent()
+{
+    SOURCES="$SOURCES $srcdir/src/video/ataricommon/*.c"
+    SOURCES="$SOURCES $srcdir/src/video/ataricommon/*.S"
+}
+
+dnl Set up the Atari Xbios driver
+CheckAtariXbiosVideo()
+{
+    AC_ARG_ENABLE(xbios,
+AC_HELP_STRING([--enable-video-xbios], [use Atari Xbios video driver [[default=yes]]]),
+                  , enable_video_xbios=yes)
+    video_xbios=no
+    if test x$enable_video = xyes -a x$enable_video_xbios = xyes; then
+        video_xbios=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_XBIOS)
+        SOURCES="$SOURCES $srcdir/src/video/xbios/*.c"
+        have_video=yes
+    fi
+}
+
+dnl Set up the Atari Gem driver
+CheckAtariGemVideo()
+{
+    AC_ARG_ENABLE(gem,
+AC_HELP_STRING([--enable-video-gem], [use Atari Gem video driver [[default=yes]]]),
+                  , enable_video_gem=yes)
+    if test x$enable_video = xyes -a x$enable_video_gem = xyes; then
+        video_gem=no
+        AC_CHECK_HEADER(gem.h, have_gem_hdr=yes)
+        AC_CHECK_LIB(gem, appl_init, have_gem_lib=yes)
+        if test x$have_gem_hdr = xyes -a x$have_gem_lib = xyes; then
+            video_gem=yes
+            AC_DEFINE(SDL_VIDEO_DRIVER_GEM)
+            SOURCES="$SOURCES $srcdir/src/video/gem/*.c"
+            SDL_LIBS="$SDL_LIBS -lgem"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl rcg04172001 Set up the Null video driver.
+CheckDummyVideo()
+{
+    AC_ARG_ENABLE(video-dummy,
+AC_HELP_STRING([--enable-video-dummy], [use dummy video driver [[default=yes]]]),
+                  , enable_video_dummy=yes)
+    if test x$enable_video_dummy = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_DUMMY)
+        SOURCES="$SOURCES $srcdir/src/video/dummy/*.c"
+        have_video=yes
+    fi
+}
+
+dnl Check to see if OpenGL support is desired
+AC_ARG_ENABLE(video-opengl,
+AC_HELP_STRING([--enable-video-opengl], [include OpenGL context creation [[default=yes]]]),
+              , enable_video_opengl=yes)
+
+dnl Find OpenGL
+CheckOpenGLX11()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_MSG_CHECKING(for OpenGL (GLX) support)
+        video_opengl=no
+        AC_TRY_COMPILE([
+         #include <GL/gl.h>
+         #include <GL/glx.h>
+         #include <GL/glu.h>
+        ],[
+        ],[
+        video_opengl=yes
+        ])
+        AC_MSG_RESULT($video_opengl)
+        if test x$video_opengl = xyes; then
+            AC_DEFINE(SDL_VIDEO_OPENGL)
+            AC_DEFINE(SDL_VIDEO_OPENGL_GLX)
+        fi
+    fi
+}
+
+dnl Find QNX RtP OpenGL
+CheckOpenGLQNX()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_MSG_CHECKING(for OpenGL (Photon) support)
+        video_opengl=no
+        AC_TRY_COMPILE([
+         #include <GL/gl.h>
+        ],[
+        ],[
+        video_opengl=yes
+        ])
+        AC_MSG_RESULT($video_opengl)
+        if test x$video_opengl = xyes; then
+            AC_DEFINE(SDL_VIDEO_OPENGL)
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lGL"
+        fi
+    fi
+}
+
+dnl Check for Win32 OpenGL
+CheckWIN32GL()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_DEFINE(SDL_VIDEO_OPENGL)
+        AC_DEFINE(SDL_VIDEO_OPENGL_WGL)
+    fi
+}
+
+dnl Check for BeOS OpenGL
+CheckBeGL()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_DEFINE(SDL_VIDEO_OPENGL)
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lGL"
+    fi
+}
+
+dnl Check for MacOS OpenGL
+CheckMacGL()
+{
+    if test x$enable_video = xyes -a x$enable_video_opengl = xyes; then
+        AC_DEFINE(SDL_VIDEO_OPENGL)
+        case "$host" in
+            *-*-darwin*)
+                if test x$enable_video_cocoa = xyes; then
+                    EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,OpenGL"
+                fi
+                if test x$enable_video_carbon = xyes; then
+                    EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,AGL"
+                fi
+        esac
+    fi
+}
+
+dnl Check for Mesa offscreen rendering
+CheckAtariOSMesa()
+{
+    if test "x$enable_video" = "xyes" -a "x$enable_video_opengl" = "xyes"; then
+        AC_CHECK_HEADER(GL/osmesa.h, have_osmesa_hdr=yes)
+        AC_CHECK_LIB(OSMesa, OSMesaCreateContext, have_osmesa_lib=yes, have_osmesa_lib=no, -lm)
+
+        # Static linking to -lOSMesa
+        AC_PATH_PROG(OSMESA_CONFIG, osmesa-config, no)
+        if test "x$OSMESA_CONFIG" = "xno" -o "x$enable_atari_ldg" = "xno"; then
+            # -lOSMesa is really the static library
+            if test "x$have_osmesa_hdr" = "xyes" -a "x$have_osmesa_lib" = "xyes"; then
+                OSMESA_LIBS="-lOSMesa"
+            fi
+        else
+            # -lOSMesa is a loader for OSMesa.ldg
+            OSMESA_CFLAGS=`$OSMESA_CONFIG --cflags`
+            OSMESA_LIBS=`$OSMESA_CONFIG --libs`
+        fi
+        AC_DEFINE(SDL_VIDEO_OPENGL)
+        AC_DEFINE(SDL_VIDEO_OPENGL_OSMESA)
+        SDL_CFLAGS="$SDL_CFLAGS $OSMESA_CFLAGS"
+        SDL_LIBS="$SDL_LIBS $OSMESA_LIBS"
+
+        AC_ARG_ENABLE(osmesa-shared,
+AC_HELP_STRING([--enable-osmesa-shared], [dynamically load OSMesa OpenGL support [[default=yes]]]),
+                              , enable_osmesa_shared=yes)
+        if test "x$enable_osmesa_shared" = "xyes" -a "x$enable_atari_ldg" = "xyes"; then
+            # Dynamic linking
+            if test "x$have_osmesa_hdr" = "xyes"; then
+                AC_DEFINE(SDL_VIDEO_OPENGL_OSMESA_DYNAMIC)
+            fi
+        fi
+    fi
+}
+
+dnl See if we can use the new unified event interface in Linux 2.4
+CheckInputEvents()
+{
+    dnl Check for Linux 2.4 unified input event interface support
+    AC_ARG_ENABLE(input-events,
+AC_HELP_STRING([--enable-input-events], [use Linux 2.4 unified input interface [[default=yes]]]),
+                  , enable_input_events=yes)
+    if test x$enable_input_events = xyes; then
+        AC_MSG_CHECKING(for Linux 2.4 unified input interface)
+        use_input_events=no
+        AC_TRY_COMPILE([
+          #include <linux/input.h>
+        ],[
+          #ifndef EVIOCGNAME
+          #error EVIOCGNAME() ioctl not available
+          #endif
+        ],[
+        use_input_events=yes
+        ])
+        AC_MSG_RESULT($use_input_events)
+        if test x$use_input_events = xyes; then
+            AC_DEFINE(SDL_INPUT_LINUXEV)
+        fi
+    fi
+}
+
+dnl See if we can use the Touchscreen input library
+CheckTslib()
+{
+    AC_ARG_ENABLE(input-tslib,
+AC_HELP_STRING([--enable-input-tslib], [use the Touchscreen library for input [[default=yes]]]),
+                  , enable_input_tslib=yes)
+    if test x$enable_input_tslib = xyes; then
+        AC_MSG_CHECKING(for Touchscreen library support)
+        enable_input_tslib=no
+        AC_TRY_COMPILE([
+          #include "tslib.h"
+        ],[
+        ],[
+        enable_input_tslib=yes
+        ])
+        AC_MSG_RESULT($enable_input_tslib)
+        if test x$enable_input_tslib = xyes; then
+            AC_DEFINE(SDL_INPUT_TSLIB)
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lts"
+        fi
+    fi
+}
+
+dnl See if we can use GNU pth library for threads
+CheckPTH()
+{
+    dnl Check for pth support
+    AC_ARG_ENABLE(pth,
+AC_HELP_STRING([--enable-pth], [use GNU pth library for multi-threading [[default=yes]]]),
+                  , enable_pth=yes)
+    if test x$enable_threads = xyes -a x$enable_pth = xyes; then
+        AC_PATH_PROG(PTH_CONFIG, pth-config, no)
+        if test "$PTH_CONFIG" = "no"; then
+            use_pth=no
+        else
+            use_pth=yes
+        fi
+        AC_MSG_CHECKING(pth)
+        AC_MSG_RESULT($use_pth)
+        if test "x$use_pth" = xyes; then
+            AC_DEFINE(SDL_THREAD_PTH)
+            SOURCES="$SOURCES $srcdir/src/thread/pth/*.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syssem.c"
+            SDL_CFLAGS="$SDL_CFLAGS `$PTH_CONFIG --cflags`"
+            SDL_LIBS="$SDL_LIBS `$PTH_CONFIG --libs --all`"
+            have_threads=yes
+        fi
+    fi
+}
+
+dnl See what type of thread model to use on Linux and Solaris
+CheckPTHREAD()
+{
+    dnl Check for pthread support
+    AC_ARG_ENABLE(pthreads,
+AC_HELP_STRING([--enable-pthreads], [use POSIX threads for multi-threading [[default=yes]]]),
+                  , enable_pthreads=yes)
+    dnl This is used on Linux for glibc binary compatibility (Doh!)
+    AC_ARG_ENABLE(pthread-sem,
+AC_HELP_STRING([--enable-pthread-sem], [use pthread semaphores [[default=yes]]]),
+                  , enable_pthread_sem=yes)
+    case "$host" in
+        *-*-linux*|*-*-uclinux*)
+            pthread_cflags="-D_REENTRANT"
+            pthread_lib="-lpthread"
+            ;;
+        *-*-bsdi*)
+            pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
+            pthread_lib=""
+            ;;
+        *-*-darwin*)
+            pthread_cflags="-D_THREAD_SAFE"
+# causes Carbon.p complaints?
+#            pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
+            ;;
+        *-*-freebsd*|*-*-dragonfly*)
+            pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
+            pthread_lib="-pthread"
+            ;;
+        *-*-netbsd*)
+            pthread_cflags="-D_REENTRANT -D_THREAD_SAFE"
+            pthread_lib="-lpthread"
+            ;;
+        *-*-openbsd*)
+            pthread_cflags="-D_REENTRANT"
+            pthread_lib="-pthread"
+            ;;
+        *-*-solaris*)
+            pthread_cflags="-D_REENTRANT"
+            pthread_lib="-lpthread -lposix4"
+            ;;
+        *-*-sysv5*)
+            pthread_cflags="-D_REENTRANT -Kthread"
+            pthread_lib=""
+            ;;
+        *-*-irix*)
+            pthread_cflags="-D_SGI_MP_SOURCE"
+            pthread_lib="-lpthread"
+            ;;
+        *-*-aix*)
+            pthread_cflags="-D_REENTRANT -mthreads"
+            pthread_lib="-lpthread"
+            ;;
+        *-*-hpux11*)
+            pthread_cflags="-D_REENTRANT"
+            pthread_lib="-L/usr/lib -lpthread"
+            ;;
+        *-*-qnx*)
+            pthread_cflags=""
+            pthread_lib=""
+            ;;
+        *-*-osf*)
+            pthread_cflags="-D_REENTRANT"
+            if test x$ac_cv_prog_gcc = xyes; then
+                pthread_lib="-lpthread -lrt"
+            else
+                pthread_lib="-lpthread -lexc -lrt"
+            fi
+            ;;
+        *)
+            pthread_cflags="-D_REENTRANT"
+            pthread_lib="-lpthread"
+            ;;
+    esac
+    if test x$enable_threads = xyes -a x$enable_pthreads = xyes -a x$enable_ipod != xyes; then
+        # Save the original compiler flags and libraries
+        ac_save_cflags="$CFLAGS"; ac_save_libs="$LIBS"
+        # Add the pthread compiler flags and libraries
+        CFLAGS="$CFLAGS $pthread_cflags"; LIBS="$LIBS $pthread_lib"
+        # Check to see if we have pthread support on this system
+        AC_MSG_CHECKING(for pthreads)
+        use_pthreads=no
+        AC_TRY_LINK([
+         #include <pthread.h>
+        ],[
+         pthread_attr_t type;
+         pthread_attr_init(&type);
+        ],[
+        use_pthreads=yes
+        ])
+        AC_MSG_RESULT($use_pthreads)
+        # Restore the compiler flags and libraries
+        CFLAGS="$ac_save_cflags"; LIBS="$ac_save_libs"
+
+        # Do futher testing if we have pthread support...
+        if test x$use_pthreads = xyes; then
+            AC_DEFINE(SDL_THREAD_PTHREAD)
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $pthread_cflags"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS $pthread_lib"
+            SDL_CFLAGS="$SDL_CFLAGS $pthread_cflags"
+            SDL_LIBS="$SDL_LIBS $pthread_lib"
+
+            # Save the original compiler flags and libraries
+            ac_save_cflags="$CFLAGS"; ac_save_libs="$LIBS"
+            # Add the pthread compiler flags and libraries
+            CFLAGS="$CFLAGS $pthread_cflags"; LIBS="$LIBS $pthread_lib"
+
+            # Check to see if recursive mutexes are available
+            AC_MSG_CHECKING(for recursive mutexes)
+            has_recursive_mutexes=no
+            if test x$has_recursive_mutexes = xno; then
+                AC_TRY_COMPILE([
+                  #include <pthread.h>
+                ],[
+                  pthread_mutexattr_t attr;
+                  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+                ],[
+                has_recursive_mutexes=yes
+                AC_DEFINE(SDL_THREAD_PTHREAD_RECURSIVE_MUTEX)
+                ])
+            fi
+            if test x$has_recursive_mutexes = xno; then
+                AC_TRY_COMPILE([
+                  #include <pthread.h>
+                ],[
+                  pthread_mutexattr_t attr;
+                  pthread_mutexattr_setkind_np(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
+                ],[
+                has_recursive_mutexes=yes
+                AC_DEFINE(SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP)
+                ])
+            fi
+            AC_MSG_RESULT($has_recursive_mutexes)
+
+            # Check to see if pthread semaphore support is missing
+            if test x$enable_pthread_sem = xyes; then
+                AC_MSG_CHECKING(for pthread semaphores)
+                have_pthread_sem=no
+                AC_TRY_COMPILE([
+                  #include <pthread.h>
+                  #include <semaphore.h>
+                ],[
+                ],[
+                have_pthread_sem=yes
+                ])
+                AC_MSG_RESULT($have_pthread_sem)
+            fi
+
+            # Restore the compiler flags and libraries
+            CFLAGS="$ac_save_cflags"; LIBS="$ac_save_libs"
+
+            # Basic thread creation functions
+            SOURCES="$SOURCES $srcdir/src/thread/pthread/SDL_systhread.c"
+
+            # Semaphores
+            # We can fake these with mutexes and condition variables if necessary
+            if test x$have_pthread_sem = xyes; then
+                SOURCES="$SOURCES $srcdir/src/thread/pthread/SDL_syssem.c"
+            else
+                SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syssem.c"
+            fi
+
+            # Mutexes
+            # We can fake these with semaphores if necessary
+            SOURCES="$SOURCES $srcdir/src/thread/pthread/SDL_sysmutex.c"
+
+            # Condition variables
+            # We can fake these with semaphores and mutexes if necessary
+            SOURCES="$SOURCES $srcdir/src/thread/pthread/SDL_syscond.c"
+
+            have_threads=yes
+        else
+            CheckPTH
+        fi
+    fi
+}
+
+dnl Determine whether the compiler can produce Win32 executables
+CheckWIN32()
+{
+    AC_MSG_CHECKING(Win32 compiler)
+    have_win32_gcc=no
+    AC_TRY_COMPILE([
+     #include <windows.h>
+    ],[
+    ],[
+    have_win32_gcc=yes
+    ])
+    AC_MSG_RESULT($have_win32_gcc)
+    if test x$have_win32_gcc != xyes; then
+       AC_MSG_ERROR([
+*** Your compiler ($CC) does not produce Win32 executables!
+       ])
+    fi
+
+    dnl See if the user wants to redirect standard output to files
+    AC_ARG_ENABLE(stdio-redirect,
+AC_HELP_STRING([--enable-stdio-redirect], [Redirect STDIO to files on Win32 [[default=yes]]]),
+                  , enable_stdio_redirect=yes)
+    if test x$enable_stdio_redirect != xyes; then
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DNO_STDIO_REDIRECT"
+    fi
+
+    if test x$enable_video = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_WINDIB)
+        SOURCES="$SOURCES $srcdir/src/video/wincommon/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/windib/*.c"
+        have_video=yes
+    fi
+}
+
+dnl Find the DirectX includes and libraries
+CheckDIRECTX()
+{
+    AC_ARG_ENABLE(directx,
+AC_HELP_STRING([--enable-directx], [use DirectX for Win32 audio/video [[default=yes]]]),
+                  , enable_directx=yes)
+    if test x$enable_directx = xyes; then
+        have_directx=no
+        AC_CHECK_HEADER(ddraw.h, have_ddraw=yes)
+        AC_CHECK_HEADER(dsound.h, have_dsound=yes)
+        AC_CHECK_HEADER(dinput.h, use_dinput=yes)
+        if test x$have_ddraw = xyes -a x$have_dsound = xyes -a x$use_dinput = xyes; then
+            have_directx=yes
+        fi
+        if test x$enable_video = xyes -a x$have_directx = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_DDRAW)
+            SOURCES="$SOURCES $srcdir/src/video/windx5/*.c"
+            have_video=yes
+        fi
+    fi
+}
+
+dnl Check for the dlfcn.h interface for dynamically loading objects
+CheckDLOPEN()
+{
+    AC_ARG_ENABLE(sdl-dlopen,
+AC_HELP_STRING([--enable-sdl-dlopen], [use dlopen for shared object loading [[default=yes]]]),
+                  , enable_sdl_dlopen=yes)
+    if test x$enable_sdl_dlopen = xyes; then
+        AC_MSG_CHECKING(for dlopen)
+        have_dlopen=no
+        AC_TRY_COMPILE([
+         #include <dlfcn.h>
+        ],[
+         #if defined(MAC_OS_X_VERSION_MIN_REQUIRED) && MAC_OS_X_VERSION_MIN_REQUIRED <= 1020
+         #error Use dlcompat for Mac OS X 10.2 compatibility
+         #endif
+        ],[
+        have_dlopen=yes
+        ])
+        AC_MSG_RESULT($have_dlopen)
+
+        if test x$have_dlopen = xyes; then
+            AC_CHECK_LIB(c, dlopen, EXTRA_LDFLAGS="$EXTRA_LDFLAGS",
+               AC_CHECK_LIB(dl, dlopen, EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ldl",
+                  AC_CHECK_LIB(ltdl, dlopen, EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lltdl")))
+            AC_CHECK_LIB(dl, dlvsym, have_dlvsym=yes)
+            if test x$have_dlvsym = xyes; then
+                AC_DEFINE(HAVE_DLVSYM)
+            fi
+            AC_DEFINE(SDL_LOADSO_DLOPEN)
+            SOURCES="$SOURCES $srcdir/src/loadso/dlopen/*.c"
+            have_loadso=yes
+        fi
+    fi
+}
+
+dnl Set up the Atari LDG (shared object loader)
+CheckAtariLdg()
+{
+    AC_ARG_ENABLE(atari-ldg,
+AC_HELP_STRING([--enable-atari-ldg], [use Atari LDG for shared object loading [[default=yes]]]),
+                  , enable_atari_ldg=yes)
+    if test x$video_gem = xyes -a x$enable_atari_ldg = xyes; then
+        AC_CHECK_HEADER(ldg.h, have_ldg_hdr=yes)
+        AC_CHECK_LIB(ldg, ldg_open, have_ldg_lib=yes, have_ldg_lib=no, -lgem)
+        if test x$have_ldg_hdr = xyes -a x$have_ldg_lib = xyes; then
+            AC_DEFINE(SDL_LOADSO_LDG)
+            SOURCES="$SOURCES $srcdir/src/loadso/mint/*.c"
+            SDL_LIBS="$SDL_LIBS -lldg -lgem"
+            have_loadso=yes
+        fi
+    fi
+}
+
+dnl Check for the usbhid(3) library on *BSD
+CheckUSBHID()
+{
+    if test x$enable_joystick = xyes; then
+        AC_CHECK_LIB(usbhid, hid_init, have_libusbhid=yes)
+        if test x$have_libusbhid = xyes; then
+            AC_CHECK_HEADER(usbhid.h, [USB_CFLAGS="-DHAVE_USBHID_H"])
+            AC_CHECK_HEADER(libusbhid.h, [USB_CFLAGS="-DHAVE_LIBUSBHID_H"])
+            USB_LIBS="$USB_LIBS -lusbhid"
+        else
+            AC_CHECK_HEADER(usb.h, [USB_CFLAGS="-DHAVE_USB_H"])
+            AC_CHECK_HEADER(libusb.h, [USB_CFLAGS="-DHAVE_LIBUSB_H"])
+            AC_CHECK_LIB(usb, hid_init, [USB_LIBS="$USB_LIBS -lusb"])
+        fi
+            
+        save_CFLAGS="$CFLAGS"
+        CFLAGS="$CFLAGS $USB_CFLAGS"
+
+        AC_MSG_CHECKING(for usbhid)
+        have_usbhid=no
+        AC_TRY_COMPILE([
+          #include <sys/types.h>
+          #if defined(HAVE_USB_H)
+          #include <usb.h>
+          #endif
+          #ifdef __DragonFly__
+          # include <bus/usb/usb.h>
+          # include <bus/usb/usbhid.h>
+          #else
+          # include <dev/usb/usb.h>
+          # include <dev/usb/usbhid.h>
+          #endif
+          #if defined(HAVE_USBHID_H)
+          #include <usbhid.h>
+          #elif defined(HAVE_LIBUSB_H)
+          #include <libusb.h>
+          #elif defined(HAVE_LIBUSBHID_H)
+          #include <libusbhid.h>
+          #endif
+        ],[
+          struct report_desc *repdesc;
+          struct usb_ctl_report *repbuf;
+          hid_kind_t hidkind;
+        ],[
+        have_usbhid=yes
+        ])
+        AC_MSG_RESULT($have_usbhid)
+
+        if test x$have_usbhid = xyes; then
+            AC_MSG_CHECKING(for ucr_data member of usb_ctl_report)
+            have_usbhid_ucr_data=no
+            AC_TRY_COMPILE([
+              #include <sys/types.h>
+              #if defined(HAVE_USB_H)
+              #include <usb.h>
+              #endif
+              #ifdef __DragonFly__
+              # include <bus/usb/usb.h>
+              # include <bus/usb/usbhid.h>
+              #else
+              # include <dev/usb/usb.h>
+              # include <dev/usb/usbhid.h>
+              #endif
+              #if defined(HAVE_USBHID_H)
+              #include <usbhid.h>
+              #elif defined(HAVE_LIBUSB_H)
+              #include <libusb.h>
+              #elif defined(HAVE_LIBUSBHID_H)
+              #include <libusbhid.h>
+              #endif
+            ],[
+              struct usb_ctl_report buf;
+              if (buf.ucr_data) { }
+            ],[
+            have_usbhid_ucr_data=yes
+            ])
+            if test x$have_usbhid_ucr_data = xyes; then
+                USB_CFLAGS="$USB_CFLAGS -DUSBHID_UCR_DATA"
+            fi
+            AC_MSG_RESULT($have_usbhid_ucr_data)
+            
+            AC_MSG_CHECKING(for new usbhid API)
+            have_usbhid_new=no
+            AC_TRY_COMPILE([
+              #include <sys/types.h>
+              #if defined(HAVE_USB_H)
+              #include <usb.h>
+              #endif
+              #ifdef __DragonFly__
+              #include <bus/usb/usb.h>
+              #include <bus/usb/usbhid.h>
+              #else
+              #include <dev/usb/usb.h>
+              #include <dev/usb/usbhid.h>
+              #endif
+              #if defined(HAVE_USBHID_H)
+              #include <usbhid.h>
+              #elif defined(HAVE_LIBUSB_H)
+              #include <libusb.h>
+              #elif defined(HAVE_LIBUSBHID_H)
+              #include <libusbhid.h>
+              #endif
+            ],[
+              report_desc_t d;
+              hid_start_parse(d, 1, 1);
+            ],[
+            have_usbhid_new=yes
+            ])
+            if test x$have_usbhid_new = xyes; then
+                USB_CFLAGS="$USB_CFLAGS -DUSBHID_NEW"
+            fi
+            AC_MSG_RESULT($have_usbhid_new)
+
+            AC_MSG_CHECKING(for struct joystick in machine/joystick.h)
+            have_machine_joystick=no
+            AC_TRY_COMPILE([
+              #include <machine/joystick.h>
+            ],[
+              struct joystick t;
+            ],[
+            have_machine_joystick=yes
+            ])
+            if test x$have_machine_joystick = xyes; then
+                AC_DEFINE(SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H)
+            fi
+            AC_MSG_RESULT($have_machine_joystick)
+
+            AC_DEFINE(SDL_JOYSTICK_USBHID)
+            SOURCES="$SOURCES $srcdir/src/joystick/bsd/*.c"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS $USB_CFLAGS"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS $USB_LIBS"
+            have_joystick=yes
+        fi
+        CFLAGS="$save_CFLAGS"
+    fi
+}
+
+dnl Check for clock_gettime()
+CheckClockGettime()
+{
+    AC_ARG_ENABLE(clock_gettime,
+AC_HELP_STRING([--enable-clock_gettime], [use clock_gettime() instead of gettimeofday() on UNIX [[default=no]]]),
+                  , enable_clock_gettime=no)
+    if test x$enable_clock_gettime = xyes; then
+        AC_CHECK_LIB(rt, clock_gettime, have_clock_gettime=yes)
+        if test x$have_clock_gettime = xyes; then
+            AC_DEFINE(HAVE_CLOCK_GETTIME)
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lrt"
+        fi
+    fi
+}
+
+dnl Check for a valid linux/version.h
+CheckLinuxVersion()
+{
+    AC_CHECK_HEADER(linux/version.h, have_linux_version_h=yes)
+    if test x$have_linux_version_h = xyes; then
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DHAVE_LINUX_VERSION_H"
+    fi
+}
+
+dnl Check if we want to use RPATH
+CheckRPATH()
+{
+    AC_ARG_ENABLE(rpath,
+AC_HELP_STRING([--enable-rpath], [use an rpath when linking SDL [[default=yes]]]),
+                  , enable_rpath=yes)
+}
+
+dnl Set up the configuration based on the host platform!
+case "$host" in
+    arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
+        ARCH=linux
+        CheckDummyVideo
+        CheckIPod
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        ;;
+    *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*)
+        case "$host" in
+            *-*-linux*)         ARCH=linux ;;
+            *-*-uclinux*)       ARCH=linux ;;
+            *-*-kfreebsd*-gnu)  ARCH=kfreebsd-gnu ;;
+            *-*-knetbsd*-gnu)   ARCH=knetbsd-gnu ;;
+            *-*-kopenbsd*-gnu)  ARCH=kopenbsd-gnu ;;
+            *-*-gnu*)           ARCH=gnu ;; # must be last of the gnu variants
+            *-*-bsdi*)          ARCH=bsdi ;;
+            *-*-freebsd*)       ARCH=freebsd ;;
+            *-*-dragonfly*)     ARCH=freebsd ;;
+            *-*-netbsd*)        ARCH=netbsd ;;
+            *-*-openbsd*)       ARCH=openbsd ;;
+            *-*-sysv5*)         ARCH=sysv5 ;;
+            *-*-solaris*)       ARCH=solaris ;;
+            *-*-hpux*)          ARCH=hpux ;;
+            *-*-irix*)          ARCH=irix ;;
+            *-*-aix*)           ARCH=aix ;;
+            *-*-osf*)           ARCH=osf ;;
+        esac
+        CheckVisibilityHidden
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        CheckDLOPEN
+        CheckNASM
+        CheckAltivec
+        CheckOSS
+        CheckDMEDIA
+        CheckMME
+        CheckALSA
+        CheckARTSC
+        CheckESD
+        CheckPulseAudio
+        CheckNAS
+        CheckX11
+        CheckNANOX
+        CheckFBCON
+        CheckDirectFB
+        CheckPS2GS
+        CheckGGI
+        CheckSVGA
+        CheckVGL
+        CheckWscons
+        CheckAAlib
+        CheckQtopia
+        CheckPicoGUI
+        CheckOpenGLX11
+        CheckInputEvents
+        CheckTslib
+        CheckUSBHID
+        CheckPTHREAD
+        CheckClockGettime
+        CheckLinuxVersion
+        CheckRPATH
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+          case $ARCH in
+            sysv5|solaris|hpux)
+                AC_DEFINE(SDL_AUDIO_DRIVER_SUNAUDIO)
+                SOURCES="$SOURCES $srcdir/src/audio/sun/*.c"
+                have_audio=yes
+            ;;
+            netbsd|openbsd)
+                AC_DEFINE(SDL_AUDIO_DRIVER_BSD)
+                SOURCES="$SOURCES $srcdir/src/audio/bsd/*.c"
+                have_audio=yes
+            ;;
+            aix)
+                AC_DEFINE(SDL_AUDIO_DRIVER_PAUD)
+                SOURCES="$SOURCES $srcdir/src/audio/paudio/*.c"
+                have_audio=yes
+            ;;
+          esac
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+          case $ARCH in
+            linux)
+                AC_DEFINE(SDL_JOYSTICK_LINUX)
+                SOURCES="$SOURCES $srcdir/src/joystick/linux/*.c"
+                have_joystick=yes
+            ;;
+          esac
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+          case $ARCH in
+            linux|solaris)
+                AC_DEFINE(SDL_CDROM_LINUX)
+                SOURCES="$SOURCES $srcdir/src/cdrom/linux/*.c"
+                have_cdrom=yes
+            ;;
+            *freebsd*)
+                AC_DEFINE(SDL_CDROM_FREEBSD)
+                SOURCES="$SOURCES $srcdir/src/cdrom/freebsd/*.c"
+                have_cdrom=yes
+            ;;
+            *openbsd*|*netbsd*)
+                AC_DEFINE(SDL_CDROM_OPENBSD)
+                SOURCES="$SOURCES $srcdir/src/cdrom/openbsd/*.c"
+                have_cdrom=yes
+            ;;
+            bsdi)
+                AC_DEFINE(SDL_CDROM_BSDI)
+                SOURCES="$SOURCES $srcdir/src/cdrom/bsdi/*.c"
+                have_cdrom=yes
+            ;;
+            aix)
+                AC_DEFINE(SDL_CDROM_AIX)
+                SOURCES="$SOURCES $srcdir/src/cdrom/aix/*.c"
+                have_cdrom=yes
+            ;;
+            osf)
+                AC_DEFINE(SDL_CDROM_OSF)
+                SOURCES="$SOURCES $srcdir/src/cdrom/osf/*.c"
+                have_cdrom=yes
+            ;;
+          esac
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes -a x$use_pthreads != xyes -a x$use_pth != xyes -a x$ARCH = xirix; then
+            AC_DEFINE(SDL_THREAD_SPROC)
+            SOURCES="$SOURCES $srcdir/src/thread/irix/*.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_sysmutex.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syscond.c"
+            have_threads=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        ;;
+    *-*-qnx*)
+        ARCH=qnx
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        # CheckNASM
+        CheckDLOPEN
+        CheckNAS
+        CheckPHOTON
+        CheckX11
+        CheckOpenGLX11
+        CheckPTHREAD
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_QNXNTO)
+            SOURCES="$SOURCES $srcdir/src/audio/nto/*.c"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lasound"
+            have_audio=yes
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+            AC_DEFINE(SDL_CDROM_QNX)
+            SOURCES="$SOURCES $srcdir/src/cdrom/qnx/*.c"
+            have_cdrom=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        ;;
+    *-*-cygwin* | *-*-mingw32*)
+        ARCH=win32
+        if test "$build" != "$host"; then # cross-compiling
+            # Default cross-compile location
+            ac_default_prefix=/usr/local/cross-tools/i386-mingw32
+        else
+            # Look for the location of the tools and install there
+            if test "$BUILD_PREFIX" != ""; then
+                ac_default_prefix=$BUILD_PREFIX
+            fi
+        fi
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        CheckWIN32
+        CheckWIN32GL
+        CheckDIRECTX
+        CheckNASM
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_WAVEOUT)
+            SOURCES="$SOURCES $srcdir/src/audio/windib/*.c"
+            if test x$have_directx = xyes; then
+                AC_DEFINE(SDL_AUDIO_DRIVER_DSOUND)
+                SOURCES="$SOURCES $srcdir/src/audio/windx5/*.c"
+            fi
+            have_audio=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_WINMM)
+            SOURCES="$SOURCES $srcdir/src/joystick/win32/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+            AC_DEFINE(SDL_CDROM_WIN32)
+            SOURCES="$SOURCES $srcdir/src/cdrom/win32/*.c"
+            have_cdrom=yes
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+            AC_DEFINE(SDL_THREAD_WIN32)
+            SOURCES="$SOURCES $srcdir/src/thread/win32/SDL_sysmutex.c"
+            SOURCES="$SOURCES $srcdir/src/thread/win32/SDL_syssem.c"
+            SOURCES="$SOURCES $srcdir/src/thread/win32/SDL_systhread.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syscond.c"
+            have_threads=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_WIN32)
+            SOURCES="$SOURCES $srcdir/src/timer/win32/*.c"
+            have_timers=yes
+        fi
+        # Set up files for the shared object loading library
+        if test x$enable_loadso = xyes; then
+            AC_DEFINE(SDL_LOADSO_WIN32)
+            SOURCES="$SOURCES $srcdir/src/loadso/win32/*.c"
+            have_loadso=yes
+        fi
+        # Set up the system libraries we need
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -luser32 -lgdi32 -lwinmm"
+        if test x$have_directx = xyes; then
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ldxguid"
+        fi
+        # The Win32 platform requires special setup
+        SOURCES="$SOURCES $srcdir/src/main/win32/*.rc"
+        SDLMAIN_SOURCES="$srcdir/src/main/win32/*.c"
+        SDL_CFLAGS="$SDL_CFLAGS -Dmain=SDL_main"
+        SDL_LIBS="-lmingw32 -lSDLmain $SDL_LIBS -mwindows"
+        ;;
+    *-*-beos*)
+        ARCH=beos
+        ac_default_prefix=/boot/develop/tools/gnupro
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        CheckNASM
+        CheckBWINDOW
+        CheckBeGL
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_BAUDIO)
+            SOURCES="$SOURCES $srcdir/src/audio/baudio/*.cc"
+            have_audio=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_BEOS)
+            SOURCES="$SOURCES $srcdir/src/joystick/beos/*.cc"
+            have_joystick=yes
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+            AC_DEFINE(SDL_CDROM_BEOS)
+            SOURCES="$SOURCES $srcdir/src/cdrom/beos/*.cc"
+            have_cdrom=yes
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+            AC_DEFINE(SDL_THREAD_BEOS)
+            SOURCES="$SOURCES $srcdir/src/thread/beos/*.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_sysmutex.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syscond.c"
+            have_threads=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_BEOS)
+            SOURCES="$SOURCES $srcdir/src/timer/beos/*.c"
+            have_timers=yes
+        fi
+        # Set up files for the shared object loading library
+        if test x$enable_loadso = xyes; then
+            AC_DEFINE(SDL_LOADSO_BEOS)
+            SOURCES="$SOURCES $srcdir/src/loadso/beos/*.c"
+            have_loadso=yes
+        fi
+        # The BeOS platform requires special setup.
+        SOURCES="$srcdir/src/main/beos/*.cc $SOURCES"
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lroot -lbe -lmedia -lgame -ldevice -ltextencoding"
+        ;;
+    *-*-darwin* )
+        # This could be either full "Mac OS X", or plain "Darwin" which is
+        # just the OS X kernel sans upper layers like Carbon and Cocoa.
+        # Next line is broken, and a few files below require Mac OS X (full)
+        ARCH=macosx
+
+        # Mac OS X builds with both the Carbon and OSX APIs at the moment
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DTARGET_API_MAC_CARBON"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DTARGET_API_MAC_OSX"
+
+        # HACK: Reset EXTRA_LDFLAGS; the only thing it contains at this point
+        # is -lm which is not needed under Mac OS X. But for some reasons it
+        # also tends to contain spurious -L switches, which we don't want to
+        # use here or in sdl-config. Hence we reset it.
+        EXTRA_LDFLAGS=""
+
+        CheckVisibilityHidden
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        CheckDLOPEN
+        CheckNASM
+
+        # Set up files for the shared object loading library
+        # (this needs to be done before the dynamic X11 check)
+        if test x$enable_loadso = xyes -a x$have_dlopen != xyes; then
+            AC_DEFINE(SDL_LOADSO_DLCOMPAT)
+            SOURCES="$SOURCES $srcdir/src/loadso/macosx/*.c"
+            have_loadso=yes
+        fi
+
+        CheckCOCOA
+        CheckCARBON
+        CheckX11
+        CheckMacGL
+        CheckOpenGLX11
+        CheckPTHREAD
+        CheckAltivec
+
+        # Need this or things might misbuild on a G3.
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -force_cpusubtype_ALL"
+
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_COREAUDIO)
+            SOURCES="$SOURCES $srcdir/src/audio/macosx/*.c"
+            AC_DEFINE(SDL_AUDIO_DRIVER_SNDMGR)
+            SOURCES="$SOURCES $srcdir/src/audio/macrom/*.c"
+            have_audio=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_IOKIT)
+            SOURCES="$SOURCES $srcdir/src/joystick/darwin/*.c"
+            have_joystick=yes
+            need_iokit_framework=yes
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+            AC_DEFINE(SDL_CDROM_MACOSX)
+            SOURCES="$SOURCES $srcdir/src/cdrom/macosx/*.c"
+            have_cdrom=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_UNIX)
+            SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            have_timers=yes
+        fi
+        # The Mac OS X platform requires special setup.
+        SDLMAIN_SOURCES="$srcdir/src/main/macosx/*.m"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -fpascal-strings"
+        SDL_LIBS="-lSDLmain $SDL_LIBS"
+        if test x$enable_video_cocoa = xyes; then
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,Cocoa"
+            need_iokit_framework=yes
+        fi
+        if test x$enable_video_carbon = xyes -o x$enable_video_cocoa = xyes; then
+            # The Cocoa backend still needs Carbon, and the YUV code QuickTime
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,QuickTime -Wl,-framework,ApplicationServices"
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,Carbon"
+        fi
+        # If either the audio or CD driver is used, add the AudioUnit framework
+        if test x$enable_audio = xyes -o x$enable_cdrom = xyes; then
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,AudioToolbox -Wl,-framework,AudioUnit"
+        fi
+        # Some subsystems reference IOKit...
+        if test x$need_iokit_framework = xyes; then
+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,IOKit"
+        fi
+        ;;
+    *-*-mint*)
+        ARCH=mint
+        CheckDummyVideo
+        CheckDiskAudio
+        CheckDummyAudio
+        CheckAtariBiosEvent
+        CheckAtariXbiosVideo
+        CheckAtariGemVideo
+        CheckAtariAudio
+        CheckAtariLdg
+        CheckAtariOSMesa
+        CheckPTH
+        # Set up files for the audio library
+        if test x$enable_threads = xyes -a x$enable_pth = xyes; then
+            if test x$enable_audio = xyes; then
+                AC_DEFINE(SDL_AUDIO_DRIVER_SUNAUDIO)
+                SOURCES="$SOURCES $srcdir/src/audio/sun/*.c"
+                have_audio=yes
+            fi
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_MINT)
+            SOURCES="$SOURCES $srcdir/src/joystick/mint/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the cdrom library
+        if test x$enable_cdrom = xyes; then
+            AC_DEFINE(SDL_CDROM_MINT)
+            SOURCES="$SOURCES $srcdir/src/cdrom/mint/*.c"
+            have_cdrom=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            if test x$enable_threads = xyes -a x$enable_pth = xyes; then
+                AC_DEFINE(SDL_TIMER_UNIX)
+                SOURCES="$SOURCES $srcdir/src/timer/unix/*.c"
+            else
+                AC_DEFINE(SDL_TIMER_MINT)
+                SOURCES="$SOURCES $srcdir/src/timer/mint/*.c"
+                SOURCES="$SOURCES $srcdir/src/timer/mint/*.S"
+            fi
+            have_timers=yes
+        fi
+        ;;
+    *-riscos)
+        ARCH=riscos
+        CheckOSS
+        CheckPTHREAD
+        # Set up files for the video library
+        if test x$enable_video = xyes; then
+            AC_DEFINE(SDL_VIDEO_DRIVER_RISCOS)
+            SOURCES="$SOURCES $srcdir/src/video/riscos/*.c"
+            SOURCES="$SOURCES $srcdir/src/video/riscos/*.S"
+            have_video=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_RISCOS)
+            SOURCES="$SOURCES $srcdir/src/joystick/riscos/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_RISCOS)
+            SOURCES="$SOURCES $srcdir/src/timer/riscos/*.c"
+            have_timers=yes
+        fi
+        # The RISC OS platform requires special setup.
+        EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ljpeg -ltiff -lpng -lz"
+        ;;
+    *)
+        AC_MSG_ERROR([
+*** Unsupported host:  Please add to configure.in
+        ])
+        ;;
+esac
+
+# Verify that we have all the platform specific files we need
+
+if test x$enable_joystick = xyes; then
+  if test x$have_joystick != xyes; then
+    # Wants joystick subsystem, but doesn't have a platform-specific backend...
+    AC_DEFINE(SDL_JOYSTICK_DUMMY)
+    SOURCES="$SOURCES $srcdir/src/joystick/dummy/*.c"
+  fi
+fi
+if test x$have_cdrom != xyes; then
+    if test x$enable_cdrom = xyes; then
+        AC_DEFINE(SDL_CDROM_DISABLED)
+    fi
+    SOURCES="$SOURCES $srcdir/src/cdrom/dummy/*.c"
+fi
+if test x$have_threads != xyes; then
+    if test x$enable_threads = xyes; then
+        AC_DEFINE(SDL_THREADS_DISABLED)
+    fi
+    SOURCES="$SOURCES $srcdir/src/thread/generic/*.c"
+fi
+if test x$have_timers != xyes; then
+    if test x$enable_timers = xyes; then
+        AC_DEFINE(SDL_TIMERS_DISABLED)
+    fi
+    SOURCES="$SOURCES $srcdir/src/timer/dummy/*.c"
+fi
+if test x$have_loadso != xyes; then
+    if test x$enable_loadso = xyes; then
+        AC_DEFINE(SDL_LOADSO_DISABLED)
+    fi
+    SOURCES="$SOURCES $srcdir/src/loadso/dummy/*.c"
+fi
+if test x$SDLMAIN_SOURCES = x; then
+    SDLMAIN_SOURCES="$srcdir/src/main/dummy/*.c"
+fi
+
+OBJECTS=`echo $SOURCES | sed 's,[[^ ]]*/\([[^ ]]*\)\.asm,$(objects)/\1.lo,g'`
+OBJECTS=`echo $OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.cc,$(objects)/\1.lo,g'`
+OBJECTS=`echo $OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.m,$(objects)/\1.lo,g'`
+OBJECTS=`echo $OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.c,$(objects)/\1.lo,g'`
+OBJECTS=`echo $OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.S,$(objects)/\1.lo,g'`
+OBJECTS=`echo $OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.rc,$(objects)/\1.o,g'`
+
+SDLMAIN_OBJECTS=`echo $SDLMAIN_SOURCES | sed 's,[[^ ]]*/\([[^ ]]*\)\.cc,$(objects)/\1.o,g'`
+SDLMAIN_OBJECTS=`echo $SDLMAIN_OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.m,$(objects)/\1.o,g'`
+SDLMAIN_OBJECTS=`echo $SDLMAIN_OBJECTS | sed 's,[[^ ]]*/\([[^ ]]*\)\.c,$(objects)/\1.o,g'`
+
+# Set runtime shared library paths as needed
+
+if test "x$enable_rpath" = "xyes"; then
+  if test $ARCH = bsdi -o $ARCH = freebsd -o $ARCH = irix -o $ARCH = linux -o $ARCH = netbsd; then
+    SDL_RLD_FLAGS="-Wl,-rpath,\${libdir}"
+  fi
+  if test $ARCH = solaris; then
+    SDL_RLD_FLAGS="-R\${libdir}"
+  fi
+else
+  SDL_RLD_FLAGS=""
+fi
+
+case "$ARCH" in
+  macosx)
+    if test x$enable_video = xyes -a x$enable_video_cocoa = xyes; then
+      SDL_LIBS="$SDL_LIBS -Wl,-framework,Cocoa"
+    fi
+    if test x$enable_video = xyes -a x$enable_video_carbon = xyes; then
+      SDL_LIBS="$SDL_LIBS -Wl,-framework,Carbon"
+    fi
+    # Evil hack to allow static linking on Mac OS X
+    SDL_STATIC_LIBS="\${libdir}/libSDLmain.a \${libdir}/libSDL.a $EXTRA_LDFLAGS"
+    ;;
+  *)
+    SDL_STATIC_LIBS="$SDL_LIBS"
+    ;;
+esac
+
+dnl Expand the cflags and libraries needed by apps using SDL
+AC_SUBST(SDL_CFLAGS)
+AC_SUBST(SDL_LIBS)
+AC_SUBST(SDL_STATIC_LIBS)
+AC_SUBST(SDL_RLD_FLAGS)
+if test x$enable_shared = xyes; then
+    ENABLE_SHARED_TRUE=
+    ENABLE_SHARED_FALSE="#"
+else
+    ENABLE_SHARED_TRUE="#"
+    ENABLE_SHARED_FALSE=
+fi
+if test x$enable_static = xyes; then
+    ENABLE_STATIC_TRUE=
+    ENABLE_STATIC_FALSE="#"
+else
+    ENABLE_STATIC_TRUE="#"
+    ENABLE_STATIC_FALSE=
+fi
+AC_SUBST(ENABLE_SHARED_TRUE)
+AC_SUBST(ENABLE_SHARED_FALSE)
+AC_SUBST(ENABLE_STATIC_TRUE)
+AC_SUBST(ENABLE_STATIC_FALSE)
+
+dnl Expand the sources and objects needed to build the library
+AC_SUBST(ac_aux_dir)
+AC_SUBST(INCLUDE)
+AC_SUBST(SOURCES)
+AC_SUBST(OBJECTS)
+AC_SUBST(SDLMAIN_SOURCES)
+AC_SUBST(SDLMAIN_OBJECTS)
+AC_SUBST(BUILD_CFLAGS)
+AC_SUBST(EXTRA_CFLAGS)
+AC_SUBST(BUILD_LDFLAGS)
+AC_SUBST(EXTRA_LDFLAGS)
+AC_SUBST(WINDRES)
+
+AC_OUTPUT([
+    Makefile sdl-config SDL.spec SDL.qpg sdl.pc
+], [
+    : >build-deps
+    if test x"$MAKE" = x; then MAKE=make; fi; $MAKE depend
+])
diff -ruN SDL-1.2.13/include/SDL.h SDL-1.2.13_OOx64/include/SDL.h
--- SDL-1.2.13/include/SDL.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL.h	2017-12-19 13:41:45 +0000
@@ -57,6 +57,7 @@
 #define SDL_INIT_VIDEO		0x00000020
 #define SDL_INIT_CDROM		0x00000100
 #define SDL_INIT_JOYSTICK	0x00000200
+#define SDL_INIT_HAPTIC		0x00001000
 #define SDL_INIT_NOPARACHUTE	0x00100000	/* Don't catch fatal signals */
 #define SDL_INIT_EVENTTHREAD	0x01000000	/* Not supported on all OS's */
 #define SDL_INIT_EVERYTHING	0x0000FFFF
diff -ruN SDL-1.2.13/include/SDL.h.bak SDL-1.2.13_OOx64/include/SDL.h.bak
--- SDL-1.2.13/include/SDL.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,94 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+/* Main include header for the SDL library */
+
+#ifndef _SDL_H
+#define _SDL_H
+
+#include "SDL_main.h"
+#include "SDL_stdinc.h"
+#include "SDL_audio.h"
+#include "SDL_cdrom.h"
+#include "SDL_cpuinfo.h"
+#include "SDL_endian.h"
+#include "SDL_error.h"
+#include "SDL_events.h"
+#include "SDL_loadso.h"
+#include "SDL_mutex.h"
+#include "SDL_rwops.h"
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "SDL_video.h"
+#include "SDL_version.h"
+
+#include "begin_code.h"
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* As of version 0.5, SDL is loaded dynamically into the application */
+
+/* These are the flags which may be passed to SDL_Init() -- you should
+   specify the subsystems which you will be using in your application.
+*/
+#define	SDL_INIT_TIMER		0x00000001
+#define SDL_INIT_AUDIO		0x00000010
+#define SDL_INIT_VIDEO		0x00000020
+#define SDL_INIT_CDROM		0x00000100
+#define SDL_INIT_JOYSTICK	0x00000200
+#define SDL_INIT_NOPARACHUTE	0x00100000	/* Don't catch fatal signals */
+#define SDL_INIT_EVENTTHREAD	0x01000000	/* Not supported on all OS's */
+#define SDL_INIT_EVERYTHING	0x0000FFFF
+
+/* This function loads the SDL dynamically linked library and initializes 
+ * the subsystems specified by 'flags' (and those satisfying dependencies)
+ * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
+ * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
+ */
+extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);
+
+/* This function initializes specific SDL subsystems */
+extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);
+
+/* This function cleans up specific SDL subsystems */
+extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);
+
+/* This function returns mask of the specified subsystems which have
+   been initialized.
+   If 'flags' is 0, it returns a mask of all initialized subsystems.
+*/
+extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);
+
+/* This function cleans up all initialized subsystems and unloads the
+ * dynamically linked library.  You should call it upon all exit conditions.
+ */
+extern DECLSPEC void SDLCALL SDL_Quit(void);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_H */
diff -ruN SDL-1.2.13/include/SDL_config.h SDL-1.2.13_OOx64/include/SDL_config.h
--- SDL-1.2.13/include/SDL_config.h	2007-12-31 06:17:05 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config.h	2017-12-19 13:48:30 +0000
@@ -1,3 +1,4 @@
+/* include/SDL_config.h.  Generated from SDL_config.h.in by configure.  */
 /*
     SDL - Simple DirectMedia Layer
     Copyright (C) 1997-2006 Sam Lantinga
@@ -23,23 +24,291 @@
 #ifndef _SDL_config_h
 #define _SDL_config_h
 
+/* This is a set of defines to configure the SDL features */
+
+/* General platform specific identifiers */
 #include "SDL_platform.h"
 
-/* Add any platform that doesn't build using the configure system */
-#if defined(__DREAMCAST__)
-#include "SDL_config_dreamcast.h"
-#elif defined(__MACOS__)
-#include "SDL_config_macos.h"
-#elif defined(__MACOSX__)
-#include "SDL_config_macosx.h"
-#elif defined(__SYMBIAN32__)
-#include "SDL_config_symbian.h"  /* must be before win32! */
-#elif defined(__WIN32__)
-#include "SDL_config_win32.h"
-#elif defined(__OS2__)
-#include "SDL_config_os2.h"
+/* Make sure that this isn't included by Visual C++ */
+#ifdef _MSC_VER
+#error You should copy include/SDL_config.h.default to include/SDL_config.h
+#endif
+
+/* C language features */
+/* #undef const */
+/* #undef inline */
+/* #undef volatile */
+
+/* C datatypes */
+/* #undef size_t */
+/* #undef int8_t */
+/* #undef uint8_t */
+/* #undef int16_t */
+/* #undef uint16_t */
+/* #undef int32_t */
+/* #undef uint32_t */
+/* #undef int64_t */
+/* #undef uint64_t */
+/* #undef uintptr_t */
+#define SDL_HAS_64BIT_TYPE 1
+
+/* Endianness */
+#define SDL_BYTEORDER 1234
+
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+#if HAVE_LIBC
+
+/* Useful headers */
+/* #undef HAVE_ALLOCA_H */
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_SIGNAL_H 1
+/* #undef HAVE_ALTIVEC_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+/* #undef HAVE_ALLOCA */
+#ifndef _WIN32 /* Don't use C runtime versions of these on Windows */
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+/* #undef HAVE_UNSETENV */
+#endif
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+/* #undef HAVE_BCOPY */
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+/* #undef HAVE_STRLCPY */
+/* #undef HAVE_STRLCAT */
+#define HAVE_STRDUP 1
+#define HAVE__STRREV 1
+#define HAVE__STRUPR 1
+#define HAVE__STRLWR 1
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_ITOA 1
+#define HAVE__LTOA 1
+/* #undef HAVE__UITOA */
+#define HAVE__ULTOA 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+#define HAVE__I64TOA 1
+#define HAVE__UI64TOA 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE__STRICMP 1
+#define HAVE_STRCASECMP 1
+#define HAVE__STRNICMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+/* #undef HAVE_ICONV */
+/* #undef HAVE_SIGACTION */
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP 1
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_DLVSYM */
+/* #undef HAVE_GETPAGESIZE */
+/* #undef HAVE_MPROTECT */
+
 #else
-#include "SDL_config_minimal.h"
-#endif /* platform config */
+/* We may need some replacement for stdarg.h here */
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CDROM_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+/* #undef SDL_HAPTIC_DISABLED */
+/* #undef SDL_LOADSO_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_BAUDIO */
+/* #undef SDL_AUDIO_DRIVER_BSD */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DART */
+/* #undef SDL_AUDIO_DRIVER_DC */
+#define SDL_AUDIO_DRIVER_DISK 1
+#define SDL_AUDIO_DRIVER_DUMMY 1
+/* #undef SDL_AUDIO_DRIVER_DMEDIA */
+#define SDL_AUDIO_DRIVER_DSOUND 1
+/* #undef SDL_AUDIO_DRIVER_PULSE */
+/* #undef SDL_AUDIO_DRIVER_PULSE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_MINT */
+/* #undef SDL_AUDIO_DRIVER_MMEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUD */
+/* #undef SDL_AUDIO_DRIVER_QNXNTO */
+/* #undef SDL_AUDIO_DRIVER_SNDMGR */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+#define SDL_AUDIO_DRIVER_WAVEOUT 1
+
+/* Enable various cdrom drivers */
+/* #undef SDL_CDROM_AIX */
+/* #undef SDL_CDROM_BEOS */
+/* #undef SDL_CDROM_BSDI */
+/* #undef SDL_CDROM_DC */
+/* #undef SDL_CDROM_DUMMY */
+/* #undef SDL_CDROM_FREEBSD */
+/* #undef SDL_CDROM_LINUX */
+/* #undef SDL_CDROM_MACOS */
+/* #undef SDL_CDROM_MACOSX */
+/* #undef SDL_CDROM_MINT */
+/* #undef SDL_CDROM_OPENBSD */
+/* #undef SDL_CDROM_OS2 */
+/* #undef SDL_CDROM_OSF */
+/* #undef SDL_CDROM_QNX */
+#define SDL_CDROM_WIN32 1
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_TSLIB */
+/* #undef SDL_JOYSTICK_BEOS */
+/* #undef SDL_JOYSTICK_DC */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_MACOS */
+/* #undef SDL_JOYSTICK_MINT */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_RISCOS */
+#define SDL_JOYSTICK_WINMM 1
+//#define SDL_JOYSTICK_DINPUT 1
+#define SDL_HAPTIC_DINPUT 1
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H */
+/* #undef SDL_HAPTIC_DUMMY */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_BEOS */
+/* #undef SDL_LOADSO_DLCOMPAT */
+/* #undef SDL_LOADSO_DLOPEN */
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_MACOS */
+/* #undef SDL_LOADSO_OS2 */
+#define SDL_LOADSO_WIN32 1
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_BEOS */
+/* #undef SDL_THREAD_DC */
+/* #undef SDL_THREAD_OS2 */
+/* #undef SDL_THREAD_PTH */
+/* #undef SDL_THREAD_PTHREAD */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_SPROC */
+#define SDL_THREAD_WIN32 1
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_BEOS */
+/* #undef SDL_TIMER_DC */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_MACOS */
+/* #undef SDL_TIMER_MINT */
+/* #undef SDL_TIMER_OS2 */
+/* #undef SDL_TIMER_RISCOS */
+/* #undef SDL_TIMER_UNIX */
+#define SDL_TIMER_WIN32 1
+/* #undef SDL_TIMER_WINCE */
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_AALIB */
+/* #undef SDL_VIDEO_DRIVER_BWINDOW */
+/* #undef SDL_VIDEO_DRIVER_DC */
+#define SDL_VIDEO_DRIVER_DDRAW 1
+/* #undef SDL_VIDEO_DRIVER_DGA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DRAWSPROCKET */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_FBCON */
+/* #undef SDL_VIDEO_DRIVER_GAPI */
+/* #undef SDL_VIDEO_DRIVER_GEM */
+/* #undef SDL_VIDEO_DRIVER_GGI */
+/* #undef SDL_VIDEO_DRIVER_IPOD */
+/* #undef SDL_VIDEO_DRIVER_NANOX */
+/* #undef SDL_VIDEO_DRIVER_OS2FS */
+/* #undef SDL_VIDEO_DRIVER_PHOTON */
+/* #undef SDL_VIDEO_DRIVER_PICOGUI */
+/* #undef SDL_VIDEO_DRIVER_PS2GS */
+/* #undef SDL_VIDEO_DRIVER_QTOPIA */
+/* #undef SDL_VIDEO_DRIVER_QUARTZ */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+/* #undef SDL_VIDEO_DRIVER_SVGALIB */
+/* #undef SDL_VIDEO_DRIVER_TOOLBOX */
+/* #undef SDL_VIDEO_DRIVER_VGL */
+#define SDL_VIDEO_DRIVER_WINDIB 1
+/* #undef SDL_VIDEO_DRIVER_WSCONS */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_X11_DGAMOUSE */
+/* #undef SDL_VIDEO_DRIVER_X11_DPMS */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRENDER */
+/* #undef SDL_VIDEO_DRIVER_X11_VIDMODE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINERAMA */
+/* #undef SDL_VIDEO_DRIVER_X11_XME */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XV */
+/* #undef SDL_VIDEO_DRIVER_XBIOS */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+/* #undef SDL_VIDEO_OPENGL_GLX */
+#define SDL_VIDEO_OPENGL_WGL 1
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+#define SDL_HERMES_BLITTERS 1
+/* #undef SDL_ALTIVEC_BLITTERS */
 
 #endif /* _SDL_config_h */
diff -ruN SDL-1.2.13/include/SDL_config.h.bak SDL-1.2.13_OOx64/include/SDL_config.h.bak
--- SDL-1.2.13/include/SDL_config.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config.h.bak	2017-12-19 13:42:59 +0000
@@ -0,0 +1,314 @@
+/* include/SDL_config.h.  Generated from SDL_config.h.in by configure.  */
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_h
+#define _SDL_config_h
+
+/* This is a set of defines to configure the SDL features */
+
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* Make sure that this isn't included by Visual C++ */
+#ifdef _MSC_VER
+#error You should copy include/SDL_config.h.default to include/SDL_config.h
+#endif
+
+/* C language features */
+/* #undef const */
+/* #undef inline */
+/* #undef volatile */
+
+/* C datatypes */
+/* #undef size_t */
+/* #undef int8_t */
+/* #undef uint8_t */
+/* #undef int16_t */
+/* #undef uint16_t */
+/* #undef int32_t */
+/* #undef uint32_t */
+/* #undef int64_t */
+/* #undef uint64_t */
+/* #undef uintptr_t */
+#define SDL_HAS_64BIT_TYPE 1
+
+/* Endianness */
+#define SDL_BYTEORDER 1234
+
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+#if HAVE_LIBC
+
+/* Useful headers */
+/* #undef HAVE_ALLOCA_H */
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_ICONV_H 1
+#define HAVE_SIGNAL_H 1
+/* #undef HAVE_ALTIVEC_H */
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+/* #undef HAVE_ALLOCA */
+#ifndef _WIN32 /* Don't use C runtime versions of these on Windows */
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+/* #undef HAVE_UNSETENV */
+#endif
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+/* #undef HAVE_BCOPY */
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+/* #undef HAVE_STRLCPY */
+/* #undef HAVE_STRLCAT */
+#define HAVE_STRDUP 1
+#define HAVE__STRREV 1
+#define HAVE__STRUPR 1
+#define HAVE__STRLWR 1
+/* #undef HAVE_INDEX */
+/* #undef HAVE_RINDEX */
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_ITOA 1
+#define HAVE__LTOA 1
+/* #undef HAVE__UITOA */
+#define HAVE__ULTOA 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+#define HAVE__I64TOA 1
+#define HAVE__UI64TOA 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOULL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE__STRICMP 1
+#define HAVE_STRCASECMP 1
+#define HAVE__STRNICMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+/* #undef HAVE_ICONV */
+/* #undef HAVE_SIGACTION */
+#define HAVE_SETJMP 1
+#define HAVE_NANOSLEEP 1
+/* #undef HAVE_CLOCK_GETTIME */
+/* #undef HAVE_DLVSYM */
+/* #undef HAVE_GETPAGESIZE */
+/* #undef HAVE_MPROTECT */
+
+#else
+/* We may need some replacement for stdarg.h here */
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* Allow disabling of core subsystems */
+/* #undef SDL_AUDIO_DISABLED */
+/* #undef SDL_CDROM_DISABLED */
+/* #undef SDL_CPUINFO_DISABLED */
+/* #undef SDL_EVENTS_DISABLED */
+/* #undef SDL_FILE_DISABLED */
+/* #undef SDL_JOYSTICK_DISABLED */
+/* #undef SDL_HAPTIC_DISABLED */
+/* #undef SDL_LOADSO_DISABLED */
+/* #undef SDL_THREADS_DISABLED */
+/* #undef SDL_TIMERS_DISABLED */
+/* #undef SDL_VIDEO_DISABLED */
+
+/* Enable various audio drivers */
+/* #undef SDL_AUDIO_DRIVER_ALSA */
+/* #undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ARTS */
+/* #undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_BAUDIO */
+/* #undef SDL_AUDIO_DRIVER_BSD */
+/* #undef SDL_AUDIO_DRIVER_COREAUDIO */
+/* #undef SDL_AUDIO_DRIVER_DART */
+/* #undef SDL_AUDIO_DRIVER_DC */
+#define SDL_AUDIO_DRIVER_DISK 1
+#define SDL_AUDIO_DRIVER_DUMMY 1
+/* #undef SDL_AUDIO_DRIVER_DMEDIA */
+#define SDL_AUDIO_DRIVER_DSOUND 1
+/* #undef SDL_AUDIO_DRIVER_PULSE */
+/* #undef SDL_AUDIO_DRIVER_PULSE_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_ESD */
+/* #undef SDL_AUDIO_DRIVER_ESD_DYNAMIC */
+/* #undef SDL_AUDIO_DRIVER_MINT */
+/* #undef SDL_AUDIO_DRIVER_MMEAUDIO */
+/* #undef SDL_AUDIO_DRIVER_NAS */
+/* #undef SDL_AUDIO_DRIVER_OSS */
+/* #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H */
+/* #undef SDL_AUDIO_DRIVER_PAUD */
+/* #undef SDL_AUDIO_DRIVER_QNXNTO */
+/* #undef SDL_AUDIO_DRIVER_SNDMGR */
+/* #undef SDL_AUDIO_DRIVER_SUNAUDIO */
+#define SDL_AUDIO_DRIVER_WAVEOUT 1
+
+/* Enable various cdrom drivers */
+/* #undef SDL_CDROM_AIX */
+/* #undef SDL_CDROM_BEOS */
+/* #undef SDL_CDROM_BSDI */
+/* #undef SDL_CDROM_DC */
+/* #undef SDL_CDROM_DUMMY */
+/* #undef SDL_CDROM_FREEBSD */
+/* #undef SDL_CDROM_LINUX */
+/* #undef SDL_CDROM_MACOS */
+/* #undef SDL_CDROM_MACOSX */
+/* #undef SDL_CDROM_MINT */
+/* #undef SDL_CDROM_OPENBSD */
+/* #undef SDL_CDROM_OS2 */
+/* #undef SDL_CDROM_OSF */
+/* #undef SDL_CDROM_QNX */
+#define SDL_CDROM_WIN32 1
+
+/* Enable various input drivers */
+/* #undef SDL_INPUT_LINUXEV */
+/* #undef SDL_INPUT_TSLIB */
+/* #undef SDL_JOYSTICK_BEOS */
+/* #undef SDL_JOYSTICK_DC */
+/* #undef SDL_JOYSTICK_DUMMY */
+/* #undef SDL_JOYSTICK_IOKIT */
+/* #undef SDL_JOYSTICK_LINUX */
+/* #undef SDL_JOYSTICK_MACOS */
+/* #undef SDL_JOYSTICK_MINT */
+/* #undef SDL_JOYSTICK_OS2 */
+/* #undef SDL_JOYSTICK_RISCOS */
+#define SDL_JOYSTICK_WINMM 1
+#define SDL_JOYSTICK_DINPUT 1
+#define SDL_HAPTIC_DINPUT 1
+/* #undef SDL_JOYSTICK_USBHID */
+/* #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H */
+/* #undef SDL_HAPTIC_DUMMY */
+/* #undef SDL_HAPTIC_LINUX */
+/* #undef SDL_HAPTIC_IOKIT */
+/* #undef SDL_HAPTIC_DINPUT */
+
+/* Enable various shared object loading systems */
+/* #undef SDL_LOADSO_BEOS */
+/* #undef SDL_LOADSO_DLCOMPAT */
+/* #undef SDL_LOADSO_DLOPEN */
+/* #undef SDL_LOADSO_DUMMY */
+/* #undef SDL_LOADSO_LDG */
+/* #undef SDL_LOADSO_MACOS */
+/* #undef SDL_LOADSO_OS2 */
+#define SDL_LOADSO_WIN32 1
+
+/* Enable various threading systems */
+/* #undef SDL_THREAD_BEOS */
+/* #undef SDL_THREAD_DC */
+/* #undef SDL_THREAD_OS2 */
+/* #undef SDL_THREAD_PTH */
+/* #undef SDL_THREAD_PTHREAD */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX */
+/* #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP */
+/* #undef SDL_THREAD_SPROC */
+#define SDL_THREAD_WIN32 1
+
+/* Enable various timer systems */
+/* #undef SDL_TIMER_BEOS */
+/* #undef SDL_TIMER_DC */
+/* #undef SDL_TIMER_DUMMY */
+/* #undef SDL_TIMER_MACOS */
+/* #undef SDL_TIMER_MINT */
+/* #undef SDL_TIMER_OS2 */
+/* #undef SDL_TIMER_RISCOS */
+/* #undef SDL_TIMER_UNIX */
+#define SDL_TIMER_WIN32 1
+/* #undef SDL_TIMER_WINCE */
+
+/* Enable various video drivers */
+/* #undef SDL_VIDEO_DRIVER_AALIB */
+/* #undef SDL_VIDEO_DRIVER_BWINDOW */
+/* #undef SDL_VIDEO_DRIVER_DC */
+#define SDL_VIDEO_DRIVER_DDRAW 1
+/* #undef SDL_VIDEO_DRIVER_DGA */
+/* #undef SDL_VIDEO_DRIVER_DIRECTFB */
+/* #undef SDL_VIDEO_DRIVER_DRAWSPROCKET */
+#define SDL_VIDEO_DRIVER_DUMMY 1
+/* #undef SDL_VIDEO_DRIVER_FBCON */
+/* #undef SDL_VIDEO_DRIVER_GAPI */
+/* #undef SDL_VIDEO_DRIVER_GEM */
+/* #undef SDL_VIDEO_DRIVER_GGI */
+/* #undef SDL_VIDEO_DRIVER_IPOD */
+/* #undef SDL_VIDEO_DRIVER_NANOX */
+/* #undef SDL_VIDEO_DRIVER_OS2FS */
+/* #undef SDL_VIDEO_DRIVER_PHOTON */
+/* #undef SDL_VIDEO_DRIVER_PICOGUI */
+/* #undef SDL_VIDEO_DRIVER_PS2GS */
+/* #undef SDL_VIDEO_DRIVER_QTOPIA */
+/* #undef SDL_VIDEO_DRIVER_QUARTZ */
+/* #undef SDL_VIDEO_DRIVER_RISCOS */
+/* #undef SDL_VIDEO_DRIVER_SVGALIB */
+/* #undef SDL_VIDEO_DRIVER_TOOLBOX */
+/* #undef SDL_VIDEO_DRIVER_VGL */
+#define SDL_VIDEO_DRIVER_WINDIB 1
+/* #undef SDL_VIDEO_DRIVER_WSCONS */
+/* #undef SDL_VIDEO_DRIVER_X11 */
+/* #undef SDL_VIDEO_DRIVER_X11_DGAMOUSE */
+/* #undef SDL_VIDEO_DRIVER_X11_DPMS */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRENDER */
+/* #undef SDL_VIDEO_DRIVER_X11_VIDMODE */
+/* #undef SDL_VIDEO_DRIVER_X11_XINERAMA */
+/* #undef SDL_VIDEO_DRIVER_X11_XME */
+/* #undef SDL_VIDEO_DRIVER_X11_XRANDR */
+/* #undef SDL_VIDEO_DRIVER_X11_XV */
+/* #undef SDL_VIDEO_DRIVER_XBIOS */
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL 1
+/* #undef SDL_VIDEO_OPENGL_GLX */
+#define SDL_VIDEO_OPENGL_WGL 1
+/* #undef SDL_VIDEO_OPENGL_OSMESA */
+/* #undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC */
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+#define SDL_HERMES_BLITTERS 1
+/* #undef SDL_ALTIVEC_BLITTERS */
+
+#endif /* _SDL_config_h */
diff -ruN SDL-1.2.13/include/SDL_config.h.in SDL-1.2.13_OOx64/include/SDL_config.h.in
--- SDL-1.2.13/include/SDL_config.h.in	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config.h.in	2017-12-20 14:55:27 +0000
@@ -149,6 +149,7 @@
 #undef SDL_CPUINFO_DISABLED
 #undef SDL_EVENTS_DISABLED
 #undef SDL_FILE_DISABLED
+#undef SDL_HAPTIC_DISABLED
 #undef SDL_JOYSTICK_DISABLED
 #undef SDL_LOADSO_DISABLED
 #undef SDL_THREADS_DISABLED
@@ -216,6 +217,10 @@
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
+#undef SDL_HAPTIC_DUMMY
+#undef SDL_HAPTIC_LINUX
+#undef SDL_HAPTIC_IOKIT
+#undef SDL_HAPTIC_DINPUT
 
 /* Enable various shared object loading systems */
 #undef SDL_LOADSO_BEOS
diff -ruN SDL-1.2.13/include/SDL_config.h.in.bak SDL-1.2.13_OOx64/include/SDL_config.h.in.bak
--- SDL-1.2.13/include/SDL_config.h.in.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config.h.in.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,306 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_h
+#define _SDL_config_h
+
+/* This is a set of defines to configure the SDL features */
+
+/* General platform specific identifiers */
+#include "SDL_platform.h"
+
+/* Make sure that this isn't included by Visual C++ */
+#ifdef _MSC_VER
+#error You should copy include/SDL_config.h.default to include/SDL_config.h
+#endif
+
+/* C language features */
+#undef const
+#undef inline
+#undef volatile
+
+/* C datatypes */
+#undef size_t
+#undef int8_t
+#undef uint8_t
+#undef int16_t
+#undef uint16_t
+#undef int32_t
+#undef uint32_t
+#undef int64_t
+#undef uint64_t
+#undef uintptr_t
+#undef SDL_HAS_64BIT_TYPE
+
+/* Endianness */
+#undef SDL_BYTEORDER
+
+/* Comment this if you want to build without any C library requirements */
+#undef HAVE_LIBC
+#if HAVE_LIBC
+
+/* Useful headers */
+#undef HAVE_ALLOCA_H
+#undef HAVE_SYS_TYPES_H
+#undef HAVE_STDIO_H
+#undef STDC_HEADERS
+#undef HAVE_STDLIB_H
+#undef HAVE_STDARG_H
+#undef HAVE_MALLOC_H
+#undef HAVE_MEMORY_H
+#undef HAVE_STRING_H
+#undef HAVE_STRINGS_H
+#undef HAVE_INTTYPES_H
+#undef HAVE_STDINT_H
+#undef HAVE_CTYPE_H
+#undef HAVE_MATH_H
+#undef HAVE_ICONV_H
+#undef HAVE_SIGNAL_H
+#undef HAVE_ALTIVEC_H
+
+/* C library functions */
+#undef HAVE_MALLOC
+#undef HAVE_CALLOC
+#undef HAVE_REALLOC
+#undef HAVE_FREE
+#undef HAVE_ALLOCA
+#ifndef _WIN32 /* Don't use C runtime versions of these on Windows */
+#undef HAVE_GETENV
+#undef HAVE_PUTENV
+#undef HAVE_UNSETENV
+#endif
+#undef HAVE_QSORT
+#undef HAVE_ABS
+#undef HAVE_BCOPY
+#undef HAVE_MEMSET
+#undef HAVE_MEMCPY
+#undef HAVE_MEMMOVE
+#undef HAVE_MEMCMP
+#undef HAVE_STRLEN
+#undef HAVE_STRLCPY
+#undef HAVE_STRLCAT
+#undef HAVE_STRDUP
+#undef HAVE__STRREV
+#undef HAVE__STRUPR
+#undef HAVE__STRLWR
+#undef HAVE_INDEX
+#undef HAVE_RINDEX
+#undef HAVE_STRCHR
+#undef HAVE_STRRCHR
+#undef HAVE_STRSTR
+#undef HAVE_ITOA
+#undef HAVE__LTOA
+#undef HAVE__UITOA
+#undef HAVE__ULTOA
+#undef HAVE_STRTOL
+#undef HAVE_STRTOUL
+#undef HAVE__I64TOA
+#undef HAVE__UI64TOA
+#undef HAVE_STRTOLL
+#undef HAVE_STRTOULL
+#undef HAVE_STRTOD
+#undef HAVE_ATOI
+#undef HAVE_ATOF
+#undef HAVE_STRCMP
+#undef HAVE_STRNCMP
+#undef HAVE__STRICMP
+#undef HAVE_STRCASECMP
+#undef HAVE__STRNICMP
+#undef HAVE_STRNCASECMP
+#undef HAVE_SSCANF
+#undef HAVE_SNPRINTF
+#undef HAVE_VSNPRINTF
+#undef HAVE_ICONV
+#undef HAVE_SIGACTION
+#undef HAVE_SETJMP
+#undef HAVE_NANOSLEEP
+#undef HAVE_CLOCK_GETTIME
+#undef HAVE_DLVSYM
+#undef HAVE_GETPAGESIZE
+#undef HAVE_MPROTECT
+
+#else
+/* We may need some replacement for stdarg.h here */
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* Allow disabling of core subsystems */
+#undef SDL_AUDIO_DISABLED
+#undef SDL_CDROM_DISABLED
+#undef SDL_CPUINFO_DISABLED
+#undef SDL_EVENTS_DISABLED
+#undef SDL_FILE_DISABLED
+#undef SDL_JOYSTICK_DISABLED
+#undef SDL_LOADSO_DISABLED
+#undef SDL_THREADS_DISABLED
+#undef SDL_TIMERS_DISABLED
+#undef SDL_VIDEO_DISABLED
+
+/* Enable various audio drivers */
+#undef SDL_AUDIO_DRIVER_ALSA
+#undef SDL_AUDIO_DRIVER_ALSA_DYNAMIC
+#undef SDL_AUDIO_DRIVER_ARTS
+#undef SDL_AUDIO_DRIVER_ARTS_DYNAMIC
+#undef SDL_AUDIO_DRIVER_BAUDIO
+#undef SDL_AUDIO_DRIVER_BSD
+#undef SDL_AUDIO_DRIVER_COREAUDIO
+#undef SDL_AUDIO_DRIVER_DART
+#undef SDL_AUDIO_DRIVER_DC
+#undef SDL_AUDIO_DRIVER_DISK
+#undef SDL_AUDIO_DRIVER_DUMMY
+#undef SDL_AUDIO_DRIVER_DMEDIA
+#undef SDL_AUDIO_DRIVER_DSOUND
+#undef SDL_AUDIO_DRIVER_PULSE
+#undef SDL_AUDIO_DRIVER_PULSE_DYNAMIC
+#undef SDL_AUDIO_DRIVER_ESD
+#undef SDL_AUDIO_DRIVER_ESD_DYNAMIC
+#undef SDL_AUDIO_DRIVER_MINT
+#undef SDL_AUDIO_DRIVER_MMEAUDIO
+#undef SDL_AUDIO_DRIVER_NAS
+#undef SDL_AUDIO_DRIVER_OSS
+#undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H
+#undef SDL_AUDIO_DRIVER_PAUD
+#undef SDL_AUDIO_DRIVER_QNXNTO
+#undef SDL_AUDIO_DRIVER_SNDMGR
+#undef SDL_AUDIO_DRIVER_SUNAUDIO
+#undef SDL_AUDIO_DRIVER_WAVEOUT
+
+/* Enable various cdrom drivers */
+#undef SDL_CDROM_AIX
+#undef SDL_CDROM_BEOS
+#undef SDL_CDROM_BSDI
+#undef SDL_CDROM_DC
+#undef SDL_CDROM_DUMMY
+#undef SDL_CDROM_FREEBSD
+#undef SDL_CDROM_LINUX
+#undef SDL_CDROM_MACOS
+#undef SDL_CDROM_MACOSX
+#undef SDL_CDROM_MINT
+#undef SDL_CDROM_OPENBSD
+#undef SDL_CDROM_OS2
+#undef SDL_CDROM_OSF
+#undef SDL_CDROM_QNX
+#undef SDL_CDROM_WIN32
+
+/* Enable various input drivers */
+#undef SDL_INPUT_LINUXEV
+#undef SDL_INPUT_TSLIB
+#undef SDL_JOYSTICK_BEOS
+#undef SDL_JOYSTICK_DC
+#undef SDL_JOYSTICK_DUMMY
+#undef SDL_JOYSTICK_IOKIT
+#undef SDL_JOYSTICK_LINUX
+#undef SDL_JOYSTICK_MACOS
+#undef SDL_JOYSTICK_MINT
+#undef SDL_JOYSTICK_OS2
+#undef SDL_JOYSTICK_RISCOS
+#undef SDL_JOYSTICK_WINMM
+#undef SDL_JOYSTICK_USBHID
+#undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
+
+/* Enable various shared object loading systems */
+#undef SDL_LOADSO_BEOS
+#undef SDL_LOADSO_DLCOMPAT
+#undef SDL_LOADSO_DLOPEN
+#undef SDL_LOADSO_DUMMY
+#undef SDL_LOADSO_LDG
+#undef SDL_LOADSO_MACOS
+#undef SDL_LOADSO_OS2
+#undef SDL_LOADSO_WIN32
+
+/* Enable various threading systems */
+#undef SDL_THREAD_BEOS
+#undef SDL_THREAD_DC
+#undef SDL_THREAD_OS2
+#undef SDL_THREAD_PTH
+#undef SDL_THREAD_PTHREAD
+#undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
+#undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
+#undef SDL_THREAD_SPROC
+#undef SDL_THREAD_WIN32
+
+/* Enable various timer systems */
+#undef SDL_TIMER_BEOS
+#undef SDL_TIMER_DC
+#undef SDL_TIMER_DUMMY
+#undef SDL_TIMER_MACOS
+#undef SDL_TIMER_MINT
+#undef SDL_TIMER_OS2
+#undef SDL_TIMER_RISCOS
+#undef SDL_TIMER_UNIX
+#undef SDL_TIMER_WIN32
+#undef SDL_TIMER_WINCE
+
+/* Enable various video drivers */
+#undef SDL_VIDEO_DRIVER_AALIB
+#undef SDL_VIDEO_DRIVER_BWINDOW
+#undef SDL_VIDEO_DRIVER_DC
+#undef SDL_VIDEO_DRIVER_DDRAW
+#undef SDL_VIDEO_DRIVER_DGA
+#undef SDL_VIDEO_DRIVER_DIRECTFB
+#undef SDL_VIDEO_DRIVER_DRAWSPROCKET
+#undef SDL_VIDEO_DRIVER_DUMMY
+#undef SDL_VIDEO_DRIVER_FBCON
+#undef SDL_VIDEO_DRIVER_GAPI
+#undef SDL_VIDEO_DRIVER_GEM
+#undef SDL_VIDEO_DRIVER_GGI
+#undef SDL_VIDEO_DRIVER_IPOD
+#undef SDL_VIDEO_DRIVER_NANOX
+#undef SDL_VIDEO_DRIVER_OS2FS
+#undef SDL_VIDEO_DRIVER_PHOTON
+#undef SDL_VIDEO_DRIVER_PICOGUI
+#undef SDL_VIDEO_DRIVER_PS2GS
+#undef SDL_VIDEO_DRIVER_QTOPIA
+#undef SDL_VIDEO_DRIVER_QUARTZ
+#undef SDL_VIDEO_DRIVER_RISCOS
+#undef SDL_VIDEO_DRIVER_SVGALIB
+#undef SDL_VIDEO_DRIVER_TOOLBOX
+#undef SDL_VIDEO_DRIVER_VGL
+#undef SDL_VIDEO_DRIVER_WINDIB
+#undef SDL_VIDEO_DRIVER_WSCONS
+#undef SDL_VIDEO_DRIVER_X11
+#undef SDL_VIDEO_DRIVER_X11_DGAMOUSE
+#undef SDL_VIDEO_DRIVER_X11_DPMS
+#undef SDL_VIDEO_DRIVER_X11_DYNAMIC
+#undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT
+#undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR
+#undef SDL_VIDEO_DRIVER_X11_DYNAMIC_XRENDER
+#undef SDL_VIDEO_DRIVER_X11_VIDMODE
+#undef SDL_VIDEO_DRIVER_X11_XINERAMA
+#undef SDL_VIDEO_DRIVER_X11_XME
+#undef SDL_VIDEO_DRIVER_X11_XRANDR
+#undef SDL_VIDEO_DRIVER_X11_XV
+#undef SDL_VIDEO_DRIVER_XBIOS
+
+/* Enable OpenGL support */
+#undef SDL_VIDEO_OPENGL
+#undef SDL_VIDEO_OPENGL_GLX
+#undef SDL_VIDEO_OPENGL_WGL
+#undef SDL_VIDEO_OPENGL_OSMESA
+#undef SDL_VIDEO_OPENGL_OSMESA_DYNAMIC
+
+/* Enable assembly routines */
+#undef SDL_ASSEMBLY_ROUTINES
+#undef SDL_HERMES_BLITTERS
+#undef SDL_ALTIVEC_BLITTERS
+
+#endif /* _SDL_config_h */
diff -ruN SDL-1.2.13/include/SDL_config_dreamcast.h SDL-1.2.13_OOx64/include/SDL_config_dreamcast.h
--- SDL-1.2.13/include/SDL_config_dreamcast.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_dreamcast.h	2017-12-20 14:55:56 +0000
@@ -89,6 +89,7 @@
 
 /* Enable various input drivers */
 #define SDL_JOYSTICK_DC	1
+#define SDL_HAPTIC_DUMMY	1
 
 /* Enable various shared object loading systems */
 #define SDL_LOADSO_DUMMY	1
diff -ruN SDL-1.2.13/include/SDL_config_dreamcast.h.bak SDL-1.2.13_OOx64/include/SDL_config_dreamcast.h.bak
--- SDL-1.2.13/include/SDL_config_dreamcast.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_dreamcast.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,106 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_dreamcast_h
+#define _SDL_config_dreamcast_h
+
+#include "SDL_platform.h"
+
+/* This is a set of defines to configure the SDL features */
+
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+typedef signed long long int64_t;
+typedef unsigned long long uint64_t;
+typedef unsigned long uintptr_t;
+#define SDL_HAS_64BIT_TYPE	1
+
+/* Useful headers */
+#define HAVE_SYS_TYPES_H	1
+#define HAVE_STDIO_H	1
+#define STDC_HEADERS	1
+#define HAVE_STRING_H	1
+#define HAVE_CTYPE_H	1
+
+/* C library functions */
+#define HAVE_MALLOC	1
+#define HAVE_CALLOC	1
+#define HAVE_REALLOC	1
+#define HAVE_FREE	1
+#define HAVE_ALLOCA	1
+#define HAVE_GETENV	1
+#define HAVE_PUTENV	1
+#define HAVE_QSORT	1
+#define HAVE_ABS	1
+#define HAVE_BCOPY	1
+#define HAVE_MEMSET	1
+#define HAVE_MEMCPY	1
+#define HAVE_MEMMOVE	1
+#define HAVE_MEMCMP	1
+#define HAVE_STRLEN	1
+#define HAVE_STRDUP	1
+#define HAVE_INDEX	1
+#define HAVE_RINDEX	1
+#define HAVE_STRCHR	1
+#define HAVE_STRRCHR	1
+#define HAVE_STRSTR	1
+#define HAVE_STRTOL	1
+#define HAVE_STRTOD	1
+#define HAVE_ATOI	1
+#define HAVE_ATOF	1
+#define HAVE_STRCMP	1
+#define HAVE_STRNCMP	1
+#define HAVE_STRICMP	1
+#define HAVE_STRCASECMP	1
+#define HAVE_SSCANF	1
+#define HAVE_SNPRINTF	1
+#define HAVE_VSNPRINTF	1
+
+/* Enable various audio drivers */
+#define SDL_AUDIO_DRIVER_DC	1
+#define SDL_AUDIO_DRIVER_DISK	1
+#define SDL_AUDIO_DRIVER_DUMMY	1
+
+/* Enable various cdrom drivers */
+#define SDL_CDROM_DC	1
+
+/* Enable various input drivers */
+#define SDL_JOYSTICK_DC	1
+
+/* Enable various shared object loading systems */
+#define SDL_LOADSO_DUMMY	1
+
+/* Enable various threading systems */
+#define SDL_THREAD_DC	1
+
+/* Enable various timer systems */
+#define SDL_TIMER_DC	1
+
+/* Enable various video drivers */
+#define SDL_VIDEO_DRIVER_DC	1
+#define SDL_VIDEO_DRIVER_DUMMY	1
+
+#endif /* _SDL_config_dreamcast_h */
diff -ruN SDL-1.2.13/include/SDL_config_macosx.h SDL-1.2.13_OOx64/include/SDL_config_macosx.h
--- SDL-1.2.13/include/SDL_config_macosx.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_macosx.h	2017-12-20 14:56:41 +0000
@@ -99,6 +99,7 @@
 
 /* Enable various input drivers */
 #define SDL_JOYSTICK_IOKIT	1
+#define SDL_HAPTIC_IOKIT	1
 
 /* Enable various shared object loading systems */
 #ifdef __ppc__
@@ -125,6 +126,11 @@
 
 /* Enable OpenGL support */
 #define SDL_VIDEO_OPENGL	1
+#define SDL_VIDEO_OPENGL_GLX 1
+#define SDL_VIDEO_RENDER_OGL 1
+
+ /* Disable screensaver */
+ #define SDL_VIDEO_DISABLE_SCREENSAVER	1
 
 /* Enable assembly routines */
 #define SDL_ASSEMBLY_ROUTINES	1
diff -ruN SDL-1.2.13/include/SDL_config_macosx.h.bak SDL-1.2.13_OOx64/include/SDL_config_macosx.h.bak
--- SDL-1.2.13/include/SDL_config_macosx.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_macosx.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,135 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_macosx_h
+#define _SDL_config_macosx_h
+
+#include "SDL_platform.h"
+
+/* This gets us MAC_OS_X_VERSION_MIN_REQUIRED... */
+#include <AvailabilityMacros.h>
+
+/* This is a set of defines to configure the SDL features */
+
+#define SDL_HAS_64BIT_TYPE	1
+
+/* Useful headers */
+/* If we specified an SDK or have a post-PowerPC chip, then alloca.h exists. */
+#if ( (MAC_OS_X_VERSION_MIN_REQUIRED >= 1030) || (!defined(__POWERPC__)) )
+#define HAVE_ALLOCA_H		1
+#endif
+#define HAVE_SYS_TYPES_H	1
+#define HAVE_STDIO_H	1
+#define STDC_HEADERS	1
+#define HAVE_STRING_H	1
+#define HAVE_INTTYPES_H	1
+#define HAVE_STDINT_H	1
+#define HAVE_CTYPE_H	1
+#define HAVE_MATH_H	1
+#define HAVE_SIGNAL_H	1
+
+/* C library functions */
+#define HAVE_MALLOC	1
+#define HAVE_CALLOC	1
+#define HAVE_REALLOC	1
+#define HAVE_FREE	1
+#define HAVE_ALLOCA	1
+#define HAVE_GETENV	1
+#define HAVE_PUTENV	1
+#define HAVE_UNSETENV	1
+#define HAVE_QSORT	1
+#define HAVE_ABS	1
+#define HAVE_BCOPY	1
+#define HAVE_MEMSET	1
+#define HAVE_MEMCPY	1
+#define HAVE_MEMMOVE	1
+#define HAVE_MEMCMP	1
+#define HAVE_STRLEN	1
+#define HAVE_STRLCPY	1
+#define HAVE_STRLCAT	1
+#define HAVE_STRDUP	1
+#define HAVE_STRCHR	1
+#define HAVE_STRRCHR	1
+#define HAVE_STRSTR	1
+#define HAVE_STRTOL	1
+#define HAVE_STRTOUL	1
+#define HAVE_STRTOLL	1
+#define HAVE_STRTOULL	1
+#define HAVE_STRTOD	1
+#define HAVE_ATOI	1
+#define HAVE_ATOF	1
+#define HAVE_STRCMP	1
+#define HAVE_STRNCMP	1
+#define HAVE_STRCASECMP	1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF	1
+#define HAVE_SNPRINTF	1
+#define HAVE_VSNPRINTF	1
+#define HAVE_SIGACTION	1
+#define HAVE_SETJMP	1
+#define HAVE_NANOSLEEP	1
+
+/* Enable various audio drivers */
+#define SDL_AUDIO_DRIVER_COREAUDIO	1
+#define SDL_AUDIO_DRIVER_SNDMGR	1
+#define SDL_AUDIO_DRIVER_DISK	1
+#define SDL_AUDIO_DRIVER_DUMMY	1
+
+/* Enable various cdrom drivers */
+#define SDL_CDROM_MACOSX	1
+
+/* Enable various input drivers */
+#define SDL_JOYSTICK_IOKIT	1
+
+/* Enable various shared object loading systems */
+#ifdef __ppc__
+/* For Mac OS X 10.2 compatibility */
+#define SDL_LOADSO_DLCOMPAT	1
+#else
+#define SDL_LOADSO_DLOPEN	1
+#endif
+
+/* Enable various threading systems */
+#define SDL_THREAD_PTHREAD	1
+#define SDL_THREAD_PTHREAD_RECURSIVE_MUTEX	1
+
+/* Enable various timer systems */
+#define SDL_TIMER_UNIX	1
+
+/* Enable various video drivers */
+#define SDL_VIDEO_DRIVER_DUMMY	1
+#if ((defined TARGET_API_MAC_CARBON) && (TARGET_API_MAC_CARBON))
+#define SDL_VIDEO_DRIVER_TOOLBOX	1
+#else
+#define SDL_VIDEO_DRIVER_QUARTZ	1
+#endif
+
+/* Enable OpenGL support */
+#define SDL_VIDEO_OPENGL	1
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES	1
+#ifdef __ppc__
+#define SDL_ALTIVEC_BLITTERS	1
+#endif
+
+#endif /* _SDL_config_macosx_h */
diff -ruN SDL-1.2.13/include/SDL_config_minimal.h SDL-1.2.13_OOx64/include/SDL_config_minimal.h
--- SDL-1.2.13/include/SDL_config_minimal.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_minimal.h	2017-12-20 14:57:03 +0000
@@ -47,6 +47,9 @@
 /* Enable the stub joystick driver (src/joystick/dummy/\*.c) */
 #define SDL_JOYSTICK_DISABLED	1
 
+/* Enable the stub haptic driver (src/haptic/dummy/\*.c) */
+#define SDL_HAPTIC_DUMMY	1
+
 /* Enable the stub shared object loader (src/loadso/dummy/\*.c) */
 #define SDL_LOADSO_DISABLED	1
 
diff -ruN SDL-1.2.13/include/SDL_config_minimal.h.bak SDL-1.2.13_OOx64/include/SDL_config_minimal.h.bak
--- SDL-1.2.13/include/SDL_config_minimal.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_minimal.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,62 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_minimal_h
+#define _SDL_config_minimal_h
+
+#include "SDL_platform.h"
+
+/* This is the minimal configuration that can be used to build SDL */
+
+#include <stdarg.h>
+
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+typedef unsigned int size_t;
+typedef unsigned long uintptr_t;
+
+/* Enable the dummy audio driver (src/audio/dummy/\*.c) */
+#define SDL_AUDIO_DRIVER_DUMMY	1
+
+/* Enable the stub cdrom driver (src/cdrom/dummy/\*.c) */
+#define SDL_CDROM_DISABLED	1
+
+/* Enable the stub joystick driver (src/joystick/dummy/\*.c) */
+#define SDL_JOYSTICK_DISABLED	1
+
+/* Enable the stub shared object loader (src/loadso/dummy/\*.c) */
+#define SDL_LOADSO_DISABLED	1
+
+/* Enable the stub thread support (src/thread/generic/\*.c) */
+#define SDL_THREADS_DISABLED	1
+
+/* Enable the stub timer support (src/timer/dummy/\*.c) */
+#define SDL_TIMERS_DISABLED	1
+
+/* Enable the dummy video driver (src/video/dummy/\*.c) */
+#define SDL_VIDEO_DRIVER_DUMMY	1
+
+#endif /* _SDL_config_minimal_h */
diff -ruN SDL-1.2.13/include/SDL_config_os2.h SDL-1.2.13_OOx64/include/SDL_config_os2.h
--- SDL-1.2.13/include/SDL_config_os2.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_os2.h	2017-12-20 14:57:16 +0000
@@ -118,6 +118,7 @@
 
 /* Enable various input drivers */
 #define SDL_JOYSTICK_OS2	1
+#define SDL_HAPTIC_DUMMY	1
 
 /* Enable various shared object loading systems */
 #define SDL_LOADSO_OS2	1
diff -ruN SDL-1.2.13/include/SDL_config_os2.h.bak SDL-1.2.13_OOx64/include/SDL_config_os2.h.bak
--- SDL-1.2.13/include/SDL_config_os2.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_os2.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,141 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_os2_h
+#define _SDL_config_os2_h
+
+#include "SDL_platform.h"
+
+/* This is a set of defines to configure the SDL features */
+
+typedef signed char         int8_t;
+typedef unsigned char       uint8_t;
+typedef signed short        int16_t;
+typedef unsigned short      uint16_t;
+typedef signed int          int32_t;
+typedef unsigned int        uint32_t;
+typedef unsigned int        size_t;
+typedef unsigned long       uintptr_t;
+typedef signed long long    int64_t;
+typedef unsigned long long  uint64_t;
+
+#define SDL_HAS_64BIT_TYPE	1
+
+/* Use Watcom's LIBC */
+#define HAVE_LIBC 1
+
+/* Useful headers */
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#define HAVE_SIGNAL_H 1
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_ALLOCA 1
+#define HAVE_GETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_UNSETENV 1
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_BCOPY 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY 1
+#define HAVE_STRLCAT 1
+#define HAVE_STRDUP 1
+#define HAVE__STRREV 1
+#define HAVE__STRUPR 1
+#define HAVE__STRLWR 1
+#define HAVE_INDEX 1
+#define HAVE_RINDEX 1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_ITOA 1
+#define HAVE__LTOA 1
+#define HAVE__UITOA 1
+#define HAVE__ULTOA 1
+#define HAVE_STRTOL 1
+#define HAVE__I64TOA 1
+#define HAVE__UI64TOA 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE_STRICMP 1
+#define HAVE_STRCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+#define HAVE_SETJMP 1
+#define HAVE_CLOCK_GETTIME 1
+
+/* Enable various audio drivers */
+#define SDL_AUDIO_DRIVER_DART	1
+#define SDL_AUDIO_DRIVER_DISK	1
+#define SDL_AUDIO_DRIVER_DUMMY	1
+
+/* Enable various cdrom drivers */
+#define SDL_CDROM_OS2	1
+
+/* Enable various input drivers */
+#define SDL_JOYSTICK_OS2	1
+
+/* Enable various shared object loading systems */
+#define SDL_LOADSO_OS2	1
+
+/* Enable various threading systems */
+#define SDL_THREAD_OS2	1
+
+/* Enable various timer systems */
+#define SDL_TIMER_OS2	1
+
+/* Enable various video drivers */
+#define SDL_VIDEO_DRIVER_DUMMY	1
+#define SDL_VIDEO_DRIVER_OS2FS	1
+
+/* Enable OpenGL support */
+/* Nothing here yet for OS/2... :( */
+
+/* Enable assembly routines where available */
+#define SDL_ASSEMBLY_ROUTINES	1
+
+#endif /* _SDL_config_os2_h */
diff -ruN SDL-1.2.13/include/SDL_config_win32.h SDL-1.2.13_OOx64/include/SDL_config_win32.h
--- SDL-1.2.13/include/SDL_config_win32.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_win32.h	2017-12-19 13:45:52 +0000
@@ -139,8 +139,10 @@
 /* Enable various input drivers */
 #ifdef _WIN32_WCE
 #define SDL_JOYSTICK_DISABLED   1
+#define SDL_HAPTIC_DUMMY	1
 #else
 #define SDL_JOYSTICK_WINMM	1
+#define SDL_HAPTIC_DINPUT	1
 #endif
 
 /* Enable various shared object loading systems */
diff -ruN SDL-1.2.13/include/SDL_config_win32.h.bak SDL-1.2.13_OOx64/include/SDL_config_win32.h.bak
--- SDL-1.2.13/include/SDL_config_win32.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_config_win32.h.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,180 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#ifndef _SDL_config_win32_h
+#define _SDL_config_win32_h
+
+#include "SDL_platform.h"
+
+/* This is a set of defines to configure the SDL features */
+
+#if defined(__GNUC__) || defined(__DMC__)
+#define HAVE_STDINT_H	1
+#elif defined(_MSC_VER)
+typedef signed __int8		int8_t;
+typedef unsigned __int8		uint8_t;
+typedef signed __int16		int16_t;
+typedef unsigned __int16	uint16_t;
+typedef signed __int32		int32_t;
+typedef unsigned __int32	uint32_t;
+typedef signed __int64		int64_t;
+typedef unsigned __int64	uint64_t;
+#ifndef _UINTPTR_T_DEFINED
+#ifdef  _WIN64
+typedef unsigned __int64    uintptr_t;
+#else
+typedef unsigned int   uintptr_t;
+#endif
+#define _UINTPTR_T_DEFINED
+#endif
+/* Older Visual C++ headers don't have the Win64-compatible typedefs... */
+#if ((_MSC_VER <= 1200) && (!defined(DWORD_PTR)))
+#define DWORD_PTR DWORD
+#endif
+#if ((_MSC_VER <= 1200) && (!defined(LONG_PTR)))
+#define LONG_PTR LONG
+#endif
+#else	/* !__GNUC__ && !_MSC_VER */
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+typedef signed long long int64_t;
+typedef unsigned long long uint64_t;
+#ifndef _SIZE_T_DEFINED_
+#define _SIZE_T_DEFINED_
+typedef unsigned int size_t;
+#endif
+typedef unsigned int uintptr_t;
+#endif /* __GNUC__ || _MSC_VER */
+#define SDL_HAS_64BIT_TYPE	1
+
+/* Enabled for SDL 1.2 (binary compatibility) */
+#define HAVE_LIBC	1
+#ifdef HAVE_LIBC
+/* Useful headers */
+#define HAVE_STDIO_H 1
+#define STDC_HEADERS 1
+#define HAVE_STRING_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_MATH_H 1
+#ifndef _WIN32_WCE
+#define HAVE_SIGNAL_H 1
+#endif
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC 1
+#define HAVE_FREE 1
+#define HAVE_ALLOCA 1
+#define HAVE_QSORT 1
+#define HAVE_ABS 1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMCMP 1
+#define HAVE_STRLEN 1
+#define HAVE__STRREV 1
+#define HAVE__STRUPR 1
+#define HAVE__STRLWR 1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_ITOA 1
+#define HAVE__LTOA 1
+#define HAVE__ULTOA 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL 1
+#define HAVE_STRTOLL 1
+#define HAVE_STRTOD 1
+#define HAVE_ATOI 1
+#define HAVE_ATOF 1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP 1
+#define HAVE__STRICMP 1
+#define HAVE__STRNICMP 1
+#define HAVE_SSCANF 1
+#else
+#define HAVE_STDARG_H	1
+#define HAVE_STDDEF_H	1
+#endif
+
+/* Enable various audio drivers */
+#ifndef _WIN32_WCE
+#define SDL_AUDIO_DRIVER_DSOUND	1
+#endif
+#define SDL_AUDIO_DRIVER_WAVEOUT	1
+#define SDL_AUDIO_DRIVER_DISK	1
+#define SDL_AUDIO_DRIVER_DUMMY	1
+
+/* Enable various cdrom drivers */
+#ifdef _WIN32_WCE
+#define SDL_CDROM_DISABLED      1
+#else
+#define SDL_CDROM_WIN32		1
+#endif
+
+/* Enable various input drivers */
+#ifdef _WIN32_WCE
+#define SDL_JOYSTICK_DISABLED   1
+#else
+#define SDL_JOYSTICK_WINMM	1
+#endif
+
+/* Enable various shared object loading systems */
+#define SDL_LOADSO_WIN32	1
+
+/* Enable various threading systems */
+#define SDL_THREAD_WIN32	1
+
+/* Enable various timer systems */
+#ifdef _WIN32_WCE
+#define SDL_TIMER_WINCE	1
+#else
+#define SDL_TIMER_WIN32	1
+#endif
+
+/* Enable various video drivers */
+#ifdef _WIN32_WCE
+#define SDL_VIDEO_DRIVER_GAPI	1
+#endif
+#ifndef _WIN32_WCE
+#define SDL_VIDEO_DRIVER_DDRAW	1
+#endif
+#define SDL_VIDEO_DRIVER_DUMMY	1
+#define SDL_VIDEO_DRIVER_WINDIB	1
+
+/* Enable OpenGL support */
+#ifndef _WIN32_WCE
+#define SDL_VIDEO_OPENGL	1
+#define SDL_VIDEO_OPENGL_WGL	1
+#endif
+
+/* Enable assembly routines (Win64 doesn't have inline asm) */
+#ifndef _WIN64
+#define SDL_ASSEMBLY_ROUTINES	1
+#endif
+
+#endif /* _SDL_config_win32_h */
diff -ruN SDL-1.2.13/include/SDL_events.h SDL-1.2.13_OOx64/include/SDL_events.h
--- SDL-1.2.13/include/SDL_events.h	2007-12-31 04:48:36 +0000
+++ SDL-1.2.13_OOx64/include/SDL_events.h	2018-04-23 16:20:33 +0000
@@ -140,6 +140,7 @@
 	Uint8 button;	/* The mouse button index */
 	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
 	Uint16 x, y;	/* The X/Y coordinates of the mouse at press time */
+	short wheelDelta; /* The delta of the mousewheel movement */
 } SDL_MouseButtonEvent;
 
 /* Joystick axis motion event structure */
diff -ruN SDL-1.2.13/include/SDL_haptic.h SDL-1.2.13_OOx64/include/SDL_haptic.h
--- SDL-1.2.13/include/SDL_haptic.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/SDL_haptic.h	2017-12-19 13:54:51 +0000
@@ -0,0 +1,1136 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+/**
+ * \file SDL_haptic.h
+ *
+ * \brief The SDL Haptic subsystem allows you to control haptic (force feedback)
+ *  devices.
+ *
+ * The basic usage is as follows:
+ *   - Initialize the Subsystem (SDL_INIT_HAPTIC).
+ *   - Open a Haptic Device.
+ *     - SDL_HapticOpen(...) to open from index.
+ *     - SDL_HapticOpenFromJoystick(...) to open from an existing joystick.
+ *   - Create an effect (SDL_HapticEffect).
+ *   - Upload the effect with SDL_HapticNewEffect(...).
+ *   - Run the effect with SDL_HapticRunEffect(...).
+ *   - (optional) Free the effect with SDL_HapticDestroyEffect(...).
+ *   - Close the haptic device with SDL_HapticClose(...).
+ *
+ * Example:
+ *
+ * \code
+ * int test_haptic( SDL_Joystick * joystick ) {
+ *    SDL_Haptic *haptic;
+ *    SDL_HapticEffect effect;
+ *    int effect_id;
+ *
+ *    // Open the device
+ *    haptic = SDL_HapticOpenFromJoystick( joystick );
+ *    if (haptic == NULL) return -1; // Most likely joystick isn't haptic
+ *
+ *    // See if it can do sine waves
+ *    if ((SDL_HapticQuery(haptic) & SDL_HAPTIC_SINE)==0) {
+ *       SDL_HapticClose(haptic); // No sine effect
+ *       return -1;
+ *    }
+ *
+ *    // Create the effect
+ *    memset( &effect, 0, sizeof(SDL_HapticEffect) ); // 0 is safe default
+ *    effect.type = SDL_HAPTIC_SINE;
+ *    effect.periodic.direction.type = SDL_HAPTIC_POLAR; // Polar coordinates
+ *    effect.periodic.direction.dir[0] = 18000; // Force comes from south
+ *    effect.periodic.period = 1000; // 1000 ms
+ *    effect.periodic.magnitude = 20000; // 20000/32767 strength
+ *    effect.periodic.length = 5000; // 5 seconds long
+ *    effect.periodic.attack_length = 1000; // Takes 1 second to get max strength
+ *    effect.periodic.fade_length = 1000; // Takes 1 second to fade away
+ *
+ *    // Upload the effect
+ *    effect_id = SDL_HapticNewEffect( haptic, &effect );
+ *
+ *    // Test the effect
+ *    SDL_HapticRunEffect( haptic, effect_id, 1 );
+ *    SDL_Delay( 5000); // Wait for the effect to finish
+ *
+ *    // We destroy the effect, although closing the device also does this
+ *    SDL_HapticDestroyEffect( haptic, effect_id );
+ *
+ *    // Close the device
+ *    SDL_HapticClose(haptic);
+ *
+ *    return 0; // Success
+ * }
+ * \endcode
+ *
+ * \author Edgar Simo Serra
+ */
+
+#ifndef _SDL_haptic_h
+#define _SDL_haptic_h
+
+#include "SDL_stdinc.h"
+#include "SDL_error.h"
+#include "SDL_joystick.h"
+
+#include "begin_code.h"
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+/* *INDENT-OFF* */
+extern "C" {
+   /* *INDENT-ON* */                                                         
+#endif /* __cplusplus */
+
+/**
+ * \typedef SDL_Haptic
+ *
+ * \brief The haptic structure used to identify an SDL haptic.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticOpenFromJoystick
+ * \sa SDL_HapticClose
+ */
+struct _SDL_Haptic;                                                     
+typedef struct _SDL_Haptic SDL_Haptic;
+
+
+/*
+ * Different haptic features a device can have.
+ */
+/**
+ * \def SDL_HAPTIC_CONSTANT
+ *
+ * \brief Constant haptic effect.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_CONSTANT   (1<<0) /* Constant effect supported */
+/**
+ * \def SDL_HAPTIC_SINE
+ *
+ * \brief Periodic haptic effect that simulates sine waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SINE       (1<<1) /* Sine wave effect supported */
+/**
+ * \def SDL_HAPTIC_SQUARE
+ *
+ * \brief Periodic haptic effect that simulates square waves.
+ * 
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SQUARE     (1<<2) /* Square wave effect supported */
+/**
+ * \def SDL_HAPTIC_TRIANGLE
+ *
+ * \brief Periodic haptic effect that simulates triangular waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_TRIANGLE   (1<<3) /* Triangle wave effect supported */
+/**
+ * \def SDL_HAPTIC_SAWTOOTHUP
+ *
+ * \brief Periodic haptic effect that simulates saw tooth up waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SAWTOOTHUP (1<<4) /* Sawtoothup wave effect supported */
+/**
+ * \def SDL_HAPTIC_SAWTOOTHDOWN
+ *
+ * \brief Periodic haptic effect that simulates saw tooth down waves.
+ *
+ * \sa SDL_HapticPeriodic
+ */
+#define SDL_HAPTIC_SAWTOOTHDOWN (1<<5) /* Sawtoothdown wave effect supported */
+/**
+ * \def SDL_HAPTIC_RAMP
+ *
+ * \brief Ramp haptic effect.
+ *
+ * \sa SDL_HapticRamp
+ */
+#define SDL_HAPTIC_RAMP       (1<<6) /* Ramp effect supported */
+/**
+ * \def SDL_HAPTIC_SPRING
+ *
+ * \brief Condition haptic effect that simulates a spring.  Effect is based on the
+ * axes position.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_SPRING     (1<<7) /* Spring effect supported - uses axes position */
+/**
+ * \def SDL_HAPTIC_DAMPER
+ *
+ * \brief Condition haptic effect that simulates dampening.  Effect is based on the
+ * axes velocity.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_DAMPER     (1<<8) /* Damper effect supported - uses axes velocity */
+/**
+ * \def SDL_HAPTIC_INERTIA
+ *
+ * \brief Condition haptic effect that simulates inertia.  Effect is based on the axes
+ * acceleration.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_INERTIA    (1<<9) /* Inertia effect supported - uses axes acceleration */
+/**
+ * \def SDL_HAPTIC_FRICTION
+ *
+ * \brief Condition haptic effect that simulates friction.  Effect is based on the axes
+ * movement.
+ *
+ * \sa SDL_HapticCondition
+ */
+#define SDL_HAPTIC_FRICTION   (1<<10) /* Friction effect supported - uses axes movement */
+/**
+ * \def SDL_HAPTIC_CUSTOM
+ *
+ * \brief User defined custom haptic effect.
+ */
+#define SDL_HAPTIC_CUSTOM     (1<<11) /* Custom effect is supported */
+/* These last two are features the device has, not effects */
+/**
+ * \def SDL_HAPTIC_GAIN
+ *
+ * \brief Device supports setting the global gain.
+ *
+ * \sa SDL_HapticSetGain
+ */
+#define SDL_HAPTIC_GAIN       (1<<12) /* Device can set global gain */
+/**
+ * \def SDL_HAPTIC_AUTOCENTER
+ *
+ * \brief Device supports setting autocenter.
+ *
+ * \sa SDL_HapticSetAutocenter
+ */
+#define SDL_HAPTIC_AUTOCENTER (1<<13) /* Device can set autocenter */
+/**
+ * \def SDL_HAPTIC_STATUS
+ *
+ * \brief Device can be queried for effect status.
+ *
+ * \sa SDL_HapticGetEffectStatus
+ */
+#define SDL_HAPTIC_STATUS     (1<<14) /* Device can be queried for effect status */
+/**
+ * \def SDL_HAPTIC_PAUSE
+ *
+ * \brief Device can be paused.
+ *
+ * \sa SDL_HapticPause
+ * \sa SDL_HapticUnpause
+ */
+#define SDL_HAPTIC_PAUSE      (1<<15) /* Device can be paused. */
+
+
+/*
+ * Direction encodings
+ */
+/**
+ * \def SDL_HAPTIC_POLAR
+ *
+ * \brief Uses polar coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_POLAR      0
+/**
+ * \def SDL_HAPTIC_CARTESIAN
+ *
+ * \brief Uses cartesian coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_CARTESIAN  1
+/**
+ * \def SDL_HAPTIC_SPHERICAL
+ *
+ * \brief Uses spherical coordinates for the direction.
+ *
+ * \sa SDL_HapticDirection
+ */
+#define SDL_HAPTIC_SPHERICAL  2
+
+
+/*
+ * Misc defines.
+ */
+/**
+ * \def SDL_HAPTIC_INFINITY
+ *
+ * \brief Used to play a device an infinite number of times.
+ *
+ * \sa SDL_HapticRunEffect
+ */
+#define SDL_HAPTIC_INFINITY   4294967295U
+
+
+/**
+ * \struct SDL_HapticDirection
+ *
+ * \brief Structure that represents a haptic direction.
+ *
+ * Directions can be specified by:
+ *   - SDL_HAPTIC_POLAR : Specified by polar coordinates.
+ *   - SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
+ *   - SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
+ *
+ * Cardinal directions of the haptic device are relative to the positioning
+ *  of the device.  North is considered to be away from the user.
+ *
+ * The following diagram represents the cardinal directions:
+ * \code
+ *              .--.
+ *              |__| .-------.
+ *              |=.| |.-----.|
+ *              |--| ||     ||
+ *              |  | |'-----'|
+ *              |__|~')_____('
+ *                [ COMPUTER ]
+ *
+ *
+ *                  North (0,-1)
+ *                      ^
+ *                      |
+ *                      |
+ * (1,0)  West <----[ HAPTIC ]----> East (-1,0)
+ *                      |
+ *                      |
+ *                      v
+ *                   South (0,1)
+ *
+ *
+ *                   [ USER ]
+ *                     \|||/
+ *                     (o o)
+ *               ---ooO-(_)-Ooo---
+ * \endcode
+ *
+ * If type is SDL_HAPTIC_POLAR, direction is encoded by hundredths of a 
+ *  degree starting north and turning clockwise.  SDL_HAPTIC_POLAR only uses
+ *  the first dir parameter.  The cardinal directions would be:
+ *   - North: 0 (0 degrees)
+ *   - East: 9000 (90 degrees)
+ *   - South: 18000 (180 degrees)
+ *   - West: 27000 (270 degrees)
+ *
+ * If type is SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
+ *  (X axis, Y axis and Z axis (with 3 axes)).  SDL_HAPTIC_CARTESIAN uses
+ *  the first three dir parameters.  The cardinal directions would be:
+ *   - North:  0,-1, 0
+ *   - East:  -1, 0, 0
+ *   - South:  0, 1, 0
+ *   - West:   1, 0, 0
+ *  The Z axis represents the height of the effect if supported, otherwise
+ *  it's unused.  In cartesian encoding (1,2) would be the same as (2,4), you
+ *  can use any multiple you want, only the direction matters.
+ *
+ * If type is SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
+ *  The first two  dir parameters are used.  The dir parameters are as follows
+ *  (all values are in hundredths of degrees):
+ *    1) Degrees from (1, 0) rotated towards (0, 1).
+ *    2) Degrees towards (0, 0, 1) (device needs at least 3 axes).
+ *
+ *
+ * Example of force coming from the south with all encodings (force coming
+ *  from the south means the user will have to pull the stick to counteract):
+ * \code
+ * SDL_HapticDirection direction;
+ *
+ * // Cartesian directions
+ * direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
+ * direction.dir[0] = 0; // X position
+ * direction.dir[1] = 1; // Y position
+ * // Assuming the device has 2 axes, we don't need to specify third parameter.
+ *
+ * // Polar directions
+ * direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
+ * direction.dir[0] = 18000; // Polar only uses first parameter
+ *
+ * // Spherical coordinates
+ * direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
+ * direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
+ * \endcode
+ *
+ * \sa SDL_HAPTIC_POLAR
+ * \sa SDL_HAPTIC_CARTESIAN
+ * \sa SDL_HAPTIC_SPHERICAL
+ * \sa SDL_HapticEffect
+ * \sa SDL_HapticNumAxes
+ */
+typedef struct SDL_HapticDirection {
+   Uint8 type; /**< The type of encoding. */
+   Sint16 dir[3]; /**< The encoded direction. */
+} SDL_HapticDirection;
+
+
+/**
+ * \struct SDL_HapticConstant
+ *
+ * \brief A structure containing a template for a Constant effect.
+ *
+ * The struct is exclusive to the SDL_HAPTIC_CONSTANT effect.
+ *
+ * A constant effect applies a constant force in the specified direction
+ *  to the joystick.
+ *
+ * \sa SDL_HAPTIC_CONSTANT
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticConstant {
+   /* Header */
+   Uint16 type; /**< SDL_HAPTIC_CONSTANT */
+   SDL_HapticDirection direction; /**< Direction of the effect. */
+
+   /* Replay */
+   Uint32 length; /**< Duration of the effect. */
+   Uint16 delay; /**< Delay before starting the effect. */
+
+   /* Trigger */
+   Uint16 button; /**< Button that triggers the effect. */
+   Uint16 interval; /**< How soon it can be triggered again after button. */
+
+   /* Constant */
+   Sint16 level; /**< Strength of the constant effect. */
+
+   /* Envelope */
+   Uint16 attack_length; /**< Duration of the attack. */
+   Uint16 attack_level; /**< Level at the start of the attack. */
+   Uint16 fade_length; /**< Duration of the fade. */
+   Uint16 fade_level; /**< Level at the end of the fade. */
+} SDL_HapticConstant;
+/**
+ * \struct SDL_HapticPeriodic
+ *
+ * \brief A structure containing a template for a Periodic effect.
+ *
+ * The struct handles the following effects:
+ *   - SDL_HAPTIC_SINE
+ *   - SDL_HAPTIC_SQUARE
+ *   - SDL_HAPTIC_TRIANGLE
+ *   - SDL_HAPTIC_SAWTOOTHUP
+ *   - SDL_HAPTIC_SAWTOOTHDOWN
+ *
+ * A periodic effect consists in a wave-shaped effect that repeats itself
+ *  over time.  The type determines the shape of the wave and the parameters
+ *  determine the dimensions of the wave.
+ *
+ * Phase is given by hundredth of a cyle meaning that giving the phase a value
+ *  of 9000 will displace it 25% of it's period.  Here are sample values:
+ *    -     0: No phase displacement.
+ *    -  9000: Displaced 25% of it's period.
+ *    - 18000: Displaced 50% of it's period.
+ *    - 27000: Displaced 75% of it's period.
+ *    - 36000: Displaced 100% of it's period, same as 0, but 0 is preffered.
+ *
+ * Examples:
+ * \code
+ * SDL_HAPTIC_SINE
+ *   __      __      __      __
+ *  /  \    /  \    /  \    /
+ * /    \__/    \__/    \__/
+ *
+ * SDL_HAPTIC_SQUARE
+ *  __    __    __    __    __
+ * |  |  |  |  |  |  |  |  |  |
+ * |  |__|  |__|  |__|  |__|  |
+ *
+ * SDL_HAPTIC_TRIANGLE
+ *   /\    /\    /\    /\    /\
+ *  /  \  /  \  /  \  /  \  /
+ * /    \/    \/    \/    \/
+ *
+ * SDL_HAPTIC_SAWTOOTHUP
+ *   /|  /|  /|  /|  /|  /|  /|
+ *  / | / | / | / | / | / | / |
+ * /  |/  |/  |/  |/  |/  |/  |
+ *
+ * SDL_HAPTIC_SAWTOOTHDOWN
+ * \  |\  |\  |\  |\  |\  |\  |
+ *  \ | \ | \ | \ | \ | \ | \ |
+ *   \|  \|  \|  \|  \|  \|  \|
+ * \endcode
+ *
+ * \sa SDL_HAPTIC_SINE
+ * \sa SDL_HAPTIC_SQUARE
+ * \sa SDL_HAPTIC_TRIANGLE
+ * \sa SDL_HAPTIC_SAWTOOTHUP
+ * \sa SDL_HAPTIC_SAWTOOTHDOWN
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticPeriodic {
+   /* Header */
+   Uint16 type; /**< SDL_HAPTIC_SINE, SDL_HAPTIC_SQUARE,
+                     SDL_HAPTIC_TRIANGLE, SDL_HAPTIC_SAWTOOTHUP or
+                     SDL_HAPTIC_SAWTOOTHDOWN */
+   SDL_HapticDirection direction; /**< Direction of the effect. */
+
+   /* Replay */
+   Uint32 length; /**< Duration of the effect. */
+   Uint16 delay; /**< Delay before starting the effect. */
+
+   /* Trigger */
+   Uint16 button; /**< Button that triggers the effect. */
+   Uint16 interval; /**< How soon it can be triggered again after button. */
+
+   /* Periodic */
+   Uint16 period; /**< Period of the wave. */
+   Sint16 magnitude; /**< Peak value. */
+   Sint16 offset; /**< Mean value of the wave. */
+   Uint16 phase; /**< Horizontal shift given by hundredth of a cycle. */
+
+   /* Envelope */
+   Uint16 attack_length; /**< Duration of the attack. */
+   Uint16 attack_level; /**< Level at the start of the attack. */
+   Uint16 fade_length; /**< Duration of the fade. */
+   Uint16 fade_level; /**< Level at the end of the fade. */
+} SDL_HapticPeriodic;
+/**
+ * \struct SDL_HapticCondition
+ *
+ * \brief A structure containing a template for a Condition effect.
+ *
+ * The struct handles the following effects:
+ *   - SDL_HAPTIC_SPRING: Effect based on axes position.
+ *   - SDL_HAPTIC_DAMPER: Effect based on axes velocity.
+ *   - SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
+ *   - SDL_HAPTIC_FRICTION: Effect based on axes movement.
+ *
+ * Direction is handled by condition internals instead of a direction member.
+ *  The condition effect specific members have three parameters.  The first
+ *  refers to the X axis, the second refers to the Y axis and the third
+ *  refers to the Z axis.  The right terms refer to the positive side of the
+ *  axis and the left terms refer to the negative side of the axis.  Please 
+ *  refer to the SDL_HapticDirection  diagram for which side is positive and
+ *  which is negative.
+ *
+ * \sa SDL_HapticDirection
+ * \sa SDL_HAPTIC_SPRING
+ * \sa SDL_HAPTIC_DAMPER
+ * \sa SDL_HAPTIC_INERTIA
+ * \sa SDL_HAPTIC_FRICTION
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticCondition {
+   /* Header */
+   Uint16 type; /**< SDL_HAPTIC_SPRING, SDL_HAPTIC_DAMPER,
+                     SDL_HAPTIC_INERTIA or SDL_HAPTIC_FRICTION */
+   SDL_HapticDirection direction; /**< Direction of the effect - Not used ATM. */
+
+   /* Replay */
+   Uint32 length; /**< Duration of the effect. */
+   Uint16 delay; /**< Delay before starting the effect. */
+
+   /* Trigger */
+   Uint16 button; /**< Button that triggers the effect. */
+   Uint16 interval; /**< How soon it can be triggered again after button. */
+
+   /* Condition */
+   Uint16 right_sat[3]; /**< Level when joystick is to the positive side. */
+   Uint16 left_sat[3]; /**< Level when joystick is to the negative side. */
+   Sint16 right_coeff[3]; /**< How fast to increase the force towards the positive side. */
+   Sint16 left_coeff[3]; /**< How fast to increase the force towards the negative side. */
+   Uint16 deadband[3]; /**< Size of the dead zone. */
+   Sint16 center[3]; /**< Position of the dead zone. */
+} SDL_HapticCondition;
+/**
+ * \struct SDL_HapticRamp
+ *
+ * \brief A structure containing a template for a Ramp effect.
+ *
+ * This struct is exclusively for the SDL_HAPTIC_RAMP effect.
+ *
+ * The ramp effect starts at start strength and ends at end strength.
+ *  It augments in linear fashion.  If you use attack and fade with a ramp
+ *  they effects get added to the ramp effect making the effect become
+ *  quadratic instead of linear.
+ *
+ * \sa SDL_HAPTIC_RAMP
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticRamp {
+   /* Header */
+   Uint16 type; /**< SDL_HAPTIC_RAMP */
+   SDL_HapticDirection direction; /**< Direction of the effect. */
+
+   /* Replay */
+   Uint32 length; /**< Duration of the effect. */
+   Uint16 delay; /**< Delay before starting the effect. */
+
+   /* Trigger */
+   Uint16 button; /**< Button that triggers the effect. */
+   Uint16 interval; /**< How soon it can be triggered again after button. */
+
+   /* Ramp */
+   Sint16 start; /**< Beginning strength level. */
+   Sint16 end; /**< Ending strength level. */
+
+   /* Envelope */
+   Uint16 attack_length; /**< Duration of the attack. */
+   Uint16 attack_level; /**< Level at the start of the attack. */
+   Uint16 fade_length; /**< Duration of the fade. */
+   Uint16 fade_level; /**< Level at the end of the fade. */
+} SDL_HapticRamp;
+/**
+ * \struct SDL_HapticCustom
+ *
+ * \brief A structure containing a template for the SDL_HAPTIC_CUSTOM effect.
+ *
+ * A custom force feedback effect is much like a periodic effect, where the
+ *  application can define it's exact shape.  You will have to allocate the
+ *  data yourself.  Data should consist of channels * samples Uint16 samples.
+ *
+ * If channels is one, the effect is rotated using the defined direction.
+ *  Otherwise it uses the samples in data for the different axes.
+ *
+ * \sa SDL_HAPTIC_CUSTOM
+ * \sa SDL_HapticEffect
+ */
+typedef struct SDL_HapticCustom {
+   /* Header */
+   Uint16 type; /**< SDL_HAPTIC_CUSTOM */
+   SDL_HapticDirection direction; /**< Direction of the effect. */
+
+   /* Replay */
+   Uint32 length; /**< Duration of the effect. */
+   Uint16 delay; /**< Delay before starting the effect. */
+
+   /* Trigger */
+   Uint16 button; /**< Button that triggers the effect. */
+   Uint16 interval; /**< How soon it can be triggered again after button. */
+
+   /* Custom */
+   Uint8 channels; /**< Axes to use, minimum of one. */
+   Uint16 period; /**< Sample periods. */
+   Uint16 samples; /**< Amount of samples. */
+   Uint16 *data; /**< Should contain channels*samples items. */
+
+   /* Envelope */                                                         
+   Uint16 attack_length; /**< Duration of the attack. */
+   Uint16 attack_level; /**< Level at the start of the attack. */
+   Uint16 fade_length; /**< Duration of the fade. */
+   Uint16 fade_level; /**< Level at the end of the fade. */
+} SDL_HapticCustom;
+/**
+ * \union SDL_HapticEffect
+ *
+ * \brief The generic template for any haptic effect.
+ *
+ * All values max at 32767 (0x7FFF).  Signed values also can be negative.
+ *  Time values unless specified otherwise are in milliseconds.
+ *
+ * You can also pass SDL_HAPTIC_INFINITY to length instead of a 0-32767 value.
+ *  Neither delay, interval, attack_length nor fade_length support 
+ *  SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
+ *
+ * Additionally, the SDL_HAPTIC_RAMP effect does not support a duration of
+ *  SDL_HAPTIC_INFINITY.
+ *
+ * Button triggers may not be supported on all devices, it is advised to not
+ *  use them if possible.  Buttons start at index 1 instead of index 0 like
+ *  they joystick.
+ *
+ * If both attack_length and fade_level are 0, the envelope is not used,
+ *  otherwise both values are used.
+ *
+ * Common parts:
+ * \code
+ * // Replay - All effects have this
+ * Uint32 length;        // Duration of effect (ms).
+ * Uint16 delay;         // Delay before starting effect.
+ *
+ * // Trigger - All effects have this
+ * Uint16 button;        // Button that triggers effect.
+ * Uint16 interval;      // How soon before effect can be triggered again.
+ *
+ * // Envelope - All effects except condition effects have this
+ * Uint16 attack_length; // Duration of the attack (ms).
+ * Uint16 attack_level;  // Level at the start of the attack.
+ * Uint16 fade_length;   // Duration of the fade out (ms).
+ * Uint16 fade_level;    // Level at the end of the fade.
+ * \endcode
+ *
+ *
+ * Here we have an example of a constant effect evolution in time:
+ *
+ * \code
+ * Strength
+ * ^
+ * |
+ * |    effect level -->  _________________
+ * |                     /                 \
+ * |                    /                   \
+ * |                   /                     \
+ * |                  /                       \ 
+ * | attack_level --> |                        \
+ * |                  |                        |  <---  fade_level
+ * |
+ * +--------------------------------------------------> Time
+ *                    [--]                 [---]
+ *                    attack_length        fade_length
+ * 
+ * [------------------][-----------------------]
+ * delay               length
+ * \endcode
+ *
+ * Note either the attack_level or the fade_level may be above the actual
+ *  effect level.
+ *
+ * \sa SDL_HapticConstant
+ * \sa SDL_HapticPeriodic
+ * \sa SDL_HapticCondition
+ * \sa SDL_HapticRamp
+ * \sa SDL_HapticCustom
+ */
+typedef union SDL_HapticEffect {
+   /* Common for all force feedback effects */
+   Uint16 type; /**< Effect type. */
+   SDL_HapticConstant constant; /**< Constant effect. */
+   SDL_HapticPeriodic periodic; /**< Periodic effect. */
+   SDL_HapticCondition condition; /**< Condition effect. */
+   SDL_HapticRamp ramp; /**< Ramp effect. */
+   SDL_HapticCustom custom; /**< Custom effect. */
+} SDL_HapticEffect;
+
+
+/* Function prototypes */
+/**
+ * \fn int SDL_NumHaptics(void)
+ *
+ * \brief Count the number of joysticks attached to the system.
+ *
+ *    \return Number of haptic devices detected on the system.
+ */
+extern DECLSPEC int SDLCALL SDL_NumHaptics(void);
+
+/**
+ * \fn const char * SDL_HapticName(int device_index)
+ *
+ * \brief Get the implementation dependent name of a Haptic device.
+ * This can be called before any joysticks are opened.
+ * If no name can be found, this function returns NULL.
+ *
+ *    \param device_index Index of the device to get it's name.
+ *    \return Name of the device or NULL on error.
+ *
+ * \sa SDL_NumHaptics
+ */
+extern DECLSPEC const char *SDLCALL SDL_HapticName(int device_index);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpen(int device_index)
+ *
+ * \brief Opens a Haptic device for usage - the index passed as an
+ * argument refers to the N'th Haptic device on this system.
+ *
+ * When opening a haptic device, it's gain will be set to maximum and
+ *  autocenter will be disabled.  To modify these values use
+ *  SDL_HapticSetGain and SDL_HapticSetAutocenter
+ *
+ *    \param device_index Index of the device to open.
+ *    \return Device identifier or NULL on error.
+ *
+ * \sa SDL_HapticIndex
+ * \sa SDL_HapticOpenFromMouse
+ * \sa SDL_HapticOpenFromJoystick
+ * \sa SDL_HapticClose
+ * \sa SDL_HapticSetGain
+ * \sa SDL_HapticSetAutocenter
+ * \sa SDL_HapticPause
+ * \sa SDL_HapticStopAll
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpen(int device_index);
+
+/**
+ * \fn int SDL_HapticOpened(int device_index)
+ *
+ * \brief Checks if the haptic device at index has been opened.
+ *
+ *    \param device_index Index to check to see if it has been opened.
+ *    \return 1 if it has been opened or 0 if it hasn't.
+ * 
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticIndex
+ */
+extern DECLSPEC int SDLCALL SDL_HapticOpened(int device_index);
+
+/**
+ * \fn int SDL_HapticIndex(SDL_Haptic * haptic)
+ *
+ * \brief Gets the index of a haptic device.
+ *
+ *    \param haptic Haptic device to get the index of.
+ *    \return The index of the haptic device or -1 on error.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticOpened
+ */
+extern DECLSPEC int SDLCALL SDL_HapticIndex(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_MouseIsHaptic(void)
+ *
+ * \brief Gets whether or not the current mouse has haptic capabilities.
+ *
+ *    \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
+ *
+ * \sa SDL_HapticOpenFromMouse
+ */
+extern DECLSPEC int SDLCALL SDL_MouseIsHaptic(void);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpenFromMouse(void)
+ *
+ * \brief Tries to open a haptic device from the current mouse.
+ *
+ *    \return The haptic device identifier or NULL on error.
+ *
+ * \sa SDL_MouseIsHaptic
+ * \sa SDL_HapticOpen
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpenFromMouse(void);
+
+/**
+ * \fn int SDL_JoystickIsHaptic(SDL_Joystick * joystick)
+ *
+ * \brief Checks to see if a joystick has haptic features.
+ *
+ *    \param joystick Joystick to test for haptic capabilities.
+ *    \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
+ *            or -1 if an error ocurred.
+ *
+ * \sa SDL_HapticOpenFromJoystick
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickIsHaptic(SDL_Joystick * joystick);
+
+/**
+ * \fn SDL_Haptic * SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)
+ *
+ * \brief Opens a Haptic device for usage from a Joystick device.  Still has
+ * to be closed seperately to the joystick.
+ *
+ * When opening from a joystick you should first close the haptic device before
+ *  closing the joystick device.  If not, on some implementations the haptic
+ *  device will also get unallocated and you'll be unable to use force feedback
+ *  on that device.
+ *
+ *    \param joystick Joystick to create a haptic device from.
+ *    \return A valid haptic device identifier on success or NULL on error.
+ *
+ * \sa SDL_HapticOpen
+ * \sa SDL_HapticClose
+ */
+extern DECLSPEC SDL_Haptic *SDLCALL SDL_HapticOpenFromJoystick(SDL_Joystick * joystick);
+
+/**
+ * \fn void SDL_HapticClose(SDL_Haptic * haptic)
+ *
+ * \brief Closes a Haptic device previously opened with SDL_HapticOpen.
+ *
+ *    \param haptic Haptic device to close.
+ */
+extern DECLSPEC void SDLCALL SDL_HapticClose(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticNumEffects(SDL_Haptic * haptic)
+ *
+ * \brief Returns the number of effects a haptic device can store.
+ *
+ * On some platforms this isn't fully supported, and therefore is an
+ *  aproximation.  Always check to see if your created effect was actually
+ *  created and do not rely solely on HapticNumEffects.
+ *
+ *    \param haptic The haptic device to query effect max.
+ *    \return The number of effects the haptic device can store or
+ *            -1 on error.
+ *
+ * \sa SDL_HapticNumEffectsPlaying
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumEffects(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic)
+ *
+ * \brief Returns the number of effects a haptic device can play at the same time.
+ *
+ * This is not supported on all platforms, but will always return a value.  Added
+ *  here for the sake of completness.
+ *
+ *    \param haptic The haptic device to query maximum playing effect.s
+ *    \return The number of effects the haptic device can play at the same time
+ *            or -1 on error.
+ *
+ * \sa SDL_HapticNumEffects
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic);
+
+/**
+ * \fn unsigned int SDL_HapticQuery(SDL_Haptic * haptic)
+ *
+ * \brief Gets the haptic devices supported features in bitwise matter.
+ *
+ * Example: 
+ * \code
+ * if (SDL_HapticQueryEffects(haptic) & SDL_HAPTIC_CONSTANT) {
+ *    printf("We have constant haptic effect!");
+ * }
+ * \endcode
+ *    
+ *
+ *    \param haptic The haptic device to query.
+ *    \return Haptic features in bitwise manner (OR'd).
+ *
+ * \sa SDL_HapticNumEffects
+ * \sa SDL_HapticEffectSupported
+ */
+extern DECLSPEC unsigned int SDLCALL SDL_HapticQuery(SDL_Haptic * haptic);
+
+
+/**
+ * \fn int SDL_HapticNumAxes(SDL_Haptic * haptic)
+ *
+ * \brief Gets the number of haptic axes the device has.
+ *
+ * \sa SDL_HapticDirection
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNumAxes(SDL_Haptic * haptic);
+
+/**
+ * \fn int SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+ *
+ * \brief Checks to see if effect is supported by haptic.
+ *
+ *    \param haptic Haptic device to check on.
+ *    \param effect Effect to check to see if it is supported.
+ *    \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or 
+ *            -1 on error.
+ * 
+ * \sa SDL_HapticQuery
+ * \sa SDL_HapticNewEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect);
+
+/**
+ * \fn int SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+ *
+ * \brief Creates a new haptic effect on the device.
+ *
+ *    \param haptic Haptic device to create the effect on.
+ *    \param effect Properties of the effect to create.
+ *    \return The id of the effect on success or -1 on error.
+ *
+ * \sa SDL_HapticUpdateEffect
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect);
+
+/**
+ * \fn int SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data)
+ *
+ * \brief Updates the properties of an effect.
+ *
+ * Can be used dynamically, although behaviour when dynamically changing
+ * direction may be strange.  Specifically the effect may reupload itself
+ * and start playing from the start.  You cannot change the type either when
+ * running UpdateEffect.
+ *
+ *    \param haptic Haptic device that has the effect.
+ *    \param effect Effect to update.
+ *    \param data New effect properties to use.
+ *    \return The id of the effect on success or -1 on error.
+ *
+ * \sa SDL_HapticNewEffect
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data);
+
+/**
+ * \fn int SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations)
+ *
+ * \brief Runs the haptic effect on it's assosciated haptic device.
+ *
+ * If iterations are SDL_HAPTIC_INFINITY, it'll run the effect over and over
+ *  repeating the envelope (attack and fade) every time.  If you only want the
+ *  effect to last forever, set SDL_HAPTIC_INFINITY in the effect's length
+ *  parameter.
+ *
+ *    \param haptic Haptic device to run the effect on.
+ *    \param effect Identifier of the haptic effect to run.
+ *    \param iterations Number of iterations to run the effect. Use
+ *           SDL_HAPTIC_INFINITY for infinity.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticStopEffect
+ * \sa SDL_HapticDestroyEffect
+ * \sa SDL_HapticGetEffectStatus
+ */
+extern DECLSPEC int SDLCALL SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations);
+
+/**
+ * \fn int SDL_HapticStopEffect(SDL_Haptic * haptic, int effect)
+ *
+ * \brief Stops the haptic effect on it's assosciated haptic device.
+ *
+ *    \param haptic Haptic device to stop the effect on.
+ *    \param effect Identifier of the effect to stop.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticDestroyEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticStopEffect(SDL_Haptic * haptic, int effect);
+
+/**
+ * \fn void SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect)
+ *
+ * \brief Destroys a haptic effect on the device.  This will stop the effect
+ * if it's running.  Effects are automatically destroyed when the device is
+ * closed.
+ *
+ *    \param haptic Device to destroy the effect on.
+ *    \param effect Identifier of the effect to destroy.
+ * 
+ * \sa SDL_HapticNewEffect
+ */
+extern DECLSPEC void SDLCALL SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect);
+
+/**
+ * \fn int SDL_HapticGetEffectStatus(SDL_Haptic *haptic, int effect)
+ *
+ * \brief Gets the status of the current effect on the haptic device.
+ *
+ * Device must support the SDL_HAPTIC_STATUS feature.
+ *
+ *    \param haptic Haptic device to query the effect status on.
+ *    \param effect Identifier of the effect to query it's status.
+ *    \return 0 if it isn't playing, SDL_HAPTIC_PLAYING if it is playing
+ *            or -1 on error.
+ *
+ * \sa SDL_HapticRunEffect
+ * \sa SDL_HapticStopEffect
+ */
+extern DECLSPEC int SDLCALL SDL_HapticGetEffectStatus(SDL_Haptic *haptic, int effect);
+
+/**
+ * \fn int SDL_HapticSetGain(SDL_Haptic * haptic, int gain)
+ *
+ * \brief Sets the global gain of the device.  Gain should be between 0 and 100.
+ *
+ * Device must support the SDL_HAPTIC_GAIN feature.
+ *
+ * The user may specify the maxmimum gain by setting the environment variable
+ *  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
+ *  SDL_HapticSetGain will scale linearly using SDL_HAPTIC_GAIN_MAX as the
+ *  maximum.
+ *
+ *    \param haptic Haptic device to set the gain on.
+ *    \param gain Value to set the gain to, should be between 0 and 100.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticSetGain(SDL_Haptic * haptic, int gain);
+
+/**
+ * \fn int SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+ *
+ * \brief Sets the global autocenter of the device.  Autocenter should be between
+ * 0 and 100.  Setting it to 0 will disable autocentering.
+ *
+ * Device must support the SDL_HAPTIC_AUTOCENTER feature.
+ *
+ *    \param haptic Haptic device to set autocentering on.
+ *    \param autocenter Value to set autocenter to, 0 disables autocentering.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticQuery
+ */
+extern DECLSPEC int SDLCALL SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticPause(SDL_Haptic * haptic)
+ *
+ * \brief Pauses a haptic device.
+ *
+ * Device must support the SDL_HAPTIC_PAUSE feature.  Call SDL_HapticUnpause
+ *  to resume playback.
+ *
+ * Do not modify the effects nor add new ones while the device is paused.
+ *  That can cause all sorts of weird errors.
+ *
+ *    \param haptic Haptic device to pause.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticUnpause
+ */
+extern DECLSPEC int SDLCALL SDL_HapticPause(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECLSPEC int SDLCALL SDL_HapticUnpause(SDL_Haptic * haptic)
+ *
+ * \brief Unpauses a haptic device.
+ *
+ * Call to unpause after SDL_HapticPause.
+ *
+ *    \param haptic Haptic device to pause.
+ *    \return 0 on success or -1 on error.
+ *
+ * \sa SDL_HapticPause
+ */
+extern DECLSPEC int SDLCALL SDL_HapticUnpause(SDL_Haptic * haptic);
+
+/**
+ * \fn extern DECSLPEC int SDLCALL SDL_HapticStopAll(SDL_Haptic * haptic)
+ *
+ * \brief Stops all the currently playing effects on a haptic device.
+ *
+ *    \param haptic Haptic device to stop.
+ *    \return 0 on success or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_HapticStopAll(SDL_Haptic * haptic);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+#include "close_code.h"
+
+#endif /* _SDL_haptic_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
+
diff -ruN SDL-1.2.13/include/d3dtypes.h_ SDL-1.2.13_OOx64/include/d3dtypes.h_
--- SDL-1.2.13/include/d3dtypes.h_	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/d3dtypes.h_	1999-11-19 17:32:22 +0000
@@ -0,0 +1,1698 @@
+/*==========================================================================;
+ *
+ *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
+ *
+ *  File:   d3dtypes.h
+ *  Content:    Direct3D types include file
+ *
+ ***************************************************************************/
+
+#ifndef _D3DTYPES_H_
+#define _D3DTYPES_H_
+
+#include <windows.h>
+
+#include <float.h>
+#include <ddraw.h>
+
+#ifndef DIRECT3D_VERSION
+#define DIRECT3D_VERSION         0x0600
+#endif
+
+#pragma pack(4)
+
+
+/* D3DVALUE is the fundamental Direct3D fractional data type */
+
+#define D3DVALP(val, prec) ((float)(val))
+#define D3DVAL(val) ((float)(val))
+typedef float D3DVALUE, *LPD3DVALUE;
+#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
+#define D3DMultiply(a, b)    ((a) * (b))
+
+typedef LONG D3DFIXED;
+
+#ifndef RGB_MAKE
+/*
+ * Format of CI colors is
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |    alpha      |         color index           |   fraction    |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+#define CI_GETALPHA(ci)    ((ci) >> 24)
+#define CI_GETINDEX(ci)    (((ci) >> 8) & 0xffff)
+#define CI_GETFRACTION(ci) ((ci) & 0xff)
+#define CI_ROUNDINDEX(ci)  CI_GETINDEX((ci) + 0x80)
+#define CI_MASKALPHA(ci)   ((ci) & 0xffffff)
+#define CI_MAKE(a, i, f)    (((a) << 24) | ((i) << 8) | (f))
+
+/*
+ * Format of RGBA colors is
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |    alpha      |      red      |     green     |     blue      |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
+#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
+#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
+#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
+#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))
+
+/* D3DRGB and D3DRGBA may be used as initialisers for D3DCOLORs
+ * The float values must be in the range 0..1
+ */
+#define D3DRGB(r, g, b) \
+    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
+#define D3DRGBA(r, g, b, a) \
+    (   (((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
+    |   (((long)((g) * 255)) << 8) | (long)((b) * 255) \
+    )
+
+/*
+ * Format of RGB colors is
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |    ignored    |      red      |     green     |     blue      |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+#define RGB_GETRED(rgb)         (((rgb) >> 16) & 0xff)
+#define RGB_GETGREEN(rgb)       (((rgb) >> 8) & 0xff)
+#define RGB_GETBLUE(rgb)        ((rgb) & 0xff)
+#define RGBA_SETALPHA(rgba, x) (((x) << 24) | ((rgba) & 0x00ffffff))
+#define RGB_MAKE(r, g, b)       ((D3DCOLOR) (((r) << 16) | ((g) << 8) | (b)))
+#define RGBA_TORGB(rgba)       ((D3DCOLOR) ((rgba) & 0xffffff))
+#define RGB_TORGBA(rgb)        ((D3DCOLOR) ((rgb) | 0xff000000))
+
+#endif
+
+/*
+ * Flags for Enumerate functions
+ */
+
+/*
+ * Stop the enumeration
+ */
+#define D3DENUMRET_CANCEL                        DDENUMRET_CANCEL
+
+/*
+ * Continue the enumeration
+ */
+#define D3DENUMRET_OK                            DDENUMRET_OK
+
+typedef HRESULT (CALLBACK* LPD3DVALIDATECALLBACK)(LPVOID lpUserArg, DWORD dwOffset);
+typedef HRESULT (CALLBACK* LPD3DENUMTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC lpDdsd, LPVOID lpContext);
+typedef HRESULT (CALLBACK* LPD3DENUMPIXELFORMATSCALLBACK)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);
+
+typedef DWORD D3DCOLOR, *LPD3DCOLOR;
+
+typedef DWORD D3DMATERIALHANDLE, *LPD3DMATERIALHANDLE;
+typedef DWORD D3DTEXTUREHANDLE, *LPD3DTEXTUREHANDLE;
+typedef DWORD D3DMATRIXHANDLE, *LPD3DMATRIXHANDLE;
+
+typedef struct _D3DCOLORVALUE {
+    union {
+    D3DVALUE r;
+    D3DVALUE dvR;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE g;
+    D3DVALUE dvG;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE b;
+    D3DVALUE dvB;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    union {
+    D3DVALUE a;
+    D3DVALUE dvA;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+} D3DCOLORVALUE, *LPD3DCOLORVALUE;
+
+typedef struct _D3DRECT {
+    union {
+    LONG x1;
+    LONG lX1;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    LONG y1;
+    LONG lY1;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    LONG x2;
+    LONG lX2;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    union {
+    LONG y2;
+    LONG lY2;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+} D3DRECT, *LPD3DRECT;
+
+typedef struct _D3DVECTOR {
+    union {
+    D3DVALUE x;
+    D3DVALUE dvX;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE y;
+    D3DVALUE dvY;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE z;
+    D3DVALUE dvZ;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+
+public:
+
+    // =====================================
+    // Constructors
+    // =====================================
+
+    _D3DVECTOR() { }
+    _D3DVECTOR(D3DVALUE f);
+    _D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z);
+    _D3DVECTOR(const D3DVALUE f[3]);
+
+    // =====================================
+    // Access grants
+    // =====================================
+
+    const D3DVALUE&operator[](int i) const;
+    D3DVALUE&operator[](int i);
+
+    // =====================================
+    // Assignment operators
+    // =====================================
+
+    _D3DVECTOR& operator += (const _D3DVECTOR& v);
+    _D3DVECTOR& operator -= (const _D3DVECTOR& v);
+    _D3DVECTOR& operator *= (const _D3DVECTOR& v);
+    _D3DVECTOR& operator /= (const _D3DVECTOR& v);
+    _D3DVECTOR& operator *= (D3DVALUE s);
+    _D3DVECTOR& operator /= (D3DVALUE s);
+
+    // =====================================
+    // Unary operators
+    // =====================================
+
+    friend _D3DVECTOR operator + (const _D3DVECTOR& v);
+    friend _D3DVECTOR operator - (const _D3DVECTOR& v);
+
+
+    // =====================================
+    // Binary operators
+    // =====================================
+
+    // Addition and subtraction
+        friend _D3DVECTOR operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+        friend _D3DVECTOR operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+    // Scalar multiplication and division
+        friend _D3DVECTOR operator * (const _D3DVECTOR& v, D3DVALUE s);
+        friend _D3DVECTOR operator * (D3DVALUE s, const _D3DVECTOR& v);
+        friend _D3DVECTOR operator / (const _D3DVECTOR& v, D3DVALUE s);
+    // Memberwise multiplication and division
+        friend _D3DVECTOR operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+        friend _D3DVECTOR operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+
+    // Vector dominance
+        friend int operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+        friend int operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+
+    // Bitwise equality
+        friend int operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+
+    // Length-related functions
+        friend D3DVALUE SquareMagnitude (const _D3DVECTOR& v);
+        friend D3DVALUE Magnitude (const _D3DVECTOR& v);
+
+    // Returns vector with same direction and unit length
+        friend _D3DVECTOR Normalize (const _D3DVECTOR& v);
+
+    // Return min/max component of the input vector
+        friend D3DVALUE Min (const _D3DVECTOR& v);
+        friend D3DVALUE Max (const _D3DVECTOR& v);
+
+    // Return memberwise min/max of input vectors
+        friend _D3DVECTOR Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+        friend _D3DVECTOR Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+
+    // Dot and cross product
+        friend D3DVALUE DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+        friend _D3DVECTOR CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
+
+#endif
+} D3DVECTOR, *LPD3DVECTOR;
+
+/*
+ * Vertex data types supported in an ExecuteBuffer.
+ */
+
+/*
+ * Homogeneous vertices
+ */
+
+typedef struct _D3DHVERTEX {
+    DWORD           dwFlags;        /* Homogeneous clipping flags */
+    union {
+    D3DVALUE    hx;
+    D3DVALUE    dvHX;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    hy;
+    D3DVALUE    dvHY;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    hz;
+    D3DVALUE    dvHZ;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+} D3DHVERTEX, *LPD3DHVERTEX;
+
+/*
+ * Transformed/lit vertices
+ */
+typedef struct _D3DTLVERTEX {
+    union {
+    D3DVALUE    sx;             /* Screen coordinates */
+    D3DVALUE    dvSX;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    sy;
+    D3DVALUE    dvSY;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    sz;
+    D3DVALUE    dvSZ;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    rhw;        /* Reciprocal of homogeneous w */
+    D3DVALUE    dvRHW;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+    union {
+    D3DCOLOR    color;          /* Vertex color */
+    D3DCOLOR    dcColor;
+#if defined(NONAMELESSUNION)
+    } u5;
+#else
+    };
+#endif
+    union {
+    D3DCOLOR    specular;       /* Specular component of vertex */
+    D3DCOLOR    dcSpecular;
+#if defined(NONAMELESSUNION)
+    } u6;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    tu;             /* Texture coordinates */
+    D3DVALUE    dvTU;
+#if defined(NONAMELESSUNION)
+    } u7;
+#else
+    };
+#endif
+    union {
+    D3DVALUE    tv;
+    D3DVALUE    dvTV;
+#if defined(NONAMELESSUNION)
+    } u8;
+#else
+    };
+#endif
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+    _D3DTLVERTEX() { }
+    _D3DTLVERTEX(const D3DVECTOR& v, float _rhw,
+                 D3DCOLOR _color, D3DCOLOR _specular,
+                 float _tu, float _tv)
+        { sx = v.x; sy = v.y; sz = v.z; rhw = _rhw;
+          color = _color; specular = _specular;
+          tu = _tu; tv = _tv;
+        }
+#endif
+} D3DTLVERTEX, *LPD3DTLVERTEX;
+
+/*
+ * Untransformed/lit vertices
+ */
+typedef struct _D3DLVERTEX {
+    union {
+    D3DVALUE     x;             /* Homogeneous coordinates */
+    D3DVALUE     dvX;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     y;
+    D3DVALUE     dvY;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     z;
+    D3DVALUE     dvZ;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    DWORD            dwReserved;
+    union {
+    D3DCOLOR     color;         /* Vertex color */
+    D3DCOLOR     dcColor;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+    union {
+    D3DCOLOR     specular;      /* Specular component of vertex */
+    D3DCOLOR     dcSpecular;
+#if defined(NONAMELESSUNION)
+    } u5;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     tu;            /* Texture coordinates */
+    D3DVALUE     dvTU;
+#if defined(NONAMELESSUNION)
+    } u6;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     tv;
+    D3DVALUE     dvTV;
+#if defined(NONAMELESSUNION)
+    } u7;
+#else
+    };
+#endif
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+    _D3DLVERTEX() { }
+    _D3DLVERTEX(const D3DVECTOR& v,
+                D3DCOLOR _color, D3DCOLOR _specular,
+                float _tu, float _tv)
+        { x = v.x; y = v.y; z = v.z; dwReserved = 0;
+          color = _color; specular = _specular;
+          tu = _tu; tv = _tv;
+        }
+#endif
+} D3DLVERTEX, *LPD3DLVERTEX;
+
+/*
+ * Untransformed/unlit vertices
+ */
+
+typedef struct _D3DVERTEX {
+    union {
+    D3DVALUE     x;             /* Homogeneous coordinates */
+    D3DVALUE     dvX;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     y;
+    D3DVALUE     dvY;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     z;
+    D3DVALUE     dvZ;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     nx;            /* Normal */
+    D3DVALUE     dvNX;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     ny;
+    D3DVALUE     dvNY;
+#if defined(NONAMELESSUNION)
+    } u5;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     nz;
+    D3DVALUE     dvNZ;
+#if defined(NONAMELESSUNION)
+    } u6;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     tu;            /* Texture coordinates */
+    D3DVALUE     dvTU;
+#if defined(NONAMELESSUNION)
+    } u7;
+#else
+    };
+#endif
+    union {
+    D3DVALUE     tv;
+    D3DVALUE     dvTV;
+#if defined(NONAMELESSUNION)
+    } u8;
+#else
+    };
+#endif
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+    _D3DVERTEX() { }
+    _D3DVERTEX(const D3DVECTOR& v, const D3DVECTOR& n, float _tu, float _tv)
+        { x = v.x; y = v.y; z = v.z;
+          nx = n.x; ny = n.y; nz = n.z;
+          tu = _tu; tv = _tv;
+        }
+#endif
+} D3DVERTEX, *LPD3DVERTEX;
+
+
+/*
+ * Matrix, viewport, and tranformation structures and definitions.
+ */
+
+typedef struct _D3DMATRIX {
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+    union {
+        struct {
+#endif
+
+            D3DVALUE        _11, _12, _13, _14;
+            D3DVALUE        _21, _22, _23, _24;
+            D3DVALUE        _31, _32, _33, _34;
+            D3DVALUE        _41, _42, _43, _44;
+
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+#if defined(NONAMELESSUNION)
+        } u1;
+#else
+        };
+#endif
+        D3DVALUE m[4][4];
+    };
+    _D3DMATRIX() { }
+    _D3DMATRIX( D3DVALUE _m00, D3DVALUE _m01, D3DVALUE _m02, D3DVALUE _m03,
+                D3DVALUE _m10, D3DVALUE _m11, D3DVALUE _m12, D3DVALUE _m13,
+                D3DVALUE _m20, D3DVALUE _m21, D3DVALUE _m22, D3DVALUE _m23,
+                D3DVALUE _m30, D3DVALUE _m31, D3DVALUE _m32, D3DVALUE _m33
+        )
+        {
+                m[0][0] = _m00; m[0][1] = _m01; m[0][2] = _m02; m[0][3] = _m03;
+                m[1][0] = _m10; m[1][1] = _m11; m[1][2] = _m12; m[1][3] = _m13;
+                m[2][0] = _m20; m[2][1] = _m21; m[2][2] = _m22; m[2][3] = _m23;
+                m[3][0] = _m30; m[3][1] = _m31; m[3][2] = _m32; m[3][3] = _m33;
+        }
+
+    D3DVALUE& operator()(int iRow, int iColumn) { return m[iRow][iColumn]; }
+    const D3DVALUE& operator()(int iRow, int iColumn) const { return m[iRow][iColumn]; }
+    friend _D3DMATRIX operator* (const _D3DMATRIX&, const _D3DMATRIX&);
+#endif
+} D3DMATRIX, *LPD3DMATRIX;
+
+#if (defined __cplusplus) && (defined D3D_OVERLOADS)
+#include "d3dvec.inl"
+#endif
+
+typedef struct _D3DVIEWPORT {
+    DWORD       dwSize;
+    DWORD       dwX;
+    DWORD       dwY;        /* Top left */
+    DWORD       dwWidth;
+    DWORD       dwHeight;   /* Dimensions */
+    D3DVALUE    dvScaleX;   /* Scale homogeneous to screen */
+    D3DVALUE    dvScaleY;   /* Scale homogeneous to screen */
+    D3DVALUE    dvMaxX;     /* Min/max homogeneous x coord */
+    D3DVALUE    dvMaxY;     /* Min/max homogeneous y coord */
+    D3DVALUE    dvMinZ;
+    D3DVALUE    dvMaxZ;     /* Min/max homogeneous z coord */
+} D3DVIEWPORT, *LPD3DVIEWPORT;
+
+typedef struct _D3DVIEWPORT2 {
+    DWORD       dwSize;
+    DWORD       dwX;
+    DWORD       dwY;        /* Viewport Top left */
+    DWORD       dwWidth;
+    DWORD       dwHeight;   /* Viewport Dimensions */
+    D3DVALUE    dvClipX;        /* Top left of clip volume */
+    D3DVALUE    dvClipY;
+    D3DVALUE    dvClipWidth;    /* Clip Volume Dimensions */
+    D3DVALUE    dvClipHeight;
+    D3DVALUE    dvMinZ;         /* Min/max of clip Volume */
+    D3DVALUE    dvMaxZ;
+} D3DVIEWPORT2, *LPD3DVIEWPORT2;
+
+/*
+ * Values for clip fields.
+ */
+#define D3DCLIP_LEFT                0x00000001L
+#define D3DCLIP_RIGHT               0x00000002L
+#define D3DCLIP_TOP             0x00000004L
+#define D3DCLIP_BOTTOM              0x00000008L
+#define D3DCLIP_FRONT               0x00000010L
+#define D3DCLIP_BACK                0x00000020L
+#define D3DCLIP_GEN0                0x00000040L
+#define D3DCLIP_GEN1                0x00000080L
+#define D3DCLIP_GEN2                0x00000100L
+#define D3DCLIP_GEN3                0x00000200L
+#define D3DCLIP_GEN4                0x00000400L
+#define D3DCLIP_GEN5                0x00000800L
+
+/*
+ * Values for d3d status.
+ */
+#define D3DSTATUS_CLIPUNIONLEFT         D3DCLIP_LEFT
+#define D3DSTATUS_CLIPUNIONRIGHT        D3DCLIP_RIGHT
+#define D3DSTATUS_CLIPUNIONTOP          D3DCLIP_TOP
+#define D3DSTATUS_CLIPUNIONBOTTOM       D3DCLIP_BOTTOM
+#define D3DSTATUS_CLIPUNIONFRONT        D3DCLIP_FRONT
+#define D3DSTATUS_CLIPUNIONBACK         D3DCLIP_BACK
+#define D3DSTATUS_CLIPUNIONGEN0         D3DCLIP_GEN0
+#define D3DSTATUS_CLIPUNIONGEN1         D3DCLIP_GEN1
+#define D3DSTATUS_CLIPUNIONGEN2         D3DCLIP_GEN2
+#define D3DSTATUS_CLIPUNIONGEN3         D3DCLIP_GEN3
+#define D3DSTATUS_CLIPUNIONGEN4         D3DCLIP_GEN4
+#define D3DSTATUS_CLIPUNIONGEN5         D3DCLIP_GEN5
+
+#define D3DSTATUS_CLIPINTERSECTIONLEFT      0x00001000L
+#define D3DSTATUS_CLIPINTERSECTIONRIGHT     0x00002000L
+#define D3DSTATUS_CLIPINTERSECTIONTOP       0x00004000L
+#define D3DSTATUS_CLIPINTERSECTIONBOTTOM    0x00008000L
+#define D3DSTATUS_CLIPINTERSECTIONFRONT     0x00010000L
+#define D3DSTATUS_CLIPINTERSECTIONBACK      0x00020000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN0      0x00040000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN1      0x00080000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN2      0x00100000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN3      0x00200000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN4      0x00400000L
+#define D3DSTATUS_CLIPINTERSECTIONGEN5      0x00800000L
+#define D3DSTATUS_ZNOTVISIBLE               0x01000000L
+/* Do not use 0x80000000 for any status flags in future as it is reserved */
+
+#define D3DSTATUS_CLIPUNIONALL  (       \
+        D3DSTATUS_CLIPUNIONLEFT |   \
+        D3DSTATUS_CLIPUNIONRIGHT    |   \
+        D3DSTATUS_CLIPUNIONTOP  |   \
+        D3DSTATUS_CLIPUNIONBOTTOM   |   \
+        D3DSTATUS_CLIPUNIONFRONT    |   \
+        D3DSTATUS_CLIPUNIONBACK |   \
+        D3DSTATUS_CLIPUNIONGEN0 |   \
+        D3DSTATUS_CLIPUNIONGEN1 |   \
+        D3DSTATUS_CLIPUNIONGEN2 |   \
+        D3DSTATUS_CLIPUNIONGEN3 |   \
+        D3DSTATUS_CLIPUNIONGEN4 |   \
+        D3DSTATUS_CLIPUNIONGEN5     \
+        )
+
+#define D3DSTATUS_CLIPINTERSECTIONALL   (       \
+        D3DSTATUS_CLIPINTERSECTIONLEFT  |   \
+        D3DSTATUS_CLIPINTERSECTIONRIGHT |   \
+        D3DSTATUS_CLIPINTERSECTIONTOP   |   \
+        D3DSTATUS_CLIPINTERSECTIONBOTTOM    |   \
+        D3DSTATUS_CLIPINTERSECTIONFRONT |   \
+        D3DSTATUS_CLIPINTERSECTIONBACK  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN0  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN1  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN2  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN3  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN4  |   \
+        D3DSTATUS_CLIPINTERSECTIONGEN5      \
+        )
+
+#define D3DSTATUS_DEFAULT   (           \
+        D3DSTATUS_CLIPINTERSECTIONALL   |   \
+        D3DSTATUS_ZNOTVISIBLE)
+
+
+/*
+ * Options for direct transform calls
+ */
+#define D3DTRANSFORM_CLIPPED       0x00000001l
+#define D3DTRANSFORM_UNCLIPPED     0x00000002l
+
+typedef struct _D3DTRANSFORMDATA {
+    DWORD           dwSize;
+    LPVOID      lpIn;           /* Input vertices */
+    DWORD           dwInSize;       /* Stride of input vertices */
+    LPVOID      lpOut;          /* Output vertices */
+    DWORD           dwOutSize;      /* Stride of output vertices */
+    LPD3DHVERTEX    lpHOut;         /* Output homogeneous vertices */
+    DWORD           dwClip;         /* Clipping hint */
+    DWORD           dwClipIntersection;
+    DWORD           dwClipUnion;    /* Union of all clip flags */
+    D3DRECT         drExtent;       /* Extent of transformed vertices */
+} D3DTRANSFORMDATA, *LPD3DTRANSFORMDATA;
+
+/*
+ * Structure defining position and direction properties for lighting.
+ */
+typedef struct _D3DLIGHTINGELEMENT {
+    D3DVECTOR dvPosition;           /* Lightable point in model space */
+    D3DVECTOR dvNormal;             /* Normalised unit vector */
+} D3DLIGHTINGELEMENT, *LPD3DLIGHTINGELEMENT;
+
+/*
+ * Structure defining material properties for lighting.
+ */
+typedef struct _D3DMATERIAL {
+    DWORD           dwSize;
+    union {
+    D3DCOLORVALUE   diffuse;        /* Diffuse color RGBA */
+    D3DCOLORVALUE   dcvDiffuse;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    D3DCOLORVALUE   ambient;        /* Ambient color RGB */
+    D3DCOLORVALUE   dcvAmbient;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    D3DCOLORVALUE   specular;       /* Specular 'shininess' */
+    D3DCOLORVALUE   dcvSpecular;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    union {
+    D3DCOLORVALUE   emissive;       /* Emissive color RGB */
+    D3DCOLORVALUE   dcvEmissive;
+#if defined(NONAMELESSUNION)
+    } u4;
+#else
+    };
+#endif
+    union {
+    D3DVALUE        power;          /* Sharpness if specular highlight */
+    D3DVALUE        dvPower;
+#if defined(NONAMELESSUNION)
+    } u5;
+#else
+    };
+#endif
+    D3DTEXTUREHANDLE    hTexture;       /* Handle to texture map */
+    DWORD           dwRampSize;
+} D3DMATERIAL, *LPD3DMATERIAL;
+
+typedef enum _D3DLIGHTTYPE {
+    D3DLIGHT_POINT          = 1,
+    D3DLIGHT_SPOT           = 2,
+    D3DLIGHT_DIRECTIONAL    = 3,
+    D3DLIGHT_PARALLELPOINT  = 4,
+#if(DIRECT3D_VERSION < 0x0500) // For backward compatible headers
+    D3DLIGHT_GLSPOT         = 5,
+#endif
+    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
+} D3DLIGHTTYPE;
+
+/*
+ * Structure defining a light source and its properties.
+ */
+typedef struct _D3DLIGHT {
+    DWORD           dwSize;
+    D3DLIGHTTYPE    dltType;            /* Type of light source */
+    D3DCOLORVALUE   dcvColor;       /* Color of light */
+    D3DVECTOR       dvPosition;     /* Position in world space */
+    D3DVECTOR       dvDirection;        /* Direction in world space */
+    D3DVALUE        dvRange;            /* Cutoff range */
+    D3DVALUE        dvFalloff;          /* Falloff */
+    D3DVALUE        dvAttenuation0;     /* Constant attenuation */
+    D3DVALUE        dvAttenuation1;     /* Linear attenuation */
+    D3DVALUE        dvAttenuation2;     /* Quadratic attenuation */
+    D3DVALUE        dvTheta;            /* Inner angle of spotlight cone */
+    D3DVALUE        dvPhi;              /* Outer angle of spotlight cone */
+} D3DLIGHT, *LPD3DLIGHT;
+
+/*
+ * Structure defining a light source and its properties.
+ */
+
+/* flags bits */
+#define D3DLIGHT_ACTIVE         0x00000001
+#define D3DLIGHT_NO_SPECULAR    0x00000002
+
+/* maximum valid light range */
+#define D3DLIGHT_RANGE_MAX      ((float)sqrt(FLT_MAX))
+
+typedef struct _D3DLIGHT2 {
+    DWORD           dwSize;
+    D3DLIGHTTYPE    dltType;        /* Type of light source */
+    D3DCOLORVALUE   dcvColor;       /* Color of light */
+    D3DVECTOR       dvPosition;     /* Position in world space */
+    D3DVECTOR       dvDirection;    /* Direction in world space */
+    D3DVALUE        dvRange;        /* Cutoff range */
+    D3DVALUE        dvFalloff;      /* Falloff */
+    D3DVALUE        dvAttenuation0; /* Constant attenuation */
+    D3DVALUE        dvAttenuation1; /* Linear attenuation */
+    D3DVALUE        dvAttenuation2; /* Quadratic attenuation */
+    D3DVALUE        dvTheta;        /* Inner angle of spotlight cone */
+    D3DVALUE        dvPhi;          /* Outer angle of spotlight cone */
+    DWORD           dwFlags;
+} D3DLIGHT2, *LPD3DLIGHT2;
+
+typedef struct _D3DLIGHTDATA {
+    DWORD                dwSize;
+    LPD3DLIGHTINGELEMENT lpIn;      /* Input positions and normals */
+    DWORD                dwInSize;  /* Stride of input elements */
+    LPD3DTLVERTEX        lpOut;     /* Output colors */
+    DWORD                dwOutSize; /* Stride of output colors */
+} D3DLIGHTDATA, *LPD3DLIGHTDATA;
+
+/*
+ * Before DX5, these values were in an enum called
+ * D3DCOLORMODEL. This was not correct, since they are
+ * bit flags. A driver can surface either or both flags
+ * in the dcmColorModel member of D3DDEVICEDESC.
+ */
+#define D3DCOLOR_MONO   1
+#define D3DCOLOR_RGB    2
+
+typedef DWORD D3DCOLORMODEL;
+
+/*
+ * Options for clearing
+ */
+#define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
+#define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
+#define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */
+
+/*
+ * Execute buffers are allocated via Direct3D.  These buffers may then
+ * be filled by the application with instructions to execute along with
+ * vertex data.
+ */
+
+/*
+ * Supported op codes for execute instructions.
+ */
+typedef enum _D3DOPCODE {
+    D3DOP_POINT                 = 1,
+    D3DOP_LINE                  = 2,
+    D3DOP_TRIANGLE      = 3,
+    D3DOP_MATRIXLOAD        = 4,
+    D3DOP_MATRIXMULTIPLY    = 5,
+    D3DOP_STATETRANSFORM        = 6,
+    D3DOP_STATELIGHT        = 7,
+    D3DOP_STATERENDER       = 8,
+    D3DOP_PROCESSVERTICES       = 9,
+    D3DOP_TEXTURELOAD       = 10,
+    D3DOP_EXIT                  = 11,
+    D3DOP_BRANCHFORWARD     = 12,
+    D3DOP_SPAN          = 13,
+    D3DOP_SETSTATUS     = 14,
+    D3DOP_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
+} D3DOPCODE;
+
+typedef struct _D3DINSTRUCTION {
+    BYTE bOpcode;   /* Instruction opcode */
+    BYTE bSize;     /* Size of each instruction data unit */
+    WORD wCount;    /* Count of instruction data units to follow */
+} D3DINSTRUCTION, *LPD3DINSTRUCTION;
+
+/*
+ * Structure for texture loads
+ */
+typedef struct _D3DTEXTURELOAD {
+    D3DTEXTUREHANDLE hDestTexture;
+    D3DTEXTUREHANDLE hSrcTexture;
+} D3DTEXTURELOAD, *LPD3DTEXTURELOAD;
+
+/*
+ * Structure for picking
+ */
+typedef struct _D3DPICKRECORD {
+    BYTE     bOpcode;
+    BYTE     bPad;
+    DWORD    dwOffset;
+    D3DVALUE dvZ;
+} D3DPICKRECORD, *LPD3DPICKRECORD;
+
+/*
+ * The following defines the rendering states which can be set in the
+ * execute buffer.
+ */
+
+typedef enum _D3DSHADEMODE {
+    D3DSHADE_FLAT              = 1,
+    D3DSHADE_GOURAUD           = 2,
+    D3DSHADE_PHONG             = 3,
+    D3DSHADE_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
+} D3DSHADEMODE;
+
+typedef enum _D3DFILLMODE {
+    D3DFILL_POINT          = 1,
+    D3DFILL_WIREFRAME          = 2,
+    D3DFILL_SOLID          = 3,
+    D3DFILL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
+} D3DFILLMODE;
+
+typedef struct _D3DLINEPATTERN {
+    WORD    wRepeatFactor;
+    WORD    wLinePattern;
+} D3DLINEPATTERN;
+
+typedef enum _D3DTEXTUREFILTER {
+    D3DFILTER_NEAREST          = 1,
+    D3DFILTER_LINEAR           = 2,
+    D3DFILTER_MIPNEAREST       = 3,
+    D3DFILTER_MIPLINEAR        = 4,
+    D3DFILTER_LINEARMIPNEAREST = 5,
+    D3DFILTER_LINEARMIPLINEAR  = 6,
+    D3DFILTER_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
+} D3DTEXTUREFILTER;
+
+typedef enum _D3DBLEND {
+    D3DBLEND_ZERO              = 1,
+    D3DBLEND_ONE               = 2,
+    D3DBLEND_SRCCOLOR          = 3,
+    D3DBLEND_INVSRCCOLOR       = 4,
+    D3DBLEND_SRCALPHA          = 5,
+    D3DBLEND_INVSRCALPHA       = 6,
+    D3DBLEND_DESTALPHA         = 7,
+    D3DBLEND_INVDESTALPHA      = 8,
+    D3DBLEND_DESTCOLOR         = 9,
+    D3DBLEND_INVDESTCOLOR      = 10,
+    D3DBLEND_SRCALPHASAT       = 11,
+    D3DBLEND_BOTHSRCALPHA      = 12,
+    D3DBLEND_BOTHINVSRCALPHA   = 13,
+    D3DBLEND_FORCE_DWORD       = 0x7fffffff, /* force 32-bit size enum */
+} D3DBLEND;
+
+typedef enum _D3DTEXTUREBLEND {
+    D3DTBLEND_DECAL            = 1,
+    D3DTBLEND_MODULATE         = 2,
+    D3DTBLEND_DECALALPHA       = 3,
+    D3DTBLEND_MODULATEALPHA    = 4,
+    D3DTBLEND_DECALMASK        = 5,
+    D3DTBLEND_MODULATEMASK     = 6,
+    D3DTBLEND_COPY             = 7,
+    D3DTBLEND_ADD              = 8,
+    D3DTBLEND_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
+} D3DTEXTUREBLEND;
+
+typedef enum _D3DTEXTUREADDRESS {
+    D3DTADDRESS_WRAP           = 1,
+    D3DTADDRESS_MIRROR         = 2,
+    D3DTADDRESS_CLAMP          = 3,
+    D3DTADDRESS_BORDER         = 4,
+    D3DTADDRESS_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
+} D3DTEXTUREADDRESS;
+
+typedef enum _D3DCULL {
+    D3DCULL_NONE               = 1,
+    D3DCULL_CW                 = 2,
+    D3DCULL_CCW                = 3,
+    D3DCULL_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
+} D3DCULL;
+
+typedef enum _D3DCMPFUNC {
+    D3DCMP_NEVER               = 1,
+    D3DCMP_LESS                = 2,
+    D3DCMP_EQUAL               = 3,
+    D3DCMP_LESSEQUAL           = 4,
+    D3DCMP_GREATER             = 5,
+    D3DCMP_NOTEQUAL            = 6,
+    D3DCMP_GREATEREQUAL        = 7,
+    D3DCMP_ALWAYS              = 8,
+    D3DCMP_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
+} D3DCMPFUNC;
+
+typedef enum _D3DSTENCILOP {
+    D3DSTENCILOP_KEEP           = 1,
+    D3DSTENCILOP_ZERO           = 2,
+    D3DSTENCILOP_REPLACE        = 3,
+    D3DSTENCILOP_INCRSAT        = 4,
+    D3DSTENCILOP_DECRSAT        = 5,
+    D3DSTENCILOP_INVERT         = 6,
+    D3DSTENCILOP_INCR           = 7,
+    D3DSTENCILOP_DECR           = 8,
+    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
+} D3DSTENCILOP;
+
+typedef enum _D3DFOGMODE {
+    D3DFOG_NONE                = 0,
+    D3DFOG_EXP                 = 1,
+    D3DFOG_EXP2                = 2,
+    D3DFOG_LINEAR              = 3,
+    D3DFOG_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
+} D3DFOGMODE;
+
+typedef enum _D3DZBUFFERTYPE {
+    D3DZB_FALSE                 = 0,
+    D3DZB_TRUE                  = 1, // Z buffering
+    D3DZB_USEW                  = 2, // W buffering
+    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
+} D3DZBUFFERTYPE;
+
+typedef enum _D3DANTIALIASMODE {
+    D3DANTIALIAS_NONE          = 0,
+    D3DANTIALIAS_SORTDEPENDENT = 1,
+    D3DANTIALIAS_SORTINDEPENDENT = 2,
+    D3DANTIALIAS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
+} D3DANTIALIASMODE;
+
+// Vertex types supported by Direct3D
+typedef enum _D3DVERTEXTYPE {
+    D3DVT_VERTEX        = 1,
+    D3DVT_LVERTEX       = 2,
+    D3DVT_TLVERTEX      = 3,
+    D3DVT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
+} D3DVERTEXTYPE;
+
+// Primitives supported by draw-primitive API
+typedef enum _D3DPRIMITIVETYPE {
+    D3DPT_POINTLIST     = 1,
+    D3DPT_LINELIST      = 2,
+    D3DPT_LINESTRIP     = 3,
+    D3DPT_TRIANGLELIST  = 4,
+    D3DPT_TRIANGLESTRIP = 5,
+    D3DPT_TRIANGLEFAN   = 6,
+    D3DPT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
+} D3DPRIMITIVETYPE;
+
+/*
+ * Amount to add to a state to generate the override for that state.
+ */
+#define D3DSTATE_OVERRIDE_BIAS      256
+
+/*
+ * A state which sets the override flag for the specified state type.
+ */
+#define D3DSTATE_OVERRIDE(type) (D3DRENDERSTATETYPE)(((DWORD) (type) + D3DSTATE_OVERRIDE_BIAS))
+
+typedef enum _D3DTRANSFORMSTATETYPE {
+    D3DTRANSFORMSTATE_WORLD           = 1,
+    D3DTRANSFORMSTATE_VIEW            = 2,
+    D3DTRANSFORMSTATE_PROJECTION      = 3,
+    D3DTRANSFORMSTATE_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
+} D3DTRANSFORMSTATETYPE;
+
+typedef enum _D3DLIGHTSTATETYPE {
+    D3DLIGHTSTATE_MATERIAL          = 1,
+    D3DLIGHTSTATE_AMBIENT           = 2,
+    D3DLIGHTSTATE_COLORMODEL        = 3,
+    D3DLIGHTSTATE_FOGMODE           = 4,
+    D3DLIGHTSTATE_FOGSTART          = 5,
+    D3DLIGHTSTATE_FOGEND            = 6,
+    D3DLIGHTSTATE_FOGDENSITY        = 7,
+    D3DLIGHTSTATE_COLORVERTEX       = 8,
+    D3DLIGHTSTATE_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
+} D3DLIGHTSTATETYPE;
+
+typedef enum _D3DRENDERSTATETYPE {
+    D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle for legacy interfaces (Texture,Texture2) */
+    D3DRENDERSTATE_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
+    D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS  */
+    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
+    D3DRENDERSTATE_WRAPU          = 5,    /* TRUE for wrapping in u */
+    D3DRENDERSTATE_WRAPV          = 6,    /* TRUE for wrapping in v */
+    D3DRENDERSTATE_ZENABLE            = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
+    D3DRENDERSTATE_FILLMODE           = 8,    /* D3DFILL_MODE        */
+    D3DRENDERSTATE_SHADEMODE          = 9,    /* D3DSHADEMODE */
+    D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
+    D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
+    D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
+    D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
+    D3DRENDERSTATE_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
+    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
+    D3DRENDERSTATE_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
+    D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
+    D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
+    D3DRENDERSTATE_SRCBLEND           = 19,   /* D3DBLEND */
+    D3DRENDERSTATE_DESTBLEND          = 20,   /* D3DBLEND */
+    D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
+    D3DRENDERSTATE_CULLMODE           = 22,   /* D3DCULL */
+    D3DRENDERSTATE_ZFUNC              = 23,   /* D3DCMPFUNC */
+    D3DRENDERSTATE_ALPHAREF           = 24,   /* D3DFIXED */
+    D3DRENDERSTATE_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
+    D3DRENDERSTATE_DITHERENABLE       = 26,   /* TRUE to enable dithering */
+    D3DRENDERSTATE_ALPHABLENDENABLE        = 27,   /* TRUE to enable alpha blending */
+    D3DRENDERSTATE_FOGENABLE          = 28,   /* TRUE to enable fog */
+    D3DRENDERSTATE_SPECULARENABLE     = 29,   /* TRUE to enable specular */
+    D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
+    D3DRENDERSTATE_SUBPIXEL       = 31,   /* TRUE to enable subpixel correction */
+    D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
+    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha */
+    D3DRENDERSTATE_FOGCOLOR           = 34,   /* D3DCOLOR */
+    D3DRENDERSTATE_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
+    D3DRENDERSTATE_FOGTABLESTART      = 36,   /* Fog table start    */
+    D3DRENDERSTATE_FOGTABLEEND        = 37,   /* Fog table end      */
+    D3DRENDERSTATE_FOGTABLEDENSITY    = 38,   /* Fog table density  */
+    D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
+    D3DRENDERSTATE_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
+    D3DRENDERSTATE_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
+    D3DRENDERSTATE_BORDERCOLOR        = 43,   /* Border color for texturing w/border */
+    D3DRENDERSTATE_TEXTUREADDRESSU    = 44,   /* Texture addressing mode for U coordinate */
+    D3DRENDERSTATE_TEXTUREADDRESSV    = 45,   /* Texture addressing mode for V coordinate */
+    D3DRENDERSTATE_MIPMAPLODBIAS      = 46,   /* D3DVALUE Mipmap LOD bias */
+    D3DRENDERSTATE_ZBIAS              = 47,   /* LONG Z bias */
+    D3DRENDERSTATE_RANGEFOGENABLE     = 48,   /* Enables range-based fog */
+    D3DRENDERSTATE_ANISOTROPY         = 49,   /* Max. anisotropy. 1 = no anisotropy */
+    D3DRENDERSTATE_FLUSHBATCH         = 50,   /* Explicit flush for DP batching (DX5 Only) */
+    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT=51, /* BOOL enable sort-independent transparency */
+    D3DRENDERSTATE_STENCILENABLE      = 52,   /* BOOL enable/disable stenciling */
+    D3DRENDERSTATE_STENCILFAIL        = 53,   /* D3DSTENCILOP to do if stencil test fails */
+    D3DRENDERSTATE_STENCILZFAIL       = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
+    D3DRENDERSTATE_STENCILPASS        = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
+    D3DRENDERSTATE_STENCILFUNC        = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
+    D3DRENDERSTATE_STENCILREF         = 57,   /* Reference value used in stencil test */
+    D3DRENDERSTATE_STENCILMASK        = 58,   /* Mask value used in stencil test */
+    D3DRENDERSTATE_STENCILWRITEMASK   = 59,   /* Write mask applied to values written to stencil buffer */
+    D3DRENDERSTATE_TEXTUREFACTOR      = 60,   /* D3DCOLOR used for multi-texture blend */
+    D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...  */
+    D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
+    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
+    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
+    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
+    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
+    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
+    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
+    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
+    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
+    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
+    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
+    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
+    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
+    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
+    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
+    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
+    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
+    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
+    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
+    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
+    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
+    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
+    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
+    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
+    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
+    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
+    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
+    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
+    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
+    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
+    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,
+
+    /*
+     * 128 values [128, 255] are reserved for texture coordinate wrap flags.
+     * These are constructed with the D3DWRAP_U and D3DWRAP_V macros. Using
+     * a flags word preserves forward compatibility with texture coordinates
+     * that are >2D.
+     */
+    D3DRENDERSTATE_WRAP0              = 128,  /* wrap for 1st texture coord. set */
+    D3DRENDERSTATE_WRAP1              = 129,  /* wrap for 2nd texture coord. set */
+    D3DRENDERSTATE_WRAP2              = 130,  /* wrap for 3rd texture coord. set */
+    D3DRENDERSTATE_WRAP3              = 131,  /* wrap for 4th texture coord. set */
+    D3DRENDERSTATE_WRAP4              = 132,  /* wrap for 5th texture coord. set */
+    D3DRENDERSTATE_WRAP5              = 133,  /* wrap for 6th texture coord. set */
+    D3DRENDERSTATE_WRAP6              = 134,  /* wrap for 7th texture coord. set */
+    D3DRENDERSTATE_WRAP7              = 135,  /* wrap for 8th texture coord. set */
+    D3DRENDERSTATE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
+} D3DRENDERSTATETYPE;
+
+// For back-compatibility with legacy compilations
+#define D3DRENDERSTATE_BLENDENABLE      D3DRENDERSTATE_ALPHABLENDENABLE
+
+
+// Bias to apply to the texture coordinate set to apply a wrap to.
+#define D3DRENDERSTATE_WRAPBIAS                 128UL
+
+/* Flags to construct the WRAP render states */
+#define D3DWRAP_U   0x00000001L
+#define D3DWRAP_V   0x00000002L
+
+
+#define D3DRENDERSTATE_STIPPLEPATTERN(y) (D3DRENDERSTATE_STIPPLEPATTERN00 + (y))
+
+typedef struct _D3DSTATE {
+    union {
+    D3DTRANSFORMSTATETYPE   dtstTransformStateType;
+    D3DLIGHTSTATETYPE   dlstLightStateType;
+    D3DRENDERSTATETYPE  drstRenderStateType;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    DWORD           dwArg[1];
+    D3DVALUE        dvArg[1];
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+} D3DSTATE, *LPD3DSTATE;
+
+/*
+ * Operation used to load matrices
+ * hDstMat = hSrcMat
+ */
+typedef struct _D3DMATRIXLOAD {
+    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
+    D3DMATRIXHANDLE hSrcMatrix;   /* Source matrix */
+} D3DMATRIXLOAD, *LPD3DMATRIXLOAD;
+
+/*
+ * Operation used to multiply matrices
+ * hDstMat = hSrcMat1 * hSrcMat2
+ */
+typedef struct _D3DMATRIXMULTIPLY {
+    D3DMATRIXHANDLE hDestMatrix;   /* Destination matrix */
+    D3DMATRIXHANDLE hSrcMatrix1;  /* First source matrix */
+    D3DMATRIXHANDLE hSrcMatrix2;  /* Second source matrix */
+} D3DMATRIXMULTIPLY, *LPD3DMATRIXMULTIPLY;
+
+/*
+ * Operation used to transform and light vertices.
+ */
+typedef struct _D3DPROCESSVERTICES {
+    DWORD        dwFlags;    /* Do we transform or light or just copy? */
+    WORD         wStart;     /* Index to first vertex in source */
+    WORD         wDest;      /* Index to first vertex in local buffer */
+    DWORD        dwCount;    /* Number of vertices to be processed */
+    DWORD    dwReserved; /* Must be zero */
+} D3DPROCESSVERTICES, *LPD3DPROCESSVERTICES;
+
+#define D3DPROCESSVERTICES_TRANSFORMLIGHT   0x00000000L
+#define D3DPROCESSVERTICES_TRANSFORM        0x00000001L
+#define D3DPROCESSVERTICES_COPY         0x00000002L
+#define D3DPROCESSVERTICES_OPMASK       0x00000007L
+
+#define D3DPROCESSVERTICES_UPDATEEXTENTS    0x00000008L
+#define D3DPROCESSVERTICES_NOCOLOR      0x00000010L
+
+
+
+
+/*
+ * State enumerants for per-stage texture processing.
+ */
+typedef enum _D3DTEXTURESTAGESTATETYPE
+{
+    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
+    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
+    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
+    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
+    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
+    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
+    D3DTSS_BUMPENVMAT00   =  7, /* D3DVALUE (bump mapping matrix) */
+    D3DTSS_BUMPENVMAT01   =  8, /* D3DVALUE (bump mapping matrix) */
+    D3DTSS_BUMPENVMAT10   =  9, /* D3DVALUE (bump mapping matrix) */
+    D3DTSS_BUMPENVMAT11   = 10, /* D3DVALUE (bump mapping matrix) */
+    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
+    D3DTSS_ADDRESS        = 12, /* D3DTEXTUREADDRESS for both coordinates */
+    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
+    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
+    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
+    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREMAGFILTER filter to use for magnification */
+    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREMINFILTER filter to use for minification */
+    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREMIPFILTER filter to use between mipmaps during minification */
+    D3DTSS_MIPMAPLODBIAS  = 19, /* D3DVALUE Mipmap LOD bias */
+    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
+    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
+    D3DTSS_BUMPENVLSCALE  = 22, /* D3DVALUE scale for bump map luminance */
+    D3DTSS_BUMPENVLOFFSET = 23, /* D3DVALUE offset for bump map luminance */
+    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
+} D3DTEXTURESTAGESTATETYPE;
+
+/*
+ * Enumerations for COLOROP and ALPHAOP texture blending operations set in
+ * texture processing stage controls in D3DRENDERSTATE.
+ */
+typedef enum _D3DTEXTUREOP
+{
+// Control
+    D3DTOP_DISABLE    = 1,      // disables stage
+    D3DTOP_SELECTARG1 = 2,      // the default
+    D3DTOP_SELECTARG2 = 3,
+
+// Modulate
+    D3DTOP_MODULATE   = 4,      // multiply args together
+    D3DTOP_MODULATE2X = 5,      // multiply and  1 bit
+    D3DTOP_MODULATE4X = 6,      // multiply and  2 bits
+
+// Add
+    D3DTOP_ADD          =  7,   // add arguments together
+    D3DTOP_ADDSIGNED    =  8,   // add with -0.5 bias
+    D3DTOP_ADDSIGNED2X  =  9,   // as above but left  1 bit
+    D3DTOP_SUBTRACT     = 10,   // Arg1 - Arg2, with no saturation
+    D3DTOP_ADDSMOOTH    = 11,   // add 2 args, subtract product
+                                // Arg1 + Arg2 - Arg1*Arg2
+                                // = Arg1 + (1-Arg1)*Arg2
+
+// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
+    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
+    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
+    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR
+    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
+    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
+    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color
+
+// Specular mapping
+    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
+    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
+                                            // COLOROP only
+    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
+                                            // COLOROP only
+    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
+                                            // COLOROP only
+    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
+                                            // COLOROP only
+
+// Bump mapping
+    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
+    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel
+    // This can do either diffuse or specular bump mapping with correct input.
+    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
+    // where each component has been scaled and offset to make it signed.
+    // The result is replicated into all four (including alpha) channels.
+    // This is a valid COLOROP only.
+    D3DTOP_DOTPRODUCT3          = 24,
+
+    D3DTOP_FORCE_DWORD = 0x7fffffff,
+} D3DTEXTUREOP;
+
+/*
+ * Values for COLORARG1,2 and ALPHAARG1,2 texture blending operations
+ * set in texture processing stage controls in D3DRENDERSTATE.
+ */
+#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
+#define D3DTA_DIFFUSE           0x00000000  // select diffuse color
+#define D3DTA_CURRENT           0x00000001  // select result of previous stage
+#define D3DTA_TEXTURE           0x00000002  // select texture color
+#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR
+
+#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x
+#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components
+
+/*
+ *  IDirect3DTexture2 State Filter Types
+ */
+typedef enum _D3DTEXTUREMAGFILTER
+{
+    D3DTFG_POINT        = 1,    // nearest
+    D3DTFG_LINEAR       = 2,    // linear interpolation
+    D3DTFG_FLATCUBIC    = 3,    // cubic
+    D3DTFG_GAUSSIANCUBIC = 4,   // different cubic kernel
+    D3DTFG_ANISOTROPIC  = 5,    //
+    D3DTFG_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
+} D3DTEXTUREMAGFILTER;
+
+typedef enum _D3DTEXTUREMINFILTER
+{
+    D3DTFN_POINT        = 1,    // nearest
+    D3DTFN_LINEAR       = 2,    // linear interpolation
+    D3DTFN_ANISOTROPIC  = 3,    //
+    D3DTFN_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
+} D3DTEXTUREMINFILTER;
+
+typedef enum _D3DTEXTUREMIPFILTER
+{
+    D3DTFP_NONE         = 1,    // mipmapping disabled (use MAG filter)
+    D3DTFP_POINT        = 2,    // nearest
+    D3DTFP_LINEAR       = 3,    // linear interpolation
+    D3DTFP_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
+} D3DTEXTUREMIPFILTER;
+
+
+/*
+ * Triangle flags
+ */
+
+/*
+ * Tri strip and fan flags.
+ * START loads all three vertices
+ * EVEN and ODD load just v3 with even or odd culling
+ * START_FLAT contains a count from 0 to 29 that allows the
+ * whole strip or fan to be culled in one hit.
+ * e.g. for a quad len = 1
+ */
+#define D3DTRIFLAG_START            0x00000000L
+#define D3DTRIFLAG_STARTFLAT(len) (len)     /* 0 < len < 30 */
+#define D3DTRIFLAG_ODD              0x0000001eL
+#define D3DTRIFLAG_EVEN             0x0000001fL
+
+/*
+ * Triangle edge flags
+ * enable edges for wireframe or antialiasing
+ */
+#define D3DTRIFLAG_EDGEENABLE1          0x00000100L /* v0-v1 edge */
+#define D3DTRIFLAG_EDGEENABLE2          0x00000200L /* v1-v2 edge */
+#define D3DTRIFLAG_EDGEENABLE3          0x00000400L /* v2-v0 edge */
+#define D3DTRIFLAG_EDGEENABLETRIANGLE \
+        (D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3)
+
+/*
+ * Primitive structures and related defines.  Vertex offsets are to types
+ * D3DVERTEX, D3DLVERTEX, or D3DTLVERTEX.
+ */
+
+/*
+ * Triangle list primitive structure
+ */
+typedef struct _D3DTRIANGLE {
+    union {
+    WORD    v1;            /* Vertex indices */
+    WORD    wV1;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    WORD    v2;
+    WORD    wV2;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+    union {
+    WORD    v3;
+    WORD    wV3;
+#if defined(NONAMELESSUNION)
+    } u3;
+#else
+    };
+#endif
+    WORD        wFlags;       /* Edge (and other) flags */
+} D3DTRIANGLE, *LPD3DTRIANGLE;
+
+/*
+ * Line list structure.
+ * The instruction count defines the number of line segments.
+ */
+typedef struct _D3DLINE {
+    union {
+    WORD    v1;            /* Vertex indices */
+    WORD    wV1;
+#if defined(NONAMELESSUNION)
+    } u1;
+#else
+    };
+#endif
+    union {
+    WORD    v2;
+    WORD    wV2;
+#if defined(NONAMELESSUNION)
+    } u2;
+#else
+    };
+#endif
+} D3DLINE, *LPD3DLINE;
+
+/*
+ * Span structure
+ * Spans join a list of points with the same y value.
+ * If the y value changes, a new span is started.
+ */
+typedef struct _D3DSPAN {
+    WORD    wCount; /* Number of spans */
+    WORD    wFirst; /* Index to first vertex */
+} D3DSPAN, *LPD3DSPAN;
+
+/*
+ * Point structure
+ */
+typedef struct _D3DPOINT {
+    WORD    wCount;     /* number of points     */
+    WORD    wFirst;     /* index to first vertex    */
+} D3DPOINT, *LPD3DPOINT;
+
+
+/*
+ * Forward branch structure.
+ * Mask is logically anded with the driver status mask
+ * if the result equals 'value', the branch is taken.
+ */
+typedef struct _D3DBRANCH {
+    DWORD   dwMask;     /* Bitmask against D3D status */
+    DWORD   dwValue;
+    BOOL    bNegate;        /* TRUE to negate comparison */
+    DWORD   dwOffset;   /* How far to branch forward (0 for exit)*/
+} D3DBRANCH, *LPD3DBRANCH;
+
+/*
+ * Status used for set status instruction.
+ * The D3D status is initialised on device creation
+ * and is modified by all execute calls.
+ */
+typedef struct _D3DSTATUS {
+    DWORD       dwFlags;    /* Do we set extents or status */
+    DWORD   dwStatus;   /* D3D status */
+    D3DRECT drExtent;
+} D3DSTATUS, *LPD3DSTATUS;
+
+#define D3DSETSTATUS_STATUS     0x00000001L
+#define D3DSETSTATUS_EXTENTS        0x00000002L
+#define D3DSETSTATUS_ALL    (D3DSETSTATUS_STATUS | D3DSETSTATUS_EXTENTS)
+
+typedef struct _D3DCLIPSTATUS {
+    DWORD dwFlags; /* Do we set 2d extents, 3D extents or status */
+    DWORD dwStatus; /* Clip status */
+    float minx, maxx; /* X extents */
+    float miny, maxy; /* Y extents */
+    float minz, maxz; /* Z extents */
+} D3DCLIPSTATUS, *LPD3DCLIPSTATUS;
+
+#define D3DCLIPSTATUS_STATUS        0x00000001L
+#define D3DCLIPSTATUS_EXTENTS2      0x00000002L
+#define D3DCLIPSTATUS_EXTENTS3      0x00000004L
+
+/*
+ * Statistics structure
+ */
+typedef struct _D3DSTATS {
+    DWORD        dwSize;
+    DWORD        dwTrianglesDrawn;
+    DWORD        dwLinesDrawn;
+    DWORD        dwPointsDrawn;
+    DWORD        dwSpansDrawn;
+    DWORD        dwVerticesProcessed;
+} D3DSTATS, *LPD3DSTATS;
+
+/*
+ * Execute options.
+ * When calling using D3DEXECUTE_UNCLIPPED all the primitives
+ * inside the buffer must be contained within the viewport.
+ */
+#define D3DEXECUTE_CLIPPED       0x00000001l
+#define D3DEXECUTE_UNCLIPPED     0x00000002l
+
+typedef struct _D3DEXECUTEDATA {
+    DWORD       dwSize;
+    DWORD       dwVertexOffset;
+    DWORD       dwVertexCount;
+    DWORD       dwInstructionOffset;
+    DWORD       dwInstructionLength;
+    DWORD       dwHVertexOffset;
+    D3DSTATUS   dsStatus;   /* Status after execute */
+} D3DEXECUTEDATA, *LPD3DEXECUTEDATA;
+
+/*
+ * Palette flags.
+ * This are or'ed with the peFlags in the PALETTEENTRYs passed to DirectDraw.
+ */
+#define D3DPAL_FREE 0x00    /* Renderer may use this entry freely */
+#define D3DPAL_READONLY 0x40    /* Renderer may not set this entry */
+#define D3DPAL_RESERVED 0x80    /* Renderer may not use this entry */
+
+
+
+typedef struct _D3DVERTEXBUFFERDESC {
+    DWORD dwSize;
+    DWORD dwCaps;
+    DWORD dwFVF;
+    DWORD dwNumVertices;
+} D3DVERTEXBUFFERDESC, *LPD3DVERTEXBUFFERDESC;
+
+/* These correspond to DDSCAPS_* flags */
+#define D3DVBCAPS_SYSTEMMEMORY      0x00000800l
+#define D3DVBCAPS_WRITEONLY         0x00010000l
+#define D3DVBCAPS_OPTIMIZED         0x80000000l
+
+/* Vertex Operations for ProcessVertices */
+#define D3DVOP_LIGHT       (1 << 10)
+#define D3DVOP_TRANSFORM   (1 << 0)
+#define D3DVOP_CLIP        (1 << 2)
+#define D3DVOP_EXTENTS     (1 << 3)
+
+//-------------------------------------------------------------------
+
+// Flexible vertex format bits
+//
+#define D3DFVF_RESERVED0        0x001
+#define D3DFVF_POSITION_MASK    0x00E
+#define D3DFVF_XYZ              0x002
+#define D3DFVF_XYZRHW           0x004
+#define D3DFVF_NORMAL           0x010
+#define D3DFVF_RESERVED1        0x020
+#define D3DFVF_DIFFUSE          0x040
+#define D3DFVF_SPECULAR         0x080
+
+#define D3DFVF_TEXCOUNT_MASK    0xf00
+#define D3DFVF_TEXCOUNT_SHIFT   8
+#define D3DFVF_TEX0             0x000
+#define D3DFVF_TEX1             0x100
+#define D3DFVF_TEX2             0x200
+#define D3DFVF_TEX3             0x300
+#define D3DFVF_TEX4             0x400
+#define D3DFVF_TEX5             0x500
+#define D3DFVF_TEX6             0x600
+#define D3DFVF_TEX7             0x700
+#define D3DFVF_TEX8             0x800
+
+#define D3DFVF_RESERVED2        0xf000  // 4 reserved bits
+
+#define D3DFVF_VERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )
+#define D3DFVF_LVERTEX ( D3DFVF_XYZ | D3DFVF_RESERVED1 | D3DFVF_DIFFUSE | \
+                         D3DFVF_SPECULAR | D3DFVF_TEX1 )
+#define D3DFVF_TLVERTEX ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | \
+                          D3DFVF_TEX1 )
+
+typedef struct _D3DDP_PTRSTRIDE
+{
+    LPVOID lpvData;
+    DWORD  dwStride;
+} D3DDP_PTRSTRIDE;
+
+#define D3DDP_MAXTEXCOORD 8
+
+typedef struct _D3DDRAWPRIMITIVESTRIDEDDATA
+{
+    D3DDP_PTRSTRIDE position;
+    D3DDP_PTRSTRIDE normal;
+    D3DDP_PTRSTRIDE diffuse;
+    D3DDP_PTRSTRIDE specular;
+    D3DDP_PTRSTRIDE textureCoords[D3DDP_MAXTEXCOORD];
+} D3DDRAWPRIMITIVESTRIDEDDATA, *LPD3DDRAWPRIMITIVESTRIDEDDATA;
+//---------------------------------------------------------------------
+// ComputeSphereVisibility return values
+//
+#define D3DVIS_INSIDE_FRUSTUM       0
+#define D3DVIS_INTERSECT_FRUSTUM    1
+#define D3DVIS_OUTSIDE_FRUSTUM      2
+#define D3DVIS_INSIDE_LEFT          0
+#define D3DVIS_INTERSECT_LEFT       (1 << 2)
+#define D3DVIS_OUTSIDE_LEFT         (2 << 2)
+#define D3DVIS_INSIDE_RIGHT         0
+#define D3DVIS_INTERSECT_RIGHT      (1 << 4)
+#define D3DVIS_OUTSIDE_RIGHT        (2 << 4)
+#define D3DVIS_INSIDE_TOP           0
+#define D3DVIS_INTERSECT_TOP        (1 << 6)
+#define D3DVIS_OUTSIDE_TOP          (2 << 6)
+#define D3DVIS_INSIDE_BOTTOM        0
+#define D3DVIS_INTERSECT_BOTTOM     (1 << 8)
+#define D3DVIS_OUTSIDE_BOTTOM       (2 << 8)
+#define D3DVIS_INSIDE_NEAR          0
+#define D3DVIS_INTERSECT_NEAR       (1 << 10)
+#define D3DVIS_OUTSIDE_NEAR         (2 << 10)
+#define D3DVIS_INSIDE_FAR           0
+#define D3DVIS_INTERSECT_FAR        (1 << 12)
+#define D3DVIS_OUTSIDE_FAR          (2 << 12)
+
+#define D3DVIS_MASK_FRUSTUM         (3 << 0)
+#define D3DVIS_MASK_LEFT            (3 << 2)
+#define D3DVIS_MASK_RIGHT           (3 << 4)
+#define D3DVIS_MASK_TOP             (3 << 6)
+#define D3DVIS_MASK_BOTTOM          (3 << 8)
+#define D3DVIS_MASK_NEAR            (3 << 10)
+#define D3DVIS_MASK_FAR             (3 << 12)
+
+
+#pragma pack()
+#endif /* _D3DTYPES_H_ */
+
diff -ruN SDL-1.2.13/include/ddraw.h SDL-1.2.13_OOx64/include/ddraw.h
--- SDL-1.2.13/include/ddraw.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/ddraw.h	1999-11-19 17:32:22 +0000
@@ -0,0 +1,4844 @@
+/*==========================================================================;
+ *
+ *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
+ *
+ *  File:	ddraw.h
+ *  Content:	DirectDraw include file
+ *
+ ***************************************************************************/
+
+#ifndef __DDRAW_INCLUDED__
+#define __DDRAW_INCLUDED__
+
+/*
+ * If you wish an application built against the newest version of DirectDraw
+ * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
+ * to be the earlies version of DirectDraw you wish to run against. For,
+ * example if you wish an application to run against a DX 3 runtime define
+ * DIRECTDRAW_VERSION to be 0x0300.
+ */
+#ifndef   DIRECTDRAW_VERSION
+#define   DIRECTDRAW_VERSION 0x0600
+#endif /* DIRECTDRAW_VERSION */
+
+#if defined( _WIN32 )  && !defined( _NO_COM )
+#define COM_NO_WINDOWS_H
+#include <objbase.h>
+#else
+#define IUnknown	    void
+#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
+	#define CO_E_NOTINITIALIZED 0x800401F0L
+#endif
+#endif
+
+#define _FACDD	0x876
+#define MAKE_DDHRESULT( code )	MAKE_HRESULT( 1, _FACDD, code )
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//
+// For compilers that don't support nameless unions, do a
+//
+// #define NONAMELESSUNION
+//
+// before #include <ddraw.h>
+//
+#ifndef DUMMYUNIONNAMEN
+#if defined(__cplusplus) || !defined(NONAMELESSUNION)
+#define DUMMYUNIONNAMEN(n)
+#else
+#define DUMMYUNIONNAMEN(n)      u##n
+#endif
+#endif
+
+#ifndef MAKEFOURCC
+    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
+                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
+                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
+#endif //defined(MAKEFOURCC)
+
+/*
+ * FOURCC codes for DX compressed-texture pixel formats
+ */
+#define FOURCC_DXT1  (MAKEFOURCC('D','X','T','1'))
+#define FOURCC_DXT2  (MAKEFOURCC('D','X','T','2'))
+#define FOURCC_DXT3  (MAKEFOURCC('D','X','T','3'))
+#define FOURCC_DXT4  (MAKEFOURCC('D','X','T','4'))
+#define FOURCC_DXT5  (MAKEFOURCC('D','X','T','5'))
+
+/*
+ * GUIDS used by DirectDraw objects
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+
+DEFINE_GUID( CLSID_DirectDraw,			0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
+DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
+DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
+DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
+DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
+DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
+DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
+DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
+DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );
+
+DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
+DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
+DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
+DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
+
+#endif
+
+/*============================================================================
+ *
+ * DirectDraw Structures
+ *
+ * Various structures used to invoke DirectDraw.
+ *
+ *==========================================================================*/
+
+struct IDirectDraw;
+struct IDirectDrawSurface;
+struct IDirectDrawPalette;
+struct IDirectDrawClipper;
+
+typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
+typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
+typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
+typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
+typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
+typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
+typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;
+
+typedef struct IDirectDrawPalette		FAR *LPDIRECTDRAWPALETTE;
+typedef struct IDirectDrawClipper		FAR *LPDIRECTDRAWCLIPPER;
+typedef struct IDirectDrawColorControl		FAR *LPDIRECTDRAWCOLORCONTROL;
+typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;
+
+typedef struct _DDFXROP			FAR *LPDDFXROP;
+typedef struct _DDSURFACEDESC		FAR *LPDDSURFACEDESC;
+typedef struct _DDSURFACEDESC2		FAR *LPDDSURFACEDESC2;
+typedef struct _DDCOLORCONTROL 		FAR *LPDDCOLORCONTROL;
+
+/*
+ * API's
+ */
+#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
+//#if defined( _WIN32 ) && !defined( _NO_ENUM )
+    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
+    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
+    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
+    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
+    /*
+     * Protect against old SDKs
+     */
+    #ifndef SM_CMONITORS
+        #define HMONITOR    HANDLE
+    #endif
+    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
+    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
+    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
+    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
+    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
+    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
+
+    #ifdef UNICODE
+	typedef LPDDENUMCALLBACKW 	    LPDDENUMCALLBACK;
+	#define DirectDrawEnumerate	    DirectDrawEnumerateW
+	typedef LPDDENUMCALLBACKEXW 	    LPDDENUMCALLBACKEX;
+	typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
+	#define DirectDrawEnumerateEx	    DirectDrawEnumerateExW
+    #else
+	typedef LPDDENUMCALLBACKA 	    LPDDENUMCALLBACK;
+	#define DirectDrawEnumerate	    DirectDrawEnumerateA
+	typedef LPDDENUMCALLBACKEXA 	    LPDDENUMCALLBACKEX;
+    	typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
+        #define DirectDrawEnumerateEx	    DirectDrawEnumerateExA
+    #endif
+    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
+    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
+#endif
+/*
+ * Flags for DirectDrawEnumerateEx
+ * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
+ * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
+ * By default, only the primary display device is enumerated.
+ * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
+ */
+
+/*
+ * This flag causes enumeration of any GDI display devices which are part of
+ * the Windows Desktop
+ */
+#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L
+
+/*
+ * This flag causes enumeration of any GDI display devices which are not
+ * part of the Windows Desktop
+ */
+#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L
+
+/*
+ * This flag causes enumeration of non-display devices
+ */
+#define DDENUM_NONDISPLAYDEVICES            0x00000004L
+
+
+#define REGSTR_KEY_DDHW_DESCRIPTION	"Description"
+#define REGSTR_KEY_DDHW_DRIVERNAME	"DriverName"
+#define REGSTR_PATH_DDHW		"Hardware\\DirectDrawDrivers"
+
+#define DDCREATE_HARDWAREONLY		0x00000001l
+#define DDCREATE_EMULATIONONLY		0x00000002l
+
+#if defined(WINNT) || !defined(WIN32)
+typedef long HRESULT;
+#endif
+
+//#ifndef WINNT
+typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
+typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
+typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
+typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
+//#endif
+
+/*
+ * Generic pixel format with 8-bit RGB and alpha components
+ */
+typedef struct _DDRGBA
+{
+    BYTE red;
+    BYTE green;
+    BYTE blue;
+    BYTE alpha;
+} DDRGBA;
+
+typedef DDRGBA FAR *LPDDRGBA;
+
+/*
+ * DDCOLORKEY
+ */
+typedef struct _DDCOLORKEY
+{
+    DWORD	dwColorSpaceLowValue;	// low boundary of color space that is to
+					// be treated as Color Key, inclusive
+    DWORD	dwColorSpaceHighValue;	// high boundary of color space that is
+					// to be treated as Color Key, inclusive
+} DDCOLORKEY;
+
+typedef DDCOLORKEY FAR* LPDDCOLORKEY;
+
+/*
+ * DDBLTFX
+ * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
+ */
+typedef struct _DDBLTFX
+{
+    DWORD	dwSize;				// size of structure
+    DWORD	dwDDFX;				// FX operations
+    DWORD	dwROP;				// Win32 raster operations
+    DWORD	dwDDROP;			// Raster operations new for DirectDraw
+    DWORD	dwRotationAngle;		// Rotation angle for blt
+    DWORD	dwZBufferOpCode;		// ZBuffer compares
+    DWORD	dwZBufferLow;			// Low limit of Z buffer
+    DWORD	dwZBufferHigh;			// High limit of Z buffer
+    DWORD	dwZBufferBaseDest;		// Destination base value
+    DWORD	dwZDestConstBitDepth;		// Bit depth used to specify Z constant for destination
+    union
+    {
+	DWORD	dwZDestConst;			// Constant to use as Z buffer for dest
+	LPDIRECTDRAWSURFACE lpDDSZBufferDest;	// Surface to use as Z buffer for dest
+    } DUMMYUNIONNAMEN(1);
+    DWORD	dwZSrcConstBitDepth;		// Bit depth used to specify Z constant for source
+    union
+    {
+	DWORD	dwZSrcConst;			// Constant to use as Z buffer for src
+	LPDIRECTDRAWSURFACE lpDDSZBufferSrc;	// Surface to use as Z buffer for src
+    } DUMMYUNIONNAMEN(2);
+    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
+    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
+    DWORD	dwReserved;
+    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
+    union
+    {
+	DWORD	dwAlphaDestConst;		// Constant to use as Alpha Channel
+	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as Alpha Channel
+    } DUMMYUNIONNAMEN(3);
+    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
+    union
+    {
+	DWORD	dwAlphaSrcConst;		// Constant to use as Alpha Channel
+	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as Alpha Channel
+    } DUMMYUNIONNAMEN(4);
+    union
+    {
+	DWORD	dwFillColor;			// color in RGB or Palettized
+	DWORD   dwFillDepth;                    // depth value for z-buffer
+	DWORD	dwFillPixel;			// pixel value for RGBA or RGBZ
+	LPDIRECTDRAWSURFACE lpDDSPattern;	// Surface to use as pattern
+    } DUMMYUNIONNAMEN(5);
+    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
+    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
+} DDBLTFX;
+
+typedef DDBLTFX FAR* LPDDBLTFX;
+
+
+/*
+ * DDSCAPS
+ */
+typedef struct _DDSCAPS
+{
+    DWORD	dwCaps;		// capabilities of surface wanted
+} DDSCAPS;
+
+typedef DDSCAPS FAR* LPDDSCAPS;
+
+
+/*
+ * DDOSCAPS
+ */
+typedef struct _DDOSCAPS
+{
+    DWORD	dwCaps;		// capabilities of surface wanted
+} DDOSCAPS;
+
+typedef DDOSCAPS FAR* LPDDOSCAPS;
+
+/*
+ * This structure is used internally by DirectDraw.
+ */
+typedef struct _DDSCAPSEX
+{
+    DWORD       dwCaps2;
+    DWORD       dwCaps3;
+    DWORD       dwCaps4;
+} DDSCAPSEX, FAR * LPDDSCAPSEX;
+
+/*
+ * DDSCAPS2
+ */
+typedef struct _DDSCAPS2
+{
+    DWORD	dwCaps;		// capabilities of surface wanted
+    DWORD       dwCaps2;
+    DWORD       dwCaps3;
+    DWORD       dwCaps4;
+} DDSCAPS2;
+
+typedef DDSCAPS2 FAR* LPDDSCAPS2;
+
+/*
+ * DDCAPS
+ */
+#define DD_ROP_SPACE		(256/32)	// space required to store ROP array
+
+/*
+ * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
+ * It is present for back compatability.
+ */
+typedef struct _DDCAPS_DX3
+{
+    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
+    DWORD	dwCaps;			// driver specific capabilities
+    DWORD	dwCaps2;		// more driver specific capabilites
+    DWORD	dwCKeyCaps;		// color key capabilities of the surface
+    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
+    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
+    DWORD	dwPalCaps;		// palette capabilities
+    DWORD	dwSVCaps;		// stereo vision capabilities
+    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
+    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
+    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
+    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
+    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
+    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
+    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
+    DWORD	dwVidMemTotal;		// total amount of video memory
+    DWORD	dwVidMemFree;		// amount of free video memory
+    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
+    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
+    DWORD	dwNumFourCCCodes;	// number of four cc codes
+    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
+    DWORD	dwAlignSizeSrc;		// source rectangle byte size
+    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
+    DWORD	dwAlignSizeDest;	// dest rectangle byte size
+    DWORD	dwAlignStrideAlign;	// stride alignment
+    DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
+    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
+    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+    DWORD	dwReserved1;		// reserved
+    DWORD	dwReserved2;		// reserved
+    DWORD	dwReserved3;		// reserved
+    DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
+    DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
+    DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
+    DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
+    DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
+    DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
+    DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
+    DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
+    DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
+    DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
+    DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
+    DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
+    DWORD	dwReserved4;		// reserved
+    DWORD	dwReserved5;		// reserved
+    DWORD	dwReserved6;		// reserved
+} DDCAPS_DX3;
+typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;
+
+/*
+ * This structure is the DDCAPS structure as it was in version 5 of Direct X.
+ * It is present for back compatability.
+ */
+typedef struct _DDCAPS_DX5
+{
+/*  0*/ DWORD	dwSize;			// size of the DDDRIVERCAPS structure
+/*  4*/ DWORD	dwCaps;			// driver specific capabilities
+/*  8*/ DWORD	dwCaps2;		// more driver specific capabilites
+/*  c*/ DWORD	dwCKeyCaps;		// color key capabilities of the surface
+/* 10*/ DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
+/* 14*/ DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
+/* 18*/ DWORD	dwPalCaps;		// palette capabilities
+/* 1c*/ DWORD	dwSVCaps;		// stereo vision capabilities
+/* 20*/ DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
+/* 24*/ DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
+/* 28*/ DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
+/* 2c*/ DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
+/* 30*/ DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
+/* 34*/ DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
+/* 38*/ DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
+/* 3c*/ DWORD	dwVidMemTotal;		// total amount of video memory
+/* 40*/ DWORD	dwVidMemFree;		// amount of free video memory
+/* 44*/ DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
+/* 48*/ DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
+/* 4c*/ DWORD	dwNumFourCCCodes;	// number of four cc codes
+/* 50*/ DWORD	dwAlignBoundarySrc;	// source rectangle alignment
+/* 54*/ DWORD	dwAlignSizeSrc;		// source rectangle byte size
+/* 58*/ DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
+/* 5c*/ DWORD	dwAlignSizeDest;	// dest rectangle byte size
+/* 60*/ DWORD	dwAlignStrideAlign;	// stride alignment
+/* 64*/ DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
+/* 84*/ DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
+/* 88*/ DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 8c*/ DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 90*/ DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 94*/ DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 98*/ DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 9c*/ DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* a0*/ DWORD	dwReserved1;		// reserved
+/* a4*/ DWORD	dwReserved2;		// reserved
+/* a8*/ DWORD	dwReserved3;		// reserved
+/* ac*/ DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
+/* b0*/ DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
+/* b4*/ DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
+/* b8*/ DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
+/* d8*/ DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
+/* dc*/ DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
+/* e0*/ DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
+/* e4*/ DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
+/*104*/ DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
+/*108*/ DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
+/*10c*/ DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
+/*110*/ DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
+// Members added for DX5:
+/*130*/ DWORD	dwMaxVideoPorts;	// maximum number of usable video ports
+/*134*/ DWORD	dwCurrVideoPorts;	// current number of video ports used
+/*138*/ DWORD	dwSVBCaps2;		// more driver specific capabilities for System->Vmem blts
+/*13c*/ DWORD	dwNLVBCaps;		  // driver specific capabilities for non-local->local vidmem blts
+/*140*/ DWORD	dwNLVBCaps2;		  // more driver specific capabilities non-local->local vidmem blts
+/*144*/ DWORD	dwNLVBCKeyCaps;		  // driver color key capabilities for non-local->local vidmem blts
+/*148*/ DWORD	dwNLVBFXCaps;		  // driver FX capabilities for non-local->local blts
+/*14c*/ DWORD	dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
+} DDCAPS_DX5;
+typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;
+
+typedef struct _DDCAPS_DX6
+{
+/*  0*/ DWORD	dwSize;			// size of the DDDRIVERCAPS structure
+/*  4*/ DWORD	dwCaps;			// driver specific capabilities
+/*  8*/ DWORD	dwCaps2;		// more driver specific capabilites
+/*  c*/ DWORD	dwCKeyCaps;		// color key capabilities of the surface
+/* 10*/ DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
+/* 14*/ DWORD	dwFXAlphaCaps;		// alpha caps
+/* 18*/ DWORD	dwPalCaps;		// palette capabilities
+/* 1c*/ DWORD	dwSVCaps;		// stereo vision capabilities
+/* 20*/ DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
+/* 24*/ DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
+/* 28*/ DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
+/* 2c*/ DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
+/* 30*/ DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
+/* 34*/ DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
+/* 38*/ DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
+/* 3c*/ DWORD	dwVidMemTotal;		// total amount of video memory
+/* 40*/ DWORD	dwVidMemFree;		// amount of free video memory
+/* 44*/ DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
+/* 48*/ DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
+/* 4c*/ DWORD	dwNumFourCCCodes;	// number of four cc codes
+/* 50*/ DWORD	dwAlignBoundarySrc;	// source rectangle alignment
+/* 54*/ DWORD	dwAlignSizeSrc;		// source rectangle byte size
+/* 58*/ DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
+/* 5c*/ DWORD	dwAlignSizeDest;	// dest rectangle byte size
+/* 60*/ DWORD	dwAlignStrideAlign;	// stride alignment
+/* 64*/ DWORD	dwRops[DD_ROP_SPACE];	// ROPS supported
+/* 84*/ DDSCAPS	ddsOldCaps;             // Was DDSCAPS	ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
+/* 88*/ DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 8c*/ DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 90*/ DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 94*/ DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 98*/ DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* 9c*/ DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
+/* a0*/ DWORD	dwReserved1;		// reserved
+/* a4*/ DWORD	dwReserved2;		// reserved
+/* a8*/ DWORD	dwReserved3;		// reserved
+/* ac*/ DWORD	dwSVBCaps;		// driver specific capabilities for System->Vmem blts
+/* b0*/ DWORD	dwSVBCKeyCaps;		// driver color key capabilities for System->Vmem blts
+/* b4*/ DWORD	dwSVBFXCaps;		// driver FX capabilities for System->Vmem blts
+/* b8*/ DWORD	dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
+/* d8*/ DWORD	dwVSBCaps;		// driver specific capabilities for Vmem->System blts
+/* dc*/ DWORD	dwVSBCKeyCaps;		// driver color key capabilities for Vmem->System blts
+/* e0*/ DWORD	dwVSBFXCaps;		// driver FX capabilities for Vmem->System blts
+/* e4*/ DWORD	dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
+/*104*/ DWORD	dwSSBCaps;		// driver specific capabilities for System->System blts
+/*108*/ DWORD	dwSSBCKeyCaps;		// driver color key capabilities for System->System blts
+/*10c*/ DWORD	dwSSBFXCaps;		// driver FX capabilities for System->System blts
+/*110*/ DWORD	dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
+/*130*/ DWORD	dwMaxVideoPorts;	// maximum number of usable video ports
+/*134*/ DWORD	dwCurrVideoPorts;	// current number of video ports used
+/*138*/ DWORD	dwSVBCaps2;		// more driver specific capabilities for System->Vmem blts
+/*13c*/ DWORD	dwNLVBCaps;		  // driver specific capabilities for non-local->local vidmem blts
+/*140*/ DWORD	dwNLVBCaps2;		  // more driver specific capabilities non-local->local vidmem blts
+/*144*/ DWORD	dwNLVBCKeyCaps;		  // driver color key capabilities for non-local->local vidmem blts
+/*148*/ DWORD	dwNLVBFXCaps;		  // driver FX capabilities for non-local->local blts
+/*14c*/ DWORD	dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
+// Members added for DX6 release
+/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
+} DDCAPS_DX6;
+typedef DDCAPS_DX6 FAR* LPDDCAPS_DX6;
+
+
+#if DIRECTDRAW_VERSION <= 0x300
+    typedef DDCAPS_DX3 DDCAPS;
+#elif DIRECTDRAW_VERSION <= 0x500
+    typedef DDCAPS_DX5 DDCAPS;
+#else
+    typedef DDCAPS_DX6 DDCAPS;
+#endif
+
+typedef DDCAPS FAR* LPDDCAPS;
+
+
+
+/*
+ * DDPIXELFORMAT
+ */
+typedef struct _DDPIXELFORMAT
+{
+    DWORD	dwSize;			// size of structure
+    DWORD	dwFlags;		// pixel format flags
+    DWORD	dwFourCC;		// (FOURCC code)
+    union
+    {
+	DWORD	dwRGBBitCount;		// how many bits per pixel
+	DWORD	dwYUVBitCount;		// how many bits per pixel
+	DWORD	dwZBufferBitDepth;	// how many total bits/pixel in z buffer (including any stencil bits)
+	DWORD	dwAlphaBitDepth;	// how many bits for alpha channels
+	DWORD   dwLuminanceBitCount;	// how many bits per pixel
+        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
+    } DUMMYUNIONNAMEN(1);
+    union
+    {
+	DWORD	dwRBitMask;		// mask for red bit
+	DWORD	dwYBitMask;		// mask for Y bits
+	DWORD   dwStencilBitDepth;	// how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
+	DWORD   dwLuminanceBitMask;	// mask for luminance bits
+        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
+    } DUMMYUNIONNAMEN(2);
+    union
+    {
+	DWORD	dwGBitMask;		// mask for green bits
+	DWORD	dwUBitMask;		// mask for U bits
+	DWORD   dwZBitMask;		// mask for Z bits
+        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
+    } DUMMYUNIONNAMEN(3);
+    union
+    {
+	DWORD	dwBBitMask;		// mask for blue bits
+	DWORD	dwVBitMask;		// mask for V bits
+	DWORD   dwStencilBitMask;	// mask for stencil bits
+        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
+    } DUMMYUNIONNAMEN(4);
+    union
+    {
+	DWORD	dwRGBAlphaBitMask;	// mask for alpha channel
+	DWORD	dwYUVAlphaBitMask;	// mask for alpha channel
+        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
+	DWORD	dwRGBZBitMask;		// mask for Z channel
+	DWORD	dwYUVZBitMask;		// mask for Z channel
+    } DUMMYUNIONNAMEN(5);
+} DDPIXELFORMAT;
+
+typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;
+
+/*
+ * DDOVERLAYFX
+ */
+typedef struct _DDOVERLAYFX
+{
+    DWORD	dwSize;				// size of structure
+    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
+    DWORD	dwAlphaEdgeBlend;		// Constant to use as alpha for edge blend
+    DWORD	dwReserved;
+    DWORD	dwAlphaDestConstBitDepth;	// Bit depth used to specify alpha constant for destination
+    union
+    {
+	DWORD	dwAlphaDestConst;		// Constant to use as alpha channel for dest
+	LPDIRECTDRAWSURFACE lpDDSAlphaDest;	// Surface to use as alpha channel for dest
+    } DUMMYUNIONNAMEN(1);
+    DWORD	dwAlphaSrcConstBitDepth;	// Bit depth used to specify alpha constant for source
+    union
+    {
+	DWORD	dwAlphaSrcConst;		// Constant to use as alpha channel for src
+	LPDIRECTDRAWSURFACE lpDDSAlphaSrc;	// Surface to use as alpha channel for src
+    } DUMMYUNIONNAMEN(2);
+    DDCOLORKEY	dckDestColorkey;		// DestColorkey override
+    DDCOLORKEY	dckSrcColorkey;			// DestColorkey override
+    DWORD       dwDDFX;                         // Overlay FX
+    DWORD	dwFlags;			// flags
+} DDOVERLAYFX;
+
+typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;
+
+
+/*
+ * DDBLTBATCH: BltBatch entry structure
+ */
+typedef struct _DDBLTBATCH
+{
+    LPRECT		lprDest;
+    LPDIRECTDRAWSURFACE	lpDDSSrc;
+    LPRECT		lprSrc;
+    DWORD		dwFlags;
+    LPDDBLTFX		lpDDBltFx;
+} DDBLTBATCH;
+
+typedef DDBLTBATCH FAR * LPDDBLTBATCH;
+
+
+/*
+ * DDGAMMARAMP
+ */
+typedef struct _DDGAMMARAMP
+{
+    WORD                red[256];
+    WORD                green[256];
+    WORD                blue[256];
+} DDGAMMARAMP;
+typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;
+
+/*
+ *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
+ */
+
+#define MAX_DDDEVICEID_STRING		512
+
+typedef struct tagDDDEVICEIDENTIFIER
+{
+    /*
+     * These elements are for presentation to the user only. They should not be used to identify particular
+     * drivers, since this is unreliable and many different strings may be associated with the same
+     * device, and the same driver from different vendors.
+     */
+    char    szDriver[MAX_DDDEVICEID_STRING];
+    char    szDescription[MAX_DDDEVICEID_STRING];
+
+    /*
+     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
+     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
+     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
+     *
+     * This version has the form:
+     *  wProduct = HIWORD(liDriverVersion.HighPart)
+     *  wVersion = LOWORD(liDriverVersion.HighPart)
+     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
+     *  wBuild = LOWORD(liDriverVersion.LowPart)
+     */
+#ifdef _WIN32
+    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
+#else
+    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
+    DWORD   dwDriverVersionHighPart;
+#endif
+
+
+    /*
+     * These elements can be used to identify particular chipsets. Use with extreme caution. 
+     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
+     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
+     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
+     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
+     */
+    DWORD   dwVendorId;
+    DWORD   dwDeviceId;
+    DWORD   dwSubSysId;
+    DWORD   dwRevision;
+
+    /*
+     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
+     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
+     * reprofile the graphics subsystem.
+     * This element can also be used to identify particular problematic drivers.
+     */
+    GUID    guidDeviceIdentifier;
+} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;
+
+/*
+ * Flags for the IDirectDraw4::GetDeviceIdentifier method
+ */
+
+/*
+ * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
+ * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
+ * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
+ * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
+ * of the DirectDraw object involved.
+ */
+#define DDGDI_GETHOSTIDENTIFIER         0x00000001L
+
+
+
+/*
+ * callbacks
+ */
+typedef DWORD	(FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
+#ifdef STREAMING
+typedef DWORD	(FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
+#endif
+
+
+/*
+ * INTERACES FOLLOW:
+ *	IDirectDraw
+ *	IDirectDrawClipper
+ *	IDirectDrawPalette
+ *	IDirectDrawSurface
+ */
+
+/*
+ * IDirectDraw
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDraw
+DECLARE_INTERFACE_( IDirectDraw, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDraw methods ***/
+    STDMETHOD(Compact)(THIS) PURE;
+    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
+    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
+    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
+    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
+    STDMETHOD(FlipToGDISurface)(THIS) PURE;
+    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
+    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
+    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
+    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
+    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
+    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
+    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
+    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
+    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
+#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
+#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
+#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
+#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
+#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
+#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
+#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
+#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
+#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
+#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
+#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
+#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
+#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
+#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
+#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
+#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
+#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
+#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
+#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
+#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
+#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
+#else
+#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
+#define IDirectDraw_AddRef(p)                       (p)->AddRef()
+#define IDirectDraw_Release(p)                      (p)->Release()
+#define IDirectDraw_Compact(p)                      (p)->Compact()
+#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
+#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
+#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
+#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
+#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
+#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
+#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
+#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
+#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
+#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
+#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
+#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
+#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
+#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
+#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
+#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
+#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
+#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
+#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
+#endif
+
+#endif
+
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDraw2
+DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDraw methods ***/
+    STDMETHOD(Compact)(THIS) PURE;
+    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
+    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
+    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
+    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
+    STDMETHOD(FlipToGDISurface)(THIS) PURE;
+    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
+    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
+    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
+    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
+    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
+    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
+    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
+    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
+    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
+    /*** Added in the v2 interface ***/
+    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
+};
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
+#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
+#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
+#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
+#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
+#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
+#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
+#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
+#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
+#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
+#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
+#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
+#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
+#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
+#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
+#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
+#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
+#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
+#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
+#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
+#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
+#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
+#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
+#else
+#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
+#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
+#define IDirectDraw2_Release(p)                      (p)->Release()
+#define IDirectDraw2_Compact(p)                      (p)->Compact()
+#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
+#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
+#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
+#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
+#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
+#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
+#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
+#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
+#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
+#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
+#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
+#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
+#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
+#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
+#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
+#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
+#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
+#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
+#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
+#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
+#endif
+
+#endif
+
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDraw4
+DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDraw methods ***/
+    STDMETHOD(Compact)(THIS) PURE;
+    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
+    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
+    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
+    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
+    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
+    STDMETHOD(FlipToGDISurface)(THIS) PURE;
+    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
+    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
+    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
+    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
+    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
+    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
+    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
+    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
+    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
+    /*** Added in the v2 interface ***/
+    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
+    /*** Added in the V4 Interface ***/
+    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
+    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
+    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
+    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
+};
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
+#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
+#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
+#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
+#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
+#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
+#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
+#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
+#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
+#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
+#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
+#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
+#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
+#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
+#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
+#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
+#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
+#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
+#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
+#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
+#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
+#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
+#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
+#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
+#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
+#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
+#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
+#else
+#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
+#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
+#define IDirectDraw4_Release(p)                      (p)->Release()
+#define IDirectDraw4_Compact(p)                      (p)->Compact()
+#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
+#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
+#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
+#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
+#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
+#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
+#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
+#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
+#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
+#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
+#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
+#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
+#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
+#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
+#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
+#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
+#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
+#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
+#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
+#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
+#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
+#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
+#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
+#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
+#endif
+
+#endif
+
+
+/*
+ * IDirectDrawPalette
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDrawPalette
+DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawPalette methods ***/
+    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
+    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
+    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
+#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
+#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
+#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
+#else
+#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
+#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
+#define IDirectDrawPalette_Release(p)                   (p)->Release()
+#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
+#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
+#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
+#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
+#endif
+
+#endif
+
+
+
+/*
+ * IDirectDrawClipper
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDrawClipper
+DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawClipper methods ***/
+    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
+    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
+    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
+    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
+    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
+#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
+#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
+#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
+#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
+#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
+#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
+#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
+#else
+#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
+#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
+#define IDirectDrawClipper_Release(p)               (p)->Release()
+#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
+#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
+#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
+#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
+#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
+#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
+#endif
+
+#endif
+
+/*
+ * IDirectDrawSurface and related interfaces
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDrawSurface
+DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawSurface methods ***/
+    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
+    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
+    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
+    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
+    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
+    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
+    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
+    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
+    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
+    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
+    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
+    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
+    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
+    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
+    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
+    STDMETHOD(IsLost)(THIS) PURE;
+    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
+    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
+    STDMETHOD(Restore)(THIS) PURE;
+    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
+    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
+    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
+    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
+    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
+    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
+    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
+#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
+#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
+#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
+#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
+#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
+#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
+#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
+#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
+#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
+#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
+#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
+#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
+#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
+#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
+#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
+#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
+#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
+#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
+#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
+#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
+#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
+#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
+#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
+#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
+#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
+#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
+#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
+#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
+#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
+#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
+#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
+#else
+#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
+#define IDirectDrawSurface_Release(p)                   (p)->Release()
+#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
+#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
+#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
+#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
+#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
+#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
+#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
+#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
+#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
+#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
+#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
+#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
+#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
+#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
+#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
+#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
+#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
+#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
+#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
+#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
+#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
+#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
+#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
+#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
+#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
+#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
+#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
+#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
+#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
+#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
+#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
+#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
+#endif
+
+/*
+ * IDirectDrawSurface2 and related interfaces
+ */
+#undef INTERFACE
+#define INTERFACE IDirectDrawSurface2
+DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawSurface methods ***/
+    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
+    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
+    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
+    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
+    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
+    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
+    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
+    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
+    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
+    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
+    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
+    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
+    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
+    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
+    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
+    STDMETHOD(IsLost)(THIS) PURE;
+    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
+    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
+    STDMETHOD(Restore)(THIS) PURE;
+    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
+    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
+    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
+    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
+    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
+    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
+    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
+    /*** Added in the v2 interface ***/
+    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
+    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
+    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
+#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
+#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
+#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
+#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
+#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
+#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
+#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
+#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
+#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
+#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
+#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
+#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
+#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
+#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
+#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
+#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
+#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
+#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
+#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
+#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
+#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
+#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
+#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
+#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
+#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
+#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
+#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
+#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
+#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
+#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
+#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
+#define IDirectDrawSurface2_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
+#define IDirectDrawSurface2_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
+#define IDirectDrawSurface2_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
+#else
+#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
+#define IDirectDrawSurface2_Release(p)                   (p)->Release()
+#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
+#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
+#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
+#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
+#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
+#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
+#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
+#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
+#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
+#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
+#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
+#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
+#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
+#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
+#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
+#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
+#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
+#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
+#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
+#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
+#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
+#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
+#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
+#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
+#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
+#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
+#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
+#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
+#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
+#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
+#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
+#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
+#define IDirectDrawSurface2_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
+#define IDirectDrawSurface2_PageLock(p,a)		 (p)->PageLock(a)
+#define IDirectDrawSurface2_PageUnlock(p,a)		 (p)->PageUnlock(a)
+#endif
+
+/*
+ * IDirectDrawSurface3 and related interfaces
+ */
+#undef INTERFACE
+#define INTERFACE IDirectDrawSurface3
+DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawSurface methods ***/
+    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
+    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
+    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
+    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
+    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
+    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
+    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
+    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
+    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
+    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
+    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
+    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
+    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
+    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
+    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
+    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
+    STDMETHOD(IsLost)(THIS) PURE;
+    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
+    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
+    STDMETHOD(Restore)(THIS) PURE;
+    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
+    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
+    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
+    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
+    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
+    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
+    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
+    /*** Added in the v2 interface ***/
+    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
+    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
+    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
+    /*** Added in the V3 interface ***/
+    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
+#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
+#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
+#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
+#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
+#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
+#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
+#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
+#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
+#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
+#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
+#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
+#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
+#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
+#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
+#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
+#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
+#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
+#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
+#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
+#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
+#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
+#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
+#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
+#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
+#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
+#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
+#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
+#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
+#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
+#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
+#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
+#define IDirectDrawSurface3_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
+#define IDirectDrawSurface3_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
+#define IDirectDrawSurface3_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
+#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)	 (p)->lpVtbl->SetSurfaceDesc(p,a,b)
+#else
+#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
+#define IDirectDrawSurface3_Release(p)                   (p)->Release()
+#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
+#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
+#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
+#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
+#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
+#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
+#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
+#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
+#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
+#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
+#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
+#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
+#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
+#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
+#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
+#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
+#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
+#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
+#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
+#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
+#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
+#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
+#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
+#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
+#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
+#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
+#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
+#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
+#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
+#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
+#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
+#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
+#define IDirectDrawSurface3_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
+#define IDirectDrawSurface3_PageLock(p,a)		 (p)->PageLock(a)
+#define IDirectDrawSurface3_PageUnlock(p,a)		 (p)->PageUnlock(a)
+#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)	 (p)->SetSurfaceDesc(a,b)
+#endif
+
+/*
+ * IDirectDrawSurface4 and related interfaces
+ */
+#undef INTERFACE
+#define INTERFACE IDirectDrawSurface4
+DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawSurface methods ***/
+    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
+    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
+    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
+    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
+    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
+    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
+    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
+    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
+    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
+    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
+    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
+    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
+    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
+    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
+    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
+    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
+    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
+    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
+    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
+    STDMETHOD(IsLost)(THIS) PURE;
+    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
+    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
+    STDMETHOD(Restore)(THIS) PURE;
+    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
+    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
+    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
+    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
+    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
+    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
+    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
+    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
+    /*** Added in the v2 interface ***/
+    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
+    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
+    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
+    /*** Added in the v3 interface ***/
+    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
+    /*** Added in the v4 interface ***/
+    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
+    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
+    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
+    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
+    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
+#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
+#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
+#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
+#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
+#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
+#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
+#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
+#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
+#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
+#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
+#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
+#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
+#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
+#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
+#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
+#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
+#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
+#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
+#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
+#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
+#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
+#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
+#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
+#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
+#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
+#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
+#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
+#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
+#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
+#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
+#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
+#define IDirectDrawSurface4_GetDDInterface(p,a)		 (p)->lpVtbl->GetDDInterface(p,a)
+#define IDirectDrawSurface4_PageLock(p,a)		 (p)->lpVtbl->PageLock(p,a)
+#define IDirectDrawSurface4_PageUnlock(p,a)		 (p)->lpVtbl->PageUnlock(p,a)
+#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)	 (p)->lpVtbl->SetSurfaceDesc(p,a,b)
+#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)	 (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
+#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)	 (p)->lpVtbl->GetPrivateData(p,a,b,c)
+#define IDirectDrawSurface4_FreePrivateData(p,a)	 (p)->lpVtbl->FreePrivateData(p,a)
+#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
+#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
+#else
+#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
+#define IDirectDrawSurface4_Release(p)                   (p)->Release()
+#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
+#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
+#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
+#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
+#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
+#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
+#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
+#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
+#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
+#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
+#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
+#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
+#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
+#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
+#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
+#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
+#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
+#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
+#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
+#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
+#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
+#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
+#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
+#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
+#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
+#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
+#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
+#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
+#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
+#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
+#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
+#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
+#define IDirectDrawSurface4_GetDDInterface(p,a)		 (p)->GetDDInterface(a)
+#define IDirectDrawSurface4_PageLock(p,a)		 (p)->PageLock(a)
+#define IDirectDrawSurface4_PageUnlock(p,a)		 (p)->PageUnlock(a)
+#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)	 (p)->SetSurfaceDesc(a,b)
+#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)	 (p)->SetPrivateData(a,b,c,d)
+#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)	 (p)->GetPrivateData(a,b,c)
+#define IDirectDrawSurface4_FreePrivateData(p,a)	 (p)->FreePrivateData(a)
+#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
+#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
+#endif
+
+
+
+/*
+ * IDirectDrawColorControl
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDrawColorControl
+DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawColorControl methods ***/
+    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
+    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
+#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
+#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
+#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
+#else
+#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
+#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
+#define IDirectDrawColorControl_Release(p)               (p)->Release()
+#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
+#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
+#endif
+
+#endif
+
+
+/*
+ * IDirectDrawGammaControl
+ */
+#if defined( _WIN32 ) && !defined( _NO_COM )
+#undef INTERFACE
+#define INTERFACE IDirectDrawGammaControl
+DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
+    STDMETHOD_(ULONG,Release) (THIS) PURE;
+    /*** IDirectDrawColorControl methods ***/
+    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
+    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
+#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
+#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
+#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
+#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
+#else
+#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
+#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
+#define IDirectDrawGammaControl_Release(p)               (p)->Release()
+#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
+#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
+#endif
+
+#endif
+
+
+
+#endif
+
+
+/*
+ * DDSURFACEDESC
+ */
+typedef struct _DDSURFACEDESC
+{
+    DWORD		dwSize;			// size of the DDSURFACEDESC structure
+    DWORD		dwFlags;		// determines what fields are valid
+    DWORD		dwHeight;		// height of surface to be created
+    DWORD		dwWidth;		// width of input surface
+    union
+    {
+        LONG		lPitch;			// distance to start of next line (return value only)
+        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
+    } DUMMYUNIONNAMEN(1);
+    DWORD		dwBackBufferCount;	// number of back buffers requested
+    union
+    {
+        DWORD           dwMipMapCount;          // number of mip-map levels requested
+	DWORD		dwZBufferBitDepth;	// depth of Z buffer requested
+	DWORD		dwRefreshRate;		// refresh rate (used when display mode is described)
+    } DUMMYUNIONNAMEN(2);
+    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
+    DWORD		dwReserved;		// reserved
+    LPVOID		lpSurface;		// pointer to the associated surface memory
+    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
+    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
+    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
+    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
+    DDPIXELFORMAT	ddpfPixelFormat;	// pixel format description of the surface
+    DDSCAPS		ddsCaps;		// direct draw surface capabilities
+} DDSURFACEDESC;
+
+/*
+ * DDSURFACEDESC2
+ */
+typedef struct _DDSURFACEDESC2
+{
+    DWORD		dwSize;			// size of the DDSURFACEDESC structure
+    DWORD		dwFlags;		// determines what fields are valid
+    DWORD		dwHeight;		// height of surface to be created
+    DWORD		dwWidth;		// width of input surface
+    union
+    {
+        LONG		lPitch;			// distance to start of next line (return value only)
+        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
+    } DUMMYUNIONNAMEN(1);
+    DWORD		dwBackBufferCount;	// number of back buffers requested
+    union
+    {
+        DWORD           dwMipMapCount;          // number of mip-map levels requestde
+                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
+	DWORD		dwRefreshRate;		// refresh rate (used when display mode is described)
+    } DUMMYUNIONNAMEN(2);
+    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
+    DWORD		dwReserved;		// reserved
+    LPVOID		lpSurface;		// pointer to the associated surface memory
+    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
+    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
+    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
+    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
+    DDPIXELFORMAT	ddpfPixelFormat;	// pixel format description of the surface
+    DDSCAPS2		ddsCaps;		// direct draw surface capabilities
+    DWORD               dwTextureStage;         // stage in multitexture cascade
+} DDSURFACEDESC2;
+
+/*
+ * ddsCaps field is valid.
+ */
+#define DDSD_CAPS		0x00000001l	// default
+
+/*
+ * dwHeight field is valid.
+ */
+#define DDSD_HEIGHT		0x00000002l
+
+/*
+ * dwWidth field is valid.
+ */
+#define DDSD_WIDTH		0x00000004l
+
+/*
+ * lPitch is valid.
+ */
+#define DDSD_PITCH		0x00000008l
+
+/*
+ * dwBackBufferCount is valid.
+ */
+#define DDSD_BACKBUFFERCOUNT	0x00000020l
+
+/*
+ * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
+ */
+#define DDSD_ZBUFFERBITDEPTH	0x00000040l
+
+/*
+ * dwAlphaBitDepth is valid.
+ */
+#define DDSD_ALPHABITDEPTH	0x00000080l
+
+
+/*
+ * lpSurface is valid.
+ */
+#define DDSD_LPSURFACE		0x00000800l
+
+/*
+ * ddpfPixelFormat is valid.
+ */
+#define DDSD_PIXELFORMAT	0x00001000l
+
+/*
+ * ddckCKDestOverlay is valid.
+ */
+#define DDSD_CKDESTOVERLAY	0x00002000l
+
+/*
+ * ddckCKDestBlt is valid.
+ */
+#define DDSD_CKDESTBLT		0x00004000l
+
+/*
+ * ddckCKSrcOverlay is valid.
+ */
+#define DDSD_CKSRCOVERLAY	0x00008000l
+
+/*
+ * ddckCKSrcBlt is valid.
+ */
+#define DDSD_CKSRCBLT		0x00010000l
+
+/*
+ * dwMipMapCount is valid.
+ */
+#define DDSD_MIPMAPCOUNT        0x00020000l
+
+ /*
+  * dwRefreshRate is valid
+  */
+#define DDSD_REFRESHRATE	0x00040000l
+
+/*
+ * dwLinearSize is valid
+ */
+#define DDSD_LINEARSIZE		0x00080000l
+
+/*
+ * dwTextureStage is valid
+ */
+#define DDSD_TEXTURESTAGE       0x00100000l
+/*
+ * All input fields are valid.
+ */
+#define DDSD_ALL		0x001ff9eel
+
+
+/*
+ * DDOPTSURFACEDESC
+ */
+typedef struct _DDOPTSURFACEDESC
+{
+    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
+    DWORD       dwFlags;            // determines what fields are valid
+    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
+    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
+    GUID        guid;               // Compression technique GUID
+    DWORD       dwCompressionRatio; // Compression ratio
+} DDOPTSURFACEDESC;
+
+/*
+ * guid field is valid.
+ */
+#define DDOSD_GUID                  0x00000001l
+
+/*
+ * dwCompressionRatio field is valid.
+ */
+#define DDOSD_COMPRESSION_RATIO     0x00000002l
+
+/*
+ * ddSCaps field is valid.
+ */
+#define DDOSD_SCAPS                 0x00000004l
+
+/*
+ * ddOSCaps field is valid.
+ */
+#define DDOSD_OSCAPS                0x00000008l
+
+/*
+ * All input fields are valid.
+ */
+#define DDOSD_ALL                   0x0000000fl
+
+/*
+ * The surface's optimized pixelformat is compressed
+ */
+#define DDOSDCAPS_OPTCOMPRESSED			0x00000001l
+
+/*
+ * The surface's optimized pixelformat is reordered
+ */
+#define DDOSDCAPS_OPTREORDERED			0x00000002l
+
+/*
+ * The opt surface is a monolithic mipmap
+ */
+#define DDOSDCAPS_MONOLITHICMIPMAP		0x00000004l
+
+/*
+ * The valid Surf caps:
+ * #define DDSCAPS_SYSTEMMEMORY			0x00000800l
+ * #define DDSCAPS_VIDEOMEMORY	        0x00004000l
+ * #define DDSCAPS_LOCALVIDMEM          0x10000000l
+ * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
+ */
+#define DDOSDCAPS_VALIDSCAPS         	0x30004800l
+
+/*
+ * The valid OptSurf caps
+ */
+#define DDOSDCAPS_VALIDOSCAPS         	0x00000007l
+
+
+/*
+ * DDCOLORCONTROL
+ */
+typedef struct _DDCOLORCONTROL
+{
+    DWORD 		dwSize;
+    DWORD		dwFlags;
+    LONG		lBrightness;
+    LONG		lContrast;
+    LONG		lHue;
+    LONG 		lSaturation;
+    LONG		lSharpness;
+    LONG		lGamma;
+    LONG		lColorEnable;
+    DWORD		dwReserved1;
+} DDCOLORCONTROL;
+
+
+/*
+ * lBrightness field is valid.
+ */
+#define DDCOLOR_BRIGHTNESS		0x00000001l
+
+/*
+ * lContrast field is valid.
+ */
+#define DDCOLOR_CONTRAST		0x00000002l
+
+/*
+ * lHue field is valid.
+ */
+#define DDCOLOR_HUE			0x00000004l
+
+/*
+ * lSaturation field is valid.
+ */
+#define DDCOLOR_SATURATION		0x00000008l
+
+/*
+ * lSharpness field is valid.
+ */
+#define DDCOLOR_SHARPNESS		0x00000010l
+
+/*
+ * lGamma field is valid.
+ */
+#define DDCOLOR_GAMMA			0x00000020l
+
+/*
+ * lColorEnable field is valid.
+ */
+#define DDCOLOR_COLORENABLE		0x00000040l
+
+
+
+/*============================================================================
+ *
+ * Direct Draw Capability Flags
+ *
+ * These flags are used to describe the capabilities of a given Surface.
+ * All flags are bit flags.
+ *
+ *==========================================================================*/
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE CAPABILITY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * This bit is reserved. It should not be specified.
+ */
+#define DDSCAPS_RESERVED1			0x00000001l
+
+/*
+ * Indicates that this surface contains alpha-only information.
+ * (To determine if a surface is RGBA/YUVA, the pixel format must be
+ * interrogated.)
+ */
+#define DDSCAPS_ALPHA				0x00000002l
+
+/*
+ * Indicates that this surface is a backbuffer.	 It is generally
+ * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
+ * It indicates that this surface is THE back buffer of a surface
+ * flipping structure.	DirectDraw supports N surfaces in a
+ * surface flipping structure.	Only the surface that immediately
+ * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
+ * The other surfaces are identified as back buffers by the presence
+ * of the DDSCAPS_FLIP capability, their attachment order, and the
+ * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
+ * capabilities.  The bit is sent to CreateSurface when a standalone
+ * back buffer is being created.  This surface could be attached to
+ * a front buffer and/or back buffers to form a flipping surface
+ * structure after the CreateSurface call.  See AddAttachments for
+ * a detailed description of the behaviors in this case.
+ */
+#define DDSCAPS_BACKBUFFER			0x00000004l
+
+/*
+ * Indicates a complex surface structure is being described.  A
+ * complex surface structure results in the creation of more than
+ * one surface.	 The additional surfaces are attached to the root
+ * surface.  The complex structure can only be destroyed by
+ * destroying the root.
+ */
+#define DDSCAPS_COMPLEX				0x00000008l
+
+/*
+ * Indicates that this surface is a part of a surface flipping structure.
+ * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
+ * DDSCAP_BACKBUFFER bits are not set.	They are set by CreateSurface
+ * on the resulting creations.	The dwBackBufferCount field in the
+ * DDSURFACEDESC structure must be set to at least 1 in order for
+ * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
+ * must always be set with creating multiple surfaces through CreateSurface.
+ */
+#define DDSCAPS_FLIP				0x00000010l
+
+/*
+ * Indicates that this surface is THE front buffer of a surface flipping
+ * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
+ * capability bit is set.
+ * If this capability is sent to CreateSurface then a standalonw front buffer
+ * is created.	This surface will not have the DDSCAPS_FLIP capability.
+ * It can be attached to other back buffers to form a flipping structure.
+ * See AddAttachments for a detailed description of the behaviors in this
+ * case.
+ */
+#define DDSCAPS_FRONTBUFFER			0x00000020l
+
+/*
+ * Indicates that this surface is any offscreen surface that is not an overlay,
+ * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
+ * to identify plain vanilla surfaces.
+ */
+#define DDSCAPS_OFFSCREENPLAIN			0x00000040l
+
+/*
+ * Indicates that this surface is an overlay.  It may or may not be directly visible
+ * depending on whether or not it is currently being overlayed onto the primary
+ * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
+ * overlayed at the moment.
+ */
+#define DDSCAPS_OVERLAY				0x00000080l
+
+/*
+ * Indicates that unique DirectDrawPalette objects can be created and
+ * attached to this surface.
+ */
+#define DDSCAPS_PALETTE				0x00000100l
+
+/*
+ * Indicates that this surface is the primary surface.	The primary
+ * surface represents what the user is seeing at the moment.
+ */
+#define DDSCAPS_PRIMARYSURFACE			0x00000200l
+
+/*
+ * Indicates that this surface is the primary surface for the left eye.
+ * The primary surface for the left eye represents what the user is seeing
+ * at the moment with the users left eye.  When this surface is created the
+ * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
+ * right eye.
+ */
+#define DDSCAPS_PRIMARYSURFACELEFT		0x00000400l
+
+/*
+ * Indicates that this surface memory was allocated in system memory
+ */
+#define DDSCAPS_SYSTEMMEMORY			0x00000800l
+
+/*
+ * Indicates that this surface can be used as a 3D texture.  It does not
+ * indicate whether or not the surface is being used for that purpose.
+ */
+#define DDSCAPS_TEXTURE			        0x00001000l
+
+/*
+ * Indicates that a surface may be a destination for 3D rendering.  This
+ * bit must be set in order to query for a Direct3D Device Interface
+ * from this surface.
+ */
+#define DDSCAPS_3DDEVICE                        0x00002000l
+
+/*
+ * Indicates that this surface exists in video memory.
+ */
+#define DDSCAPS_VIDEOMEMORY			0x00004000l
+
+/*
+ * Indicates that changes made to this surface are immediately visible.
+ * It is always set for the primary surface and is set for overlays while
+ * they are being overlayed and texture maps while they are being textured.
+ */
+#define DDSCAPS_VISIBLE				0x00008000l
+
+/*
+ * Indicates that only writes are permitted to the surface.  Read accesses
+ * from the surface may or may not generate a protection fault, but the
+ * results of a read from this surface will not be meaningful.	READ ONLY.
+ */
+#define DDSCAPS_WRITEONLY			0x00010000l
+
+/*
+ * Indicates that this surface is a z buffer. A z buffer does not contain
+ * displayable information.  Instead it contains bit depth information that is
+ * used to determine which pixels are visible and which are obscured.
+ */
+#define DDSCAPS_ZBUFFER				0x00020000l
+
+/*
+ * Indicates surface will have a DC associated long term
+ */
+#define DDSCAPS_OWNDC				0x00040000l
+
+/*
+ * Indicates surface should be able to receive live video
+ */
+#define DDSCAPS_LIVEVIDEO			0x00080000l
+
+/*
+ * Indicates surface should be able to have a stream decompressed
+ * to it by the hardware.
+ */
+#define DDSCAPS_HWCODEC				0x00100000l
+
+/*
+ * Surface is a ModeX surface.
+ *
+ */
+#define DDSCAPS_MODEX				0x00200000l
+
+/*
+ * Indicates surface is one level of a mip-map. This surface will
+ * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
+ * This can be done explicitly, by creating a number of surfaces and
+ * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
+ * If this bit is set then DDSCAPS_TEXTURE must also be set.
+ */
+#define DDSCAPS_MIPMAP                          0x00400000l
+
+/*
+ * This bit is reserved. It should not be specified.
+ */
+#define DDSCAPS_RESERVED2                       0x00800000l
+
+
+/*
+ * Indicates that memory for the surface is not allocated until the surface
+ * is loaded (via the Direct3D texture Load() function).
+ */
+#define DDSCAPS_ALLOCONLOAD                     0x04000000l
+
+/*
+ * Indicates that the surface will recieve data from a video port.
+ */
+#define DDSCAPS_VIDEOPORT			0x08000000l
+
+/*
+ * Indicates that a video memory surface is resident in true, local video
+ * memory rather than non-local video memory. If this flag is specified then
+ * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
+ * DDSCAPS_NONLOCALVIDMEM.
+ */
+#define DDSCAPS_LOCALVIDMEM                     0x10000000l
+
+/*
+ * Indicates that a video memory surface is resident in non-local video
+ * memory rather than true, local video memory. If this flag is specified
+ * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
+ * DDSCAPS_LOCALVIDMEM.
+ */
+#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l
+
+/*
+ * Indicates that this surface is a standard VGA mode surface, and not a
+ * ModeX surface. (This flag will never be set in combination with the
+ * DDSCAPS_MODEX flag).
+ */
+#define DDSCAPS_STANDARDVGAMODE                 0x40000000l
+
+/*
+ * Indicates that this surface will be an optimized surface. This flag is
+ * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
+ * will be created without any underlying video memory until loaded.
+ */
+#define DDSCAPS_OPTIMIZED                       0x80000000l
+
+
+
+
+/*
+ * Indicates that this surface will receive data from a video port using
+ * the de-interlacing hardware.  This allows the driver to allocate memory
+ * for any extra buffers that may be required.  The DDSCAPS_VIDEOPORT and
+ * DDSCAPS_OVERLAY flags must also be set.
+ */
+#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000002L
+
+/*
+ * Indicates to the driver that this surface will be locked very frequently
+ * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
+ * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
+ * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
+ */
+#define DDSCAPS2_HINTDYNAMIC 			0x00000004L
+
+/*
+ * Indicates to the driver that this surface can be re-ordered/retiled on
+ * load. This operation will not change the size of the texture. It is
+ * relatively fast and symmetrical, since the application may lock these
+ * bits (although it will take a performance hit when doing so). Surfaces
+ * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
+ * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
+ */
+#define DDSCAPS2_HINTSTATIC 			0x00000008L
+
+/*
+ * Indicates that the client would like this texture surface to be managed by the
+ * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
+ * DDSCAPS_TEXTURE set.
+ */
+#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L
+
+/*
+ * These bits are reserved for internal use */
+#define DDSCAPS2_RESERVED1                      0x00000020L
+#define DDSCAPS2_RESERVED2                      0x00000040L
+
+/*
+ * Indicates to the driver that this surface will never be locked again.
+ * The driver is free to optimize this surface via retiling and actual compression.
+ * All calls to Lock() or Blts from this surface will fail. Surfaces with this
+ * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
+ * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
+ */
+#define DDSCAPS2_OPAQUE                         0x00000080L
+
+/*
+ * Applications should set this bit at CreateSurface time to indicate that they
+ * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
+ */
+#define DDSCAPS2_HINTANTIALIASING               0x00000100L
+
+
+
+
+ /****************************************************************************
+ *
+ * DIRECTDRAW DRIVER CAPABILITY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Display hardware has 3D acceleration.
+ */
+#define DDCAPS_3D			0x00000001l
+
+/*
+ * Indicates that DirectDraw will support only dest rectangles that are aligned
+ * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
+ * READ ONLY.
+ */
+#define DDCAPS_ALIGNBOUNDARYDEST	0x00000002l
+
+/*
+ * Indicates that DirectDraw will support only source rectangles  whose sizes in
+ * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
+ */
+#define DDCAPS_ALIGNSIZEDEST		0x00000004l
+/*
+ * Indicates that DirectDraw will support only source rectangles that are aligned
+ * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
+ * READ ONLY.
+ */
+#define DDCAPS_ALIGNBOUNDARYSRC		0x00000008l
+
+/*
+ * Indicates that DirectDraw will support only source rectangles  whose sizes in
+ * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
+ */
+#define DDCAPS_ALIGNSIZESRC		0x00000010l
+
+/*
+ * Indicates that DirectDraw will create video memory surfaces that have a stride
+ * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
+ */
+#define DDCAPS_ALIGNSTRIDE		0x00000020l
+
+/*
+ * Display hardware is capable of blt operations.
+ */
+#define DDCAPS_BLT			0x00000040l
+
+/*
+ * Display hardware is capable of asynchronous blt operations.
+ */
+#define DDCAPS_BLTQUEUE			0x00000080l
+
+/*
+ * Display hardware is capable of color space conversions during the blt operation.
+ */
+#define DDCAPS_BLTFOURCC		0x00000100l
+
+/*
+ * Display hardware is capable of stretching during blt operations.
+ */
+#define DDCAPS_BLTSTRETCH		0x00000200l
+
+/*
+ * Display hardware is shared with GDI.
+ */
+#define DDCAPS_GDI			0x00000400l
+
+/*
+ * Display hardware can overlay.
+ */
+#define DDCAPS_OVERLAY			0x00000800l
+
+/*
+ * Set if display hardware supports overlays but can not clip them.
+ */
+#define DDCAPS_OVERLAYCANTCLIP		0x00001000l
+
+/*
+ * Indicates that overlay hardware is capable of color space conversions during
+ * the overlay operation.
+ */
+#define DDCAPS_OVERLAYFOURCC		0x00002000l
+
+/*
+ * Indicates that stretching can be done by the overlay hardware.
+ */
+#define DDCAPS_OVERLAYSTRETCH		0x00004000l
+
+/*
+ * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
+ * other than the primary surface.
+ */
+#define DDCAPS_PALETTE			0x00008000l
+
+/*
+ * Indicates that palette changes can be syncd with the veritcal refresh.
+ */
+#define DDCAPS_PALETTEVSYNC		0x00010000l
+
+/*
+ * Display hardware can return the current scan line.
+ */
+#define DDCAPS_READSCANLINE		0x00020000l
+
+/*
+ * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT
+ * can be created.
+ */
+#define DDCAPS_STEREOVIEW		0x00040000l
+
+/*
+ * Display hardware is capable of generating a vertical blank interrupt.
+ */
+#define DDCAPS_VBI			0x00080000l
+
+/*
+ * Supports the use of z buffers with blt operations.
+ */
+#define DDCAPS_ZBLTS			0x00100000l
+
+/*
+ * Supports Z Ordering of overlays.
+ */
+#define DDCAPS_ZOVERLAYS		0x00200000l
+
+/*
+ * Supports color key
+ */
+#define DDCAPS_COLORKEY			0x00400000l
+
+/*
+ * Supports alpha surfaces
+ */
+#define DDCAPS_ALPHA			0x00800000l
+
+/*
+ * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
+ */
+#define DDCAPS_COLORKEYHWASSIST		0x01000000l
+
+/*
+ * no hardware support at all
+ */
+#define DDCAPS_NOHARDWARE		0x02000000l
+
+/*
+ * Display hardware is capable of color fill with bltter
+ */
+#define DDCAPS_BLTCOLORFILL		0x04000000l
+
+/*
+ * Display hardware is bank switched, and potentially very slow at
+ * random access to VRAM.
+ */
+#define DDCAPS_BANKSWITCHED		0x08000000l
+
+/*
+ * Display hardware is capable of depth filling Z-buffers with bltter
+ */
+#define DDCAPS_BLTDEPTHFILL		0x10000000l
+
+/*
+ * Display hardware is capable of clipping while bltting.
+ */
+#define DDCAPS_CANCLIP			0x20000000l
+
+/*
+ * Display hardware is capable of clipping while stretch bltting.
+ */
+#define DDCAPS_CANCLIPSTRETCHED		0x40000000l
+
+/*
+ * Display hardware is capable of bltting to or from system memory
+ */
+#define DDCAPS_CANBLTSYSMEM		0x80000000l
+
+
+ /****************************************************************************
+ *
+ * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
+ *
+ ****************************************************************************/
+
+/*
+ * Display hardware is certified
+ */
+#define DDCAPS2_CERTIFIED              0x00000001l
+
+/*
+ * Driver cannot interleave 2D operations (lock and blt) to surfaces with
+ * Direct3D rendering operations between calls to BeginScene() and EndScene()
+ */
+#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l
+
+/*
+ * Display hardware contains a video port
+ */
+#define DDCAPS2_VIDEOPORT               0x00000004l
+
+/*
+ * The overlay can be automatically flipped according to the video port
+ * VSYNCs, providing automatic doubled buffered display of video port
+ * data using an overlay
+ */
+#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l
+
+/*
+ * Overlay can display each field of interlaced data individually while
+ * it is interleaved in memory without causing jittery artifacts.
+ */
+#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l
+
+/*
+ * Overlay can display each field of interlaced data individually while
+ * it is not interleaved in memory without causing jittery artifacts.
+ */
+#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l
+
+/*
+ * The overlay surface contains color controls (brightness, sharpness, etc.)
+ */
+#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l
+
+/*
+ * The primary surface contains color controls (gamma, etc.)
+ */
+#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l
+
+/*
+ * RGBZ -> RGB supported for 16:16 RGB:Z
+ */
+#define DDCAPS2_CANDROPZ16BIT           0x00000100l
+
+/*
+ * Driver supports non-local video memory.
+ */
+#define DDCAPS2_NONLOCALVIDMEM          0x00000200l
+
+/*
+ * Dirver supports non-local video memory but has different capabilities for
+ * non-local video memory surfaces. If this bit is set then so must
+ * DDCAPS2_NONLOCALVIDMEM.
+ */
+#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l
+
+/*
+ * Driver neither requires nor prefers surfaces to be pagelocked when performing
+ * blts involving system memory surfaces
+ */
+#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l
+
+/*
+ * Driver can create surfaces which are wider than the primary surface
+ */
+#define DDCAPS2_WIDESURFACES            0x00001000l
+
+/*
+ * Driver supports bob without using a video port by handling the
+ * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
+ */
+#define DDCAPS2_CANFLIPODDEVEN          0x00002000l
+
+/*
+ * Driver supports bob using hardware
+ */
+#define DDCAPS2_CANBOBHARDWARE          0x00004000l
+
+/*
+ * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
+ */
+#define DDCAPS2_COPYFOURCC              0x00008000l
+
+
+/*
+ * Driver supports loadable gamma ramps for the primary surface
+ */
+#define DDCAPS2_PRIMARYGAMMA            0x00020000l
+
+/*
+ * Driver can render in windowed mode.
+ */
+#define DDCAPS2_CANRENDERWINDOWED       0x00080000l
+
+/*
+ * A calibrator is available to adjust the gamma ramp according to the
+ * physical display properties so that the result will be identical on
+ * all calibrated systems.
+ */
+#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l
+
+/*
+ * Indicates that the driver will respond to DDFLIP_INTERVALn flags
+ */
+#define DDCAPS2_FLIPINTERVAL            0x00200000l
+
+/*
+ * Indicates that the driver will respond to DDFLIP_NOVSYNC
+ */
+#define DDCAPS2_FLIPNOVSYNC             0x00400000l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Supports alpha blending around the edge of a source color keyed surface.
+ * For Blt.
+ */
+#define DDFXALPHACAPS_BLTALPHAEDGEBLEND		0x00000001l
+
+/*
+ * Supports alpha information in the pixel format.  The bit depth of alpha
+ * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
+ * more opaque as the alpha value increases.  (0 is transparent.)
+ * For Blt.
+ */
+#define DDFXALPHACAPS_BLTALPHAPIXELS		0x00000002l
+
+/*
+ * Supports alpha information in the pixel format.  The bit depth of alpha
+ * information in the pixel format can be 1,2,4, or 8.	The alpha value
+ * becomes more transparent as the alpha value increases.  (0 is opaque.)
+ * This flag can only be set if DDCAPS_ALPHA is set.
+ * For Blt.
+ */
+#define DDFXALPHACAPS_BLTALPHAPIXELSNEG		0x00000004l
+
+/*
+ * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
+ * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
+ * (0 is transparent.)
+ * For Blt.
+ */
+#define DDFXALPHACAPS_BLTALPHASURFACES		0x00000008l
+
+/*
+ * The depth of the alpha channel data can range can be 1,2,4, or 8.
+ * The NEG suffix indicates that this alpha channel becomes more transparent
+ * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
+ * DDCAPS_ALPHA is set.
+ * For Blt.
+ */
+#define DDFXALPHACAPS_BLTALPHASURFACESNEG	0x00000010l
+
+/*
+ * Supports alpha blending around the edge of a source color keyed surface.
+ * For Overlays.
+ */
+#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND	0x00000020l
+
+/*
+ * Supports alpha information in the pixel format.  The bit depth of alpha
+ * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
+ * more opaque as the alpha value increases.  (0 is transparent.)
+ * For Overlays.
+ */
+#define DDFXALPHACAPS_OVERLAYALPHAPIXELS	0x00000040l
+
+/*
+ * Supports alpha information in the pixel format.  The bit depth of alpha
+ * information in the pixel format can be 1,2,4, or 8.	The alpha value
+ * becomes more transparent as the alpha value increases.  (0 is opaque.)
+ * This flag can only be set if DDCAPS_ALPHA is set.
+ * For Overlays.
+ */
+#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG	0x00000080l
+
+/*
+ * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
+ * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
+ * (0 is transparent.)
+ * For Overlays.
+ */
+#define DDFXALPHACAPS_OVERLAYALPHASURFACES	0x00000100l
+
+/*
+ * The depth of the alpha channel data can range can be 1,2,4, or 8.
+ * The NEG suffix indicates that this alpha channel becomes more transparent
+ * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
+ * DDCAPS_ALPHA is set.
+ * For Overlays.
+ */
+#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG	0x00000200l
+
+#if DIRECTDRAW_VERSION < 0x0600
+#endif  //DIRECTDRAW_VERSION
+
+
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW FX CAPABILITY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Uses arithmetic operations to stretch and shrink surfaces during blt
+ * rather than pixel doubling techniques.  Along the Y axis.
+ */
+#define DDFXCAPS_BLTARITHSTRETCHY	0x00000020l
+
+/*
+ * Uses arithmetic operations to stretch during blt
+ * rather than pixel doubling techniques.  Along the Y axis. Only
+ * works for x1, x2, etc.
+ */
+#define DDFXCAPS_BLTARITHSTRETCHYN	0x00000010l
+
+/*
+ * Supports mirroring left to right in blt.
+ */
+#define DDFXCAPS_BLTMIRRORLEFTRIGHT	0x00000040l
+
+/*
+ * Supports mirroring top to bottom in blt.
+ */
+#define DDFXCAPS_BLTMIRRORUPDOWN	0x00000080l
+
+/*
+ * Supports arbitrary rotation for blts.
+ */
+#define DDFXCAPS_BLTROTATION		0x00000100l
+
+/*
+ * Supports 90 degree rotations for blts.
+ */
+#define DDFXCAPS_BLTROTATION90		0x00000200l
+
+/*
+ * DirectDraw supports arbitrary shrinking of a surface along the
+ * x axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSHRINKX		0x00000400l
+
+/*
+ * DirectDraw supports integer shrinking (1x,2x,) of a surface
+ * along the x axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSHRINKXN		0x00000800l
+
+/*
+ * DirectDraw supports arbitrary shrinking of a surface along the
+ * y axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSHRINKY		0x00001000l
+
+/*
+ * DirectDraw supports integer shrinking (1x,2x,) of a surface
+ * along the y axis (vertical direction) for blts.
+ */
+#define DDFXCAPS_BLTSHRINKYN		0x00002000l
+
+/*
+ * DirectDraw supports arbitrary stretching of a surface along the
+ * x axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSTRETCHX		0x00004000l
+
+/*
+ * DirectDraw supports integer stretching (1x,2x,) of a surface
+ * along the x axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSTRETCHXN		0x00008000l
+
+/*
+ * DirectDraw supports arbitrary stretching of a surface along the
+ * y axis (horizontal direction) for blts.
+ */
+#define DDFXCAPS_BLTSTRETCHY		0x00010000l
+
+/*
+ * DirectDraw supports integer stretching (1x,2x,) of a surface
+ * along the y axis (vertical direction) for blts.
+ */
+#define DDFXCAPS_BLTSTRETCHYN		0x00020000l
+
+/*
+ * Uses arithmetic operations to stretch and shrink surfaces during
+ * overlay rather than pixel doubling techniques.  Along the Y axis
+ * for overlays.
+ */
+#define DDFXCAPS_OVERLAYARITHSTRETCHY	0x00040000l
+
+/*
+ * Uses arithmetic operations to stretch surfaces during
+ * overlay rather than pixel doubling techniques.  Along the Y axis
+ * for overlays. Only works for x1, x2, etc.
+ */
+#define DDFXCAPS_OVERLAYARITHSTRETCHYN	0x00000008l
+
+/*
+ * DirectDraw supports arbitrary shrinking of a surface along the
+ * x axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSHRINKX		0x00080000l
+
+/*
+ * DirectDraw supports integer shrinking (1x,2x,) of a surface
+ * along the x axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSHRINKXN	0x00100000l
+
+/*
+ * DirectDraw supports arbitrary shrinking of a surface along the
+ * y axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSHRINKY		0x00200000l
+
+/*
+ * DirectDraw supports integer shrinking (1x,2x,) of a surface
+ * along the y axis (vertical direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSHRINKYN	0x00400000l
+
+/*
+ * DirectDraw supports arbitrary stretching of a surface along the
+ * x axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSTRETCHX	0x00800000l
+
+/*
+ * DirectDraw supports integer stretching (1x,2x,) of a surface
+ * along the x axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSTRETCHXN	0x01000000l
+
+/*
+ * DirectDraw supports arbitrary stretching of a surface along the
+ * y axis (horizontal direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSTRETCHY	0x02000000l
+
+/*
+ * DirectDraw supports integer stretching (1x,2x,) of a surface
+ * along the y axis (vertical direction) for overlays.
+ */
+#define DDFXCAPS_OVERLAYSTRETCHYN	0x04000000l
+
+/*
+ * DirectDraw supports mirroring of overlays across the vertical axis
+ */
+#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT	0x08000000l
+
+/*
+ * DirectDraw supports mirroring of overlays across the horizontal axis
+ */
+#define DDFXCAPS_OVERLAYMIRRORUPDOWN	0x10000000l
+
+/*
+ * Driver can do alpha blending for blits.
+ */
+#define DDFXCAPS_BLTALPHA 		0x00000001l
+
+/*
+ * Driver can do geometric transformations (or warps) for blits.
+ */
+#define DDFXCAPS_BLTTRANSFORM		0x00000002l
+
+/*
+ * Driver can do surface-reconstruction filtering for warped blits.
+ */
+#define DDFXCAPS_BLTFILTER 		DDFXCAPS_BLTARITHSTRETCHY
+
+/*
+ * Driver can do alpha blending for overlays.
+ */
+#define DDFXCAPS_OVERLAYALPHA 		0x00000004l
+
+/*
+ * Driver can do geometric transformations (or warps) for overlays.
+ */
+#define DDFXCAPS_OVERLAYTRANSFORM 	0x20000000l
+
+/*
+ * Driver can do surface-reconstruction filtering for warped overlays.
+ */
+#define DDFXCAPS_OVERLAYFILTER 		DDFXCAPS_OVERLAYARITHSTRETCHY
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW STEREO VIEW CAPABILITIES
+ *
+ ****************************************************************************/
+
+/*
+ * The stereo view is accomplished via enigma encoding.
+ */
+#define DDSVCAPS_ENIGMA			0x00000001l
+
+/*
+ * The stereo view is accomplished via high frequency flickering.
+ */
+#define DDSVCAPS_FLICKER		0x00000002l
+
+/*
+ * The stereo view is accomplished via red and blue filters applied
+ * to the left and right eyes.	All images must adapt their colorspaces
+ * for this process.
+ */
+#define DDSVCAPS_REDBLUE		0x00000004l
+
+/*
+ * The stereo view is accomplished with split screen technology.
+ */
+#define DDSVCAPS_SPLIT			0x00000008l
+
+/****************************************************************************
+ *
+ * DIRECTDRAWPALETTE CAPABILITIES
+ *
+ ****************************************************************************/
+
+/*
+ * Index is 4 bits.  There are sixteen color entries in the palette table.
+ */
+#define DDPCAPS_4BIT			0x00000001l
+
+/*
+ * Index is onto a 8 bit color index.  This field is only valid with the
+ * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
+ * surface is in 8bpp. Each color entry is one byte long and is an index
+ * into destination surface's 8bpp palette.
+ */
+#define DDPCAPS_8BITENTRIES		0x00000002l
+
+/*
+ * Index is 8 bits.  There are 256 color entries in the palette table.
+ */
+#define DDPCAPS_8BIT			0x00000004l
+
+/*
+ * Indicates that this DIRECTDRAWPALETTE should use the palette color array
+ * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
+ * object.
+ */
+#define DDPCAPS_INITIALIZE		0x00000008l
+
+/*
+ * This palette is the one attached to the primary surface.  Changing this
+ * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
+ * and supported.
+ */
+#define DDPCAPS_PRIMARYSURFACE		0x00000010l
+
+/*
+ * This palette is the one attached to the primary surface left.  Changing
+ * this table has immediate effect on the display for the left eye unless
+ * DDPSETPAL_VSYNC is specified and supported.
+ */
+#define DDPCAPS_PRIMARYSURFACELEFT	0x00000020l
+
+/*
+ * This palette can have all 256 entries defined
+ */
+#define DDPCAPS_ALLOW256		0x00000040l
+
+/*
+ * This palette can have modifications to it synced with the monitors
+ * refresh rate.
+ */
+#define DDPCAPS_VSYNC			0x00000080l
+
+/*
+ * Index is 1 bit.  There are two color entries in the palette table.
+ */
+#define DDPCAPS_1BIT			0x00000100l
+
+/*
+ * Index is 2 bit.  There are four color entries in the palette table.
+ */
+#define DDPCAPS_2BIT			0x00000200l
+
+/*
+ * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
+ */
+#define DDPCAPS_ALPHA			0x00000400l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWPALETTE SETENTRY CONSTANTS
+ *
+ ****************************************************************************/
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWPALETTE GETENTRY CONSTANTS
+ *
+ ****************************************************************************/
+
+/* 0 is the only legal value */
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
+ *
+ ****************************************************************************/
+
+/*
+ * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
+ * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
+ * pointer and Release when the private data is destroyed. This includes when
+ * the surface or palette is destroyed before such priovate data is destroyed.
+ */
+#define DDSPD_IUNKNOWNPOINTER           0x00000001L
+
+/*
+ * Private data is only valid for the current state of the object,
+ * as determined by the uniqueness value.
+ */
+#define DDSPD_VOLATILE                  0x00000002L
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
+ *
+ ****************************************************************************/
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW BITDEPTH CONSTANTS
+ *
+ * NOTE:  These are only used to indicate supported bit depths.   These
+ * are flags only, they are not to be used as an actual bit depth.   The
+ * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
+ * bit depths in a surface or for changing the display mode.
+ *
+ ****************************************************************************/
+
+/*
+ * 1 bit per pixel.
+ */
+#define DDBD_1			0x00004000l
+
+/*
+ * 2 bits per pixel.
+ */
+#define DDBD_2			0x00002000l
+
+/*
+ * 4 bits per pixel.
+ */
+#define DDBD_4			0x00001000l
+
+/*
+ * 8 bits per pixel.
+ */
+#define DDBD_8			0x00000800l
+
+/*
+ * 16 bits per pixel.
+ */
+#define DDBD_16			0x00000400l
+
+/*
+ * 24 bits per pixel.
+ */
+#define DDBD_24			0X00000200l
+
+/*
+ * 32 bits per pixel.
+ */
+#define DDBD_32			0x00000100l
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Set if the structure contains a color space.	 Not set if the structure
+ * contains a single color key.
+ */
+#define DDCKEY_COLORSPACE	0x00000001l
+
+/*
+ * Set if the structure specifies a color key or color space which is to be
+ * used as a destination color key for blt operations.
+ */
+#define DDCKEY_DESTBLT		0x00000002l
+
+/*
+ * Set if the structure specifies a color key or color space which is to be
+ * used as a destination color key for overlay operations.
+ */
+#define DDCKEY_DESTOVERLAY	0x00000004l
+
+/*
+ * Set if the structure specifies a color key or color space which is to be
+ * used as a source color key for blt operations.
+ */
+#define DDCKEY_SRCBLT		0x00000008l
+
+/*
+ * Set if the structure specifies a color key or color space which is to be
+ * used as a source color key for overlay operations.
+ */
+#define DDCKEY_SRCOVERLAY	0x00000010l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Supports transparent blting using a color key to identify the replaceable
+ * bits of the destination surface for RGB colors.
+ */
+#define DDCKEYCAPS_DESTBLT			0x00000001l
+
+/*
+ * Supports transparent blting using a color space to identify the replaceable
+ * bits of the destination surface for RGB colors.
+ */
+#define DDCKEYCAPS_DESTBLTCLRSPACE		0x00000002l
+
+/*
+ * Supports transparent blting using a color space to identify the replaceable
+ * bits of the destination surface for YUV colors.
+ */
+#define DDCKEYCAPS_DESTBLTCLRSPACEYUV		0x00000004l
+
+/*
+ * Supports transparent blting using a color key to identify the replaceable
+ * bits of the destination surface for YUV colors.
+ */
+#define DDCKEYCAPS_DESTBLTYUV			0x00000008l
+
+/*
+ * Supports overlaying using colorkeying of the replaceable bits of the surface
+ * being overlayed for RGB colors.
+ */
+#define DDCKEYCAPS_DESTOVERLAY			0x00000010l
+
+/*
+ * Supports a color space as the color key for the destination for RGB colors.
+ */
+#define DDCKEYCAPS_DESTOVERLAYCLRSPACE		0x00000020l
+
+/*
+ * Supports a color space as the color key for the destination for YUV colors.
+ */
+#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV	0x00000040l
+
+/*
+ * Supports only one active destination color key value for visible overlay
+ * surfaces.
+ */
+#define DDCKEYCAPS_DESTOVERLAYONEACTIVE		0x00000080l
+
+/*
+ * Supports overlaying using colorkeying of the replaceable bits of the
+ * surface being overlayed for YUV colors.
+ */
+#define DDCKEYCAPS_DESTOVERLAYYUV		0x00000100l
+
+/*
+ * Supports transparent blting using the color key for the source with
+ * this surface for RGB colors.
+ */
+#define DDCKEYCAPS_SRCBLT			0x00000200l
+
+/*
+ * Supports transparent blting using a color space for the source with
+ * this surface for RGB colors.
+ */
+#define DDCKEYCAPS_SRCBLTCLRSPACE		0x00000400l
+
+/*
+ * Supports transparent blting using a color space for the source with
+ * this surface for YUV colors.
+ */
+#define DDCKEYCAPS_SRCBLTCLRSPACEYUV		0x00000800l
+
+/*
+ * Supports transparent blting using the color key for the source with
+ * this surface for YUV colors.
+ */
+#define DDCKEYCAPS_SRCBLTYUV			0x00001000l
+
+/*
+ * Supports overlays using the color key for the source with this
+ * overlay surface for RGB colors.
+ */
+#define DDCKEYCAPS_SRCOVERLAY			0x00002000l
+
+/*
+ * Supports overlays using a color space as the source color key for
+ * the overlay surface for RGB colors.
+ */
+#define DDCKEYCAPS_SRCOVERLAYCLRSPACE		0x00004000l
+
+/*
+ * Supports overlays using a color space as the source color key for
+ * the overlay surface for YUV colors.
+ */
+#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV	0x00008000l
+
+/*
+ * Supports only one active source color key value for visible
+ * overlay surfaces.
+ */
+#define DDCKEYCAPS_SRCOVERLAYONEACTIVE		0x00010000l
+
+/*
+ * Supports overlays using the color key for the source with this
+ * overlay surface for YUV colors.
+ */
+#define DDCKEYCAPS_SRCOVERLAYYUV		0x00020000l
+
+/*
+ * there are no bandwidth trade-offs for using colorkey with an overlay
+ */
+#define DDCKEYCAPS_NOCOSTOVERLAY		0x00040000l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW PIXELFORMAT FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * The surface has alpha channel information in the pixel format.
+ */
+#define DDPF_ALPHAPIXELS			0x00000001l
+
+/*
+ * The pixel format contains alpha only information
+ */
+#define DDPF_ALPHA				0x00000002l
+
+/*
+ * The FourCC code is valid.
+ */
+#define DDPF_FOURCC				0x00000004l
+
+/*
+ * The surface is 4-bit color indexed.
+ */
+#define DDPF_PALETTEINDEXED4			0x00000008l
+
+/*
+ * The surface is indexed into a palette which stores indices
+ * into the destination surface's 8-bit palette.
+ */
+#define DDPF_PALETTEINDEXEDTO8			0x00000010l
+
+/*
+ * The surface is 8-bit color indexed.
+ */
+#define DDPF_PALETTEINDEXED8			0x00000020l
+
+/*
+ * The RGB data in the pixel format structure is valid.
+ */
+#define DDPF_RGB				0x00000040l
+
+/*
+ * The surface will accept pixel data in the format specified
+ * and compress it during the write.
+ */
+#define DDPF_COMPRESSED				0x00000080l
+
+/*
+ * The surface will accept RGB data and translate it during
+ * the write to YUV data.  The format of the data to be written
+ * will be contained in the pixel format structure.  The DDPF_RGB
+ * flag will be set.
+ */
+#define DDPF_RGBTOYUV				0x00000100l
+
+/*
+ * pixel format is YUV - YUV data in pixel format struct is valid
+ */
+#define DDPF_YUV				0x00000200l
+
+/*
+ * pixel format is a z buffer only surface
+ */
+#define DDPF_ZBUFFER				0x00000400l
+
+/*
+ * The surface is 1-bit color indexed.
+ */
+#define DDPF_PALETTEINDEXED1			0x00000800l
+
+/*
+ * The surface is 2-bit color indexed.
+ */
+#define DDPF_PALETTEINDEXED2			0x00001000l
+
+/*
+ * The surface contains Z information in the pixels
+ */
+#define DDPF_ZPIXELS				0x00002000l
+
+/*
+ * The surface contains stencil information along with Z
+ */
+#define DDPF_STENCILBUFFER			0x00004000l
+
+/*
+ * Premultiplied alpha format -- the color components have been
+ * premultiplied by the alpha component.
+ */
+#define DDPF_ALPHAPREMULT 			0x00008000l
+
+
+/*
+ * Luminance data in the pixel format is valid.
+ * Use this flag for luminance-only or luminance+alpha surfaces,
+ * the bit depth is then ddpf.dwLuminanceBitCount.
+ */
+#define DDPF_LUMINANCE                          0x00020000l
+
+/*
+ * Luminance data in the pixel format is valid.
+ * Use this flag when hanging luminance off bumpmap surfaces,
+ * the bit mask for the luminance portion of the pixel is then
+ * ddpf.dwBumpLuminanceBitMask
+ */
+#define DDPF_BUMPLUMINANCE                      0x00040000l
+
+/*
+ * Bump map dUdV data in the pixel format is valid.
+ */
+#define DDPF_BUMPDUDV                           0x00080000l
+
+/*===========================================================================
+ *
+ *
+ * DIRECTDRAW CALLBACK FLAGS
+ *
+ *
+ *==========================================================================*/
+
+/****************************************************************************
+ *
+ * DIRECTDRAW ENUMSURFACES FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Enumerate all of the surfaces that meet the search criterion.
+ */
+#define DDENUMSURFACES_ALL			0x00000001l
+
+/*
+ * A search hit is a surface that matches the surface description.
+ */
+#define DDENUMSURFACES_MATCH			0x00000002l
+
+/*
+ * A search hit is a surface that does not match the surface description.
+ */
+#define DDENUMSURFACES_NOMATCH			0x00000004l
+
+/*
+ * Enumerate the first surface that can be created which meets the search criterion.
+ */
+#define DDENUMSURFACES_CANBECREATED		0x00000008l
+
+/*
+ * Enumerate the surfaces that already exist that meet the search criterion.
+ */
+#define DDENUMSURFACES_DOESEXIST		0x00000010l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW SETDISPLAYMODE FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * The desired mode is a standard VGA mode
+ */
+#define DDSDM_STANDARDVGAMODE                   0x00000001l
+
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW ENUMDISPLAYMODES FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
+ * that a particular mode will be enumerated only once.  This flag specifies whether
+ * the refresh rate is taken into account when determining if a mode is unique.
+ */
+#define DDEDM_REFRESHRATES			0x00000001l
+
+/*
+ * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
+ * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
+ * enumerated if the application has previously called SetCooperativeLevel with the
+ * DDSCL_ALLOWMODEX flag set).
+ */
+#define DDEDM_STANDARDVGAMODES                  0x00000002L
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Exclusive mode owner will be responsible for the entire primary surface.
+ * GDI can be ignored. used with DD
+ */
+#define DDSCL_FULLSCREEN			0x00000001l
+
+/*
+ * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
+ */
+#define DDSCL_ALLOWREBOOT			0x00000002l
+
+/*
+ * prevents DDRAW from modifying the application window.
+ * prevents DDRAW from minimize/restore the application window on activation.
+ */
+#define DDSCL_NOWINDOWCHANGES			0x00000004l
+
+/*
+ * app wants to work as a regular Windows application
+ */
+#define DDSCL_NORMAL				0x00000008l
+
+/*
+ * app wants exclusive access
+ */
+#define DDSCL_EXCLUSIVE                         0x00000010l
+
+
+/*
+ * app can deal with non-windows display modes
+ */
+#define DDSCL_ALLOWMODEX                        0x00000040l
+
+/*
+ * this window will receive the focus messages
+ */
+#define DDSCL_SETFOCUSWINDOW                    0x00000080l
+
+/*
+ * this window is associated with the DDRAW object and will
+ * cover the screen in fullscreen mode
+ */
+#define DDSCL_SETDEVICEWINDOW                   0x00000100l
+
+/*
+ * app wants DDRAW to create a window to be associated with the
+ * DDRAW object
+ */
+#define DDSCL_CREATEDEVICEWINDOW                0x00000200l
+
+/*
+ * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
+ * take the global crtisec more frequently.
+ */
+#define DDSCL_MULTITHREADED                     0x00000400l
+
+/*
+ * App hints that it would like to keep the FPU set up for optimal Direct3D
+ * performance (single precision and exceptions disabled) so Direct3D
+ * does not need to explicitly set the FPU each time
+ */
+#define DDSCL_FPUSETUP                          0x00000800l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW BLT FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Use the alpha information in the pixel format or the alpha channel surface
+ * attached to the destination surface as the alpha channel for this blt.
+ */
+#define DDBLT_ALPHADEST				0x00000001l
+
+/*
+ * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
+ * for the destination surface for this blt.
+ */
+#define DDBLT_ALPHADESTCONSTOVERRIDE		0x00000002l
+
+/*
+ * The NEG suffix indicates that the destination surface becomes more
+ * transparent as the alpha value increases. (0 is opaque)
+ */
+#define DDBLT_ALPHADESTNEG			0x00000004l
+
+/*
+ * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
+ * channel for the destination for this blt.
+ */
+#define DDBLT_ALPHADESTSURFACEOVERRIDE		0x00000008l
+
+/*
+ * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
+ * for the edges of the image that border the color key colors.
+ */
+#define DDBLT_ALPHAEDGEBLEND			0x00000010l
+
+/*
+ * Use the alpha information in the pixel format or the alpha channel surface
+ * attached to the source surface as the alpha channel for this blt.
+ */
+#define DDBLT_ALPHASRC				0x00000020l
+
+/*
+ * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
+ * for the source for this blt.
+ */
+#define DDBLT_ALPHASRCCONSTOVERRIDE		0x00000040l
+
+/*
+ * The NEG suffix indicates that the source surface becomes more transparent
+ * as the alpha value increases. (0 is opaque)
+ */
+#define DDBLT_ALPHASRCNEG			0x00000080l
+
+/*
+ * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
+ * for the source for this blt.
+ */
+#define DDBLT_ALPHASRCSURFACEOVERRIDE		0x00000100l
+
+/*
+ * Do this blt asynchronously through the FIFO in the order received.  If
+ * there is no room in the hardware FIFO fail the call.
+ */
+#define DDBLT_ASYNC				0x00000200l
+
+/*
+ * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
+ * to fill the destination rectangle on the destination surface with.
+ */
+#define DDBLT_COLORFILL				0x00000400l
+
+/*
+ * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
+ * to use for the blt.
+ */
+#define DDBLT_DDFX				0x00000800l
+
+/*
+ * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
+ * that are not part of the Win32 API.
+ */
+#define DDBLT_DDROPS				0x00001000l
+
+/*
+ * Use the color key associated with the destination surface.
+ */
+#define DDBLT_KEYDEST				0x00002000l
+
+/*
+ * Use the dckDestColorkey field in the DDBLTFX structure as the color key
+ * for the destination surface.
+ */
+#define DDBLT_KEYDESTOVERRIDE			0x00004000l
+
+/*
+ * Use the color key associated with the source surface.
+ */
+#define DDBLT_KEYSRC				0x00008000l
+
+/*
+ * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
+ * for the source surface.
+ */
+#define DDBLT_KEYSRCOVERRIDE			0x00010000l
+
+/*
+ * Use the dwROP field in the DDBLTFX structure for the raster operation
+ * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
+ */
+#define DDBLT_ROP				0x00020000l
+
+/*
+ * Use the dwRotationAngle field in the DDBLTFX structure as the angle
+ * (specified in 1/100th of a degree) to rotate the surface.
+ */
+#define DDBLT_ROTATIONANGLE			0x00040000l
+
+/*
+ * Z-buffered blt using the z-buffers attached to the source and destination
+ * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
+ * z-buffer opcode.
+ */
+#define DDBLT_ZBUFFER				0x00080000l
+
+/*
+ * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
+ * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
+ * for the destination.
+ */
+#define DDBLT_ZBUFFERDESTCONSTOVERRIDE		0x00100000l
+
+/*
+ * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
+ * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
+ * respectively for the destination.
+ */
+#define DDBLT_ZBUFFERDESTOVERRIDE		0x00200000l
+
+/*
+ * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
+ * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
+ * for the source.
+ */
+#define DDBLT_ZBUFFERSRCCONSTOVERRIDE		0x00400000l
+
+/*
+ * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
+ * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
+ * respectively for the source.
+ */
+#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l
+
+/*
+ * wait until the device is ready to handle the blt
+ * this will cause blt to not return DDERR_WASSTILLDRAWING
+ */
+#define DDBLT_WAIT                              0x01000000l
+
+/*
+ * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
+ * to fill the destination rectangle on the destination Z-buffer surface
+ * with.
+ */
+#define DDBLT_DEPTHFILL				0x02000000l
+
+
+/****************************************************************************
+ *
+ * BLTFAST FLAGS
+ *
+ ****************************************************************************/
+
+#define DDBLTFAST_NOCOLORKEY                    0x00000000
+#define DDBLTFAST_SRCCOLORKEY                   0x00000001
+#define DDBLTFAST_DESTCOLORKEY                  0x00000002
+#define DDBLTFAST_WAIT                          0x00000010
+
+
+
+
+/****************************************************************************
+ *
+ * FLIP FLAGS
+ *
+ ****************************************************************************/
+
+#define DDFLIP_WAIT                          0x00000001L
+
+/*
+ * Indicates that the target surface contains the even field of video data.
+ * This flag is only valid with an overlay surface.
+ */
+#define DDFLIP_EVEN                          0x00000002L
+
+/*
+ * Indicates that the target surface contains the odd field of video data.
+ * This flag is only valid with an overlay surface.
+ */
+#define DDFLIP_ODD                           0x00000004L
+
+/*
+ * Causes DirectDraw to perform the physical flip immediately and return
+ * to the application. Typically, what was the front buffer but is now the back
+ * buffer will still be visible (depending on timing) until the next vertical 
+ * retrace. Subsequent operations involving the two flipped surfaces will
+ * not check to see if the physical flip has finished (i.e. will not return
+ * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
+ * This allows an application to perform Flips at a higher frequency than the
+ * monitor refresh rate, but may introduce visible artifacts.
+ * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set, 
+ * DDFLIP_NOVSYNC has no effect.
+ */
+#define DDFLIP_NOVSYNC                       0x00000008L
+
+
+/*
+ * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
+ * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
+ * surface involved in the flip until the specified number of vertical retraces has
+ * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set, 
+ * DDFLIP_INTERVALn has no effect.
+ */
+
+/*
+ * DirectDraw will flip on every other vertical sync
+ */
+#define DDFLIP_INTERVAL2                     0x02000000L
+
+
+/*
+ * DirectDraw will flip on every third vertical sync
+ */
+#define DDFLIP_INTERVAL3                     0x03000000L
+
+
+/*
+ * DirectDraw will flip on every fourth vertical sync
+ */
+#define DDFLIP_INTERVAL4                     0x04000000L
+
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW SURFACE OVERLAY FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Use the alpha information in the pixel format or the alpha channel surface
+ * attached to the destination surface as the alpha channel for the
+ * destination overlay.
+ */
+#define DDOVER_ALPHADEST			0x00000001l
+
+/*
+ * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
+ * destination alpha channel for this overlay.
+ */
+#define DDOVER_ALPHADESTCONSTOVERRIDE		0x00000002l
+
+/*
+ * The NEG suffix indicates that the destination surface becomes more
+ * transparent as the alpha value increases.
+ */
+#define DDOVER_ALPHADESTNEG			0x00000004l
+
+/*
+ * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
+ * channel destination for this overlay.
+ */
+#define DDOVER_ALPHADESTSURFACEOVERRIDE		0x00000008l
+
+/*
+ * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
+ * channel for the edges of the image that border the color key colors.
+ */
+#define DDOVER_ALPHAEDGEBLEND			0x00000010l
+
+/*
+ * Use the alpha information in the pixel format or the alpha channel surface
+ * attached to the source surface as the source alpha channel for this overlay.
+ */
+#define DDOVER_ALPHASRC				0x00000020l
+
+/*
+ * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
+ * alpha channel for this overlay.
+ */
+#define DDOVER_ALPHASRCCONSTOVERRIDE		0x00000040l
+
+/*
+ * The NEG suffix indicates that the source surface becomes more transparent
+ * as the alpha value increases.
+ */
+#define DDOVER_ALPHASRCNEG			0x00000080l
+
+/*
+ * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
+ * source for this overlay.
+ */
+#define DDOVER_ALPHASRCSURFACEOVERRIDE		0x00000100l
+
+/*
+ * Turn this overlay off.
+ */
+#define DDOVER_HIDE				0x00000200l
+
+/*
+ * Use the color key associated with the destination surface.
+ */
+#define DDOVER_KEYDEST				0x00000400l
+
+/*
+ * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
+ * for the destination surface
+ */
+#define DDOVER_KEYDESTOVERRIDE			0x00000800l
+
+/*
+ * Use the color key associated with the source surface.
+ */
+#define DDOVER_KEYSRC				0x00001000l
+
+/*
+ * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
+ * for the source surface.
+ */
+#define DDOVER_KEYSRCOVERRIDE			0x00002000l
+
+/*
+ * Turn this overlay on.
+ */
+#define DDOVER_SHOW				0x00004000l
+
+/*
+ * Add a dirty rect to an emulated overlayed surface.
+ */
+#define DDOVER_ADDDIRTYRECT                     0x00008000l
+
+/*
+ * Redraw all dirty rects on an emulated overlayed surface.
+ */
+#define DDOVER_REFRESHDIRTYRECTS		0x00010000l
+
+/*
+ * Redraw the entire surface on an emulated overlayed surface.
+ */
+#define DDOVER_REFRESHALL                      0x00020000l
+
+
+/*
+ * Use the overlay FX flags to define special overlay FX
+ */
+#define DDOVER_DDFX                       	0x00080000l
+
+/*
+ * Autoflip the overlay when ever the video port autoflips
+ */
+#define DDOVER_AUTOFLIP                       	0x00100000l
+
+/*
+ * Display each field of video port data individually without
+ * causing any jittery artifacts
+ */
+#define DDOVER_BOB                       	0x00200000l
+
+/*
+ * Indicates that bob/weave decisions should not be overridden by other
+ * interfaces.
+ */
+#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
+
+/*
+ * Indicates that the surface memory is composed of interleaved fields.
+ */
+#define DDOVER_INTERLEAVED			0x00800000l
+
+/*
+ * Indicates that bob will be performed using hardware rather than
+ * software or emulated.
+ */
+#define DDOVER_BOBHARDWARE			0x01000000l
+
+
+
+
+
+
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE LOCK FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * The default.	 Set to indicate that Lock should return a valid memory pointer
+ * to the top of the specified rectangle.  If no rectangle is specified then a
+ * pointer to the top of the surface is returned.
+ */
+#define DDLOCK_SURFACEMEMORYPTR			0x00000000L	// default
+
+/*
+ * Set to indicate that Lock should wait until it can obtain a valid memory
+ * pointer before returning.  If this bit is set, Lock will never return
+ * DDERR_WASSTILLDRAWING.
+ */
+#define DDLOCK_WAIT				0x00000001L
+
+/*
+ * Set if an event handle is being passed to Lock.  Lock will trigger the event
+ * when it can return the surface memory pointer requested.
+ */
+#define DDLOCK_EVENT				0x00000002L
+
+/*
+ * Indicates that the surface being locked will only be read from.
+ */
+#define DDLOCK_READONLY				0x00000010L
+
+/*
+ * Indicates that the surface being locked will only be written to
+ */
+#define DDLOCK_WRITEONLY			0x00000020L
+
+
+/*
+ * Indicates that a system wide lock should not be taken when this surface
+ * is locked. This has several advantages (cursor responsiveness, ability
+ * to call more Windows functions, easier debugging) when locking video
+ * memory surfaces. However, an application specifying this flag must
+ * comply with a number of conditions documented in the help file.
+ * Furthermore, this flag cannot be specified when locking the primary.
+ */
+#define DDLOCK_NOSYSLOCK                        0x00000800L
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE PAGELOCK FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * No flags defined at present
+ */
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * No flags defined at present
+ */
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE BLT FX FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * If stretching, use arithmetic stretching along the Y axis for this blt.
+ */
+#define DDBLTFX_ARITHSTRETCHY			0x00000001l
+
+/*
+ * Do this blt mirroring the surface left to right.  Spin the
+ * surface around its y-axis.
+ */
+#define DDBLTFX_MIRRORLEFTRIGHT			0x00000002l
+
+/*
+ * Do this blt mirroring the surface up and down.  Spin the surface
+ * around its x-axis.
+ */
+#define DDBLTFX_MIRRORUPDOWN			0x00000004l
+
+/*
+ * Schedule this blt to avoid tearing.
+ */
+#define DDBLTFX_NOTEARING			0x00000008l
+
+/*
+ * Do this blt rotating the surface one hundred and eighty degrees.
+ */
+#define DDBLTFX_ROTATE180			0x00000010l
+
+/*
+ * Do this blt rotating the surface two hundred and seventy degrees.
+ */
+#define DDBLTFX_ROTATE270			0x00000020l
+
+/*
+ * Do this blt rotating the surface ninety degrees.
+ */
+#define DDBLTFX_ROTATE90			0x00000040l
+
+/*
+ * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
+ * specified to limit the bits copied from the source surface.
+ */
+#define DDBLTFX_ZBUFFERRANGE			0x00000080l
+
+/*
+ * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
+ * before comparing it with the desting z values.
+ */
+#define DDBLTFX_ZBUFFERBASEDEST			0x00000100l
+
+/****************************************************************************
+ *
+ * DIRECTDRAWSURFACE OVERLAY FX FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * If stretching, use arithmetic stretching along the Y axis for this overlay.
+ */
+#define DDOVERFX_ARITHSTRETCHY			0x00000001l
+
+/*
+ * Mirror the overlay across the vertical axis
+ */
+#define DDOVERFX_MIRRORLEFTRIGHT		0x00000002l
+
+/*
+ * Mirror the overlay across the horizontal axis
+ */
+#define DDOVERFX_MIRRORUPDOWN			0x00000004l
+
+/****************************************************************************
+ *
+ * Flags for dwDDFX member of DDSPRITEFX structure
+ *
+ ****************************************************************************/
+/*
+ * Use affine transformation matrix in fTransform member.
+ */
+#define DDSPRITEFX_AFFINETRANSFORM		0x00000001l
+
+/*
+ * Use RGBA scaling factors in ddrgbaScaleFactors member.
+ */
+#define DDSPRITEFX_RGBASCALING			0x00000002l
+
+/*
+ * Degrade RGBA scaling factors to accommodate driver's capabilities.
+ */
+#define DDSPRITEFX_DEGRADERGBASCALING		0x00000004l
+
+/*
+ * Do bilinear filtering of stretched or warped sprite.
+ */
+#define DDSPRITEFX_BILINEARFILTER     	  	0x00000008l
+
+/*
+ * Do "blur" filtering of stretched or warped sprite.
+ */
+#define DDSPRITEFX_BLURFILTER 	      	 	0x00000010l
+
+/*
+ * Do "flat" filtering of stretched or warped sprite.
+ */
+#define DDSPRITEFX_FLATFILTER 	      		0x00000020l
+
+/*
+ * Degrade filtering operation to accommodate driver's capabilities.
+ */
+#define DDSPRITEFX_DEGRADEFILTER 	      	0x00000040l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * return when the vertical blank interval begins
+ */
+#define DDWAITVB_BLOCKBEGIN			0x00000001l
+
+/*
+ * set up an event to trigger when the vertical blank begins
+ */
+#define DDWAITVB_BLOCKBEGINEVENT		0x00000002l
+
+/*
+ * return when the vertical blank interval ends and display begins
+ */
+#define DDWAITVB_BLOCKEND			0x00000004l
+
+/****************************************************************************
+ *
+ * DIRECTDRAW GETFLIPSTATUS FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * is it OK to flip now?
+ */
+#define DDGFS_CANFLIP			0x00000001l
+
+/*
+ * is the last flip finished?
+ */
+#define DDGFS_ISFLIPDONE		0x00000002l
+
+/****************************************************************************
+ *
+ * DIRECTDRAW GETBLTSTATUS FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * is it OK to blt now?
+ */
+#define DDGBS_CANBLT			0x00000001l
+
+/*
+ * is the blt to the surface finished?
+ */
+#define DDGBS_ISBLTDONE			0x00000002l
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Enumerate overlays back to front.
+ */
+#define DDENUMOVERLAYZ_BACKTOFRONT	0x00000000l
+
+/*
+ * Enumerate overlays front to back
+ */
+#define DDENUMOVERLAYZ_FRONTTOBACK	0x00000001l
+
+/****************************************************************************
+ *
+ * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Send overlay to front
+ */
+#define DDOVERZ_SENDTOFRONT		0x00000000l
+
+/*
+ * Send overlay to back
+ */
+#define DDOVERZ_SENDTOBACK		0x00000001l
+
+/*
+ * Move Overlay forward
+ */
+#define DDOVERZ_MOVEFORWARD		0x00000002l
+
+/*
+ * Move Overlay backward
+ */
+#define DDOVERZ_MOVEBACKWARD		0x00000003l
+
+/*
+ * Move Overlay in front of relative surface
+ */
+#define DDOVERZ_INSERTINFRONTOF		0x00000004l
+
+/*
+ * Move Overlay in back of relative surface
+ */
+#define DDOVERZ_INSERTINBACKOF		0x00000005l
+
+
+
+/****************************************************************************
+ *
+ * DIRECTDRAW SETGAMMARAMP FLAGS
+ *
+ ****************************************************************************/
+
+/*
+ * Request calibrator to adjust the gamma ramp according to the physical
+ * properties of the display so that the result should appear identical
+ * on all systems.
+ */
+#define DDSGR_CALIBRATE                        0x00000001L
+
+
+/*===========================================================================
+ *
+ *
+ * DIRECTDRAW RETURN CODES
+ *
+ * The return values from DirectDraw Commands and Surface that return an HRESULT
+ * are codes from DirectDraw concerning the results of the action
+ * requested by DirectDraw.
+ *
+ *==========================================================================*/
+
+/*
+ * Status is OK
+ *
+ * Issued by: DirectDraw Commands and all callbacks
+ */
+#define DD_OK					0
+#define DD_FALSE                                S_FALSE
+
+/****************************************************************************
+ *
+ * DIRECTDRAW ENUMCALLBACK RETURN VALUES
+ *
+ * EnumCallback returns are used to control the flow of the DIRECTDRAW and
+ * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
+ * enumeration callback routines.
+ *
+ ****************************************************************************/
+
+/*
+ * stop the enumeration
+ */
+#define DDENUMRET_CANCEL			0
+
+/*
+ * continue the enumeration
+ */
+#define DDENUMRET_OK				1
+
+/****************************************************************************
+ *
+ * DIRECTDRAW ERRORS
+ *
+ * Errors are represented by negative values and cannot be combined.
+ *
+ ****************************************************************************/
+
+/*
+ * This object is already initialized
+ */
+#define DDERR_ALREADYINITIALIZED		MAKE_DDHRESULT( 5 )
+
+/*
+ * This surface can not be attached to the requested surface.
+ */
+#define DDERR_CANNOTATTACHSURFACE		MAKE_DDHRESULT( 10 )
+
+/*
+ * This surface can not be detached from the requested surface.
+ */
+#define DDERR_CANNOTDETACHSURFACE		MAKE_DDHRESULT( 20 )
+
+/*
+ * Support is currently not available.
+ */
+#define DDERR_CURRENTLYNOTAVAIL			MAKE_DDHRESULT( 40 )
+
+/*
+ * An exception was encountered while performing the requested operation
+ */
+#define DDERR_EXCEPTION				MAKE_DDHRESULT( 55 )
+
+/*
+ * Generic failure.
+ */
+#define DDERR_GENERIC				E_FAIL
+
+/*
+ * Height of rectangle provided is not a multiple of reqd alignment
+ */
+#define DDERR_HEIGHTALIGN			MAKE_DDHRESULT( 90 )
+
+/*
+ * Unable to match primary surface creation request with existing
+ * primary surface.
+ */
+#define DDERR_INCOMPATIBLEPRIMARY		MAKE_DDHRESULT( 95 )
+
+/*
+ * One or more of the caps bits passed to the callback are incorrect.
+ */
+#define DDERR_INVALIDCAPS			MAKE_DDHRESULT( 100 )
+
+/*
+ * DirectDraw does not support provided Cliplist.
+ */
+#define DDERR_INVALIDCLIPLIST			MAKE_DDHRESULT( 110 )
+
+/*
+ * DirectDraw does not support the requested mode
+ */
+#define DDERR_INVALIDMODE			MAKE_DDHRESULT( 120 )
+
+/*
+ * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
+ */
+#define DDERR_INVALIDOBJECT			MAKE_DDHRESULT( 130 )
+
+/*
+ * One or more of the parameters passed to the callback function are
+ * incorrect.
+ */
+#define DDERR_INVALIDPARAMS			E_INVALIDARG
+
+/*
+ * pixel format was invalid as specified
+ */
+#define DDERR_INVALIDPIXELFORMAT		MAKE_DDHRESULT( 145 )
+
+/*
+ * Rectangle provided was invalid.
+ */
+#define DDERR_INVALIDRECT			MAKE_DDHRESULT( 150 )
+
+/*
+ * Operation could not be carried out because one or more surfaces are locked
+ */
+#define DDERR_LOCKEDSURFACES			MAKE_DDHRESULT( 160 )
+
+/*
+ * There is no 3D present.
+ */
+#define DDERR_NO3D				MAKE_DDHRESULT( 170 )
+
+/*
+ * Operation could not be carried out because there is no alpha accleration
+ * hardware present or available.
+ */
+#define DDERR_NOALPHAHW				MAKE_DDHRESULT( 180 )
+
+
+/*
+ * no clip list available
+ */
+#define DDERR_NOCLIPLIST			MAKE_DDHRESULT( 205 )
+
+/*
+ * Operation could not be carried out because there is no color conversion
+ * hardware present or available.
+ */
+#define DDERR_NOCOLORCONVHW			MAKE_DDHRESULT( 210 )
+
+/*
+ * Create function called without DirectDraw object method SetCooperativeLevel
+ * being called.
+ */
+#define DDERR_NOCOOPERATIVELEVELSET		MAKE_DDHRESULT( 212 )
+
+/*
+ * Surface doesn't currently have a color key
+ */
+#define DDERR_NOCOLORKEY			MAKE_DDHRESULT( 215 )
+
+/*
+ * Operation could not be carried out because there is no hardware support
+ * of the dest color key.
+ */
+#define DDERR_NOCOLORKEYHW			MAKE_DDHRESULT( 220 )
+
+/*
+ * No DirectDraw support possible with current display driver
+ */
+#define DDERR_NODIRECTDRAWSUPPORT		MAKE_DDHRESULT( 222 )
+
+/*
+ * Operation requires the application to have exclusive mode but the
+ * application does not have exclusive mode.
+ */
+#define DDERR_NOEXCLUSIVEMODE			MAKE_DDHRESULT( 225 )
+
+/*
+ * Flipping visible surfaces is not supported.
+ */
+#define DDERR_NOFLIPHW				MAKE_DDHRESULT( 230 )
+
+/*
+ * There is no GDI present.
+ */
+#define DDERR_NOGDI				MAKE_DDHRESULT( 240 )
+
+/*
+ * Operation could not be carried out because there is no hardware present
+ * or available.
+ */
+#define DDERR_NOMIRRORHW			MAKE_DDHRESULT( 250 )
+
+/*
+ * Requested item was not found
+ */
+#define DDERR_NOTFOUND				MAKE_DDHRESULT( 255 )
+
+/*
+ * Operation could not be carried out because there is no overlay hardware
+ * present or available.
+ */
+#define DDERR_NOOVERLAYHW			MAKE_DDHRESULT( 260 )
+
+/*
+ * Operation could not be carried out because the source and destination
+ * rectangles are on the same surface and overlap each other.
+ */
+#define DDERR_OVERLAPPINGRECTS			MAKE_DDHRESULT( 270 )
+
+/*
+ * Operation could not be carried out because there is no appropriate raster
+ * op hardware present or available.
+ */
+#define DDERR_NORASTEROPHW			MAKE_DDHRESULT( 280 )
+
+/*
+ * Operation could not be carried out because there is no rotation hardware
+ * present or available.
+ */
+#define DDERR_NOROTATIONHW			MAKE_DDHRESULT( 290 )
+
+/*
+ * Operation could not be carried out because there is no hardware support
+ * for stretching
+ */
+#define DDERR_NOSTRETCHHW			MAKE_DDHRESULT( 310 )
+
+/*
+ * DirectDrawSurface is not in 4 bit color palette and the requested operation
+ * requires 4 bit color palette.
+ */
+#define DDERR_NOT4BITCOLOR			MAKE_DDHRESULT( 316 )
+
+/*
+ * DirectDrawSurface is not in 4 bit color index palette and the requested
+ * operation requires 4 bit color index palette.
+ */
+#define DDERR_NOT4BITCOLORINDEX			MAKE_DDHRESULT( 317 )
+
+/*
+ * DirectDraw Surface is not in 8 bit color mode and the requested operation
+ * requires 8 bit color.
+ */
+#define DDERR_NOT8BITCOLOR			MAKE_DDHRESULT( 320 )
+
+/*
+ * Operation could not be carried out because there is no texture mapping
+ * hardware present or available.
+ */
+#define DDERR_NOTEXTUREHW			MAKE_DDHRESULT( 330 )
+
+/*
+ * Operation could not be carried out because there is no hardware support
+ * for vertical blank synchronized operations.
+ */
+#define DDERR_NOVSYNCHW				MAKE_DDHRESULT( 335 )
+
+/*
+ * Operation could not be carried out because there is no hardware support
+ * for zbuffer blting.
+ */
+#define DDERR_NOZBUFFERHW			MAKE_DDHRESULT( 340 )
+
+/*
+ * Overlay surfaces could not be z layered based on their BltOrder because
+ * the hardware does not support z layering of overlays.
+ */
+#define DDERR_NOZOVERLAYHW			MAKE_DDHRESULT( 350 )
+
+/*
+ * The hardware needed for the requested operation has already been
+ * allocated.
+ */
+#define DDERR_OUTOFCAPS				MAKE_DDHRESULT( 360 )
+
+/*
+ * DirectDraw does not have enough memory to perform the operation.
+ */
+#define DDERR_OUTOFMEMORY			E_OUTOFMEMORY
+
+/*
+ * DirectDraw does not have enough memory to perform the operation.
+ */
+#define DDERR_OUTOFVIDEOMEMORY			MAKE_DDHRESULT( 380 )
+
+/*
+ * hardware does not support clipped overlays
+ */
+#define DDERR_OVERLAYCANTCLIP			MAKE_DDHRESULT( 382 )
+
+/*
+ * Can only have ony color key active at one time for overlays
+ */
+#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE	MAKE_DDHRESULT( 384 )
+
+/*
+ * Access to this palette is being refused because the palette is already
+ * locked by another thread.
+ */
+#define DDERR_PALETTEBUSY			MAKE_DDHRESULT( 387 )
+
+/*
+ * No src color key specified for this operation.
+ */
+#define DDERR_COLORKEYNOTSET			MAKE_DDHRESULT( 400 )
+
+/*
+ * This surface is already attached to the surface it is being attached to.
+ */
+#define DDERR_SURFACEALREADYATTACHED		MAKE_DDHRESULT( 410 )
+
+/*
+ * This surface is already a dependency of the surface it is being made a
+ * dependency of.
+ */
+#define DDERR_SURFACEALREADYDEPENDENT		MAKE_DDHRESULT( 420 )
+
+/*
+ * Access to this surface is being refused because the surface is already
+ * locked by another thread.
+ */
+#define DDERR_SURFACEBUSY			MAKE_DDHRESULT( 430 )
+
+/*
+ * Access to this surface is being refused because no driver exists
+ * which can supply a pointer to the surface.
+ * This is most likely to happen when attempting to lock the primary
+ * surface when no DCI provider is present.
+ * Will also happen on attempts to lock an optimized surface.
+ */
+#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )
+
+/*
+ * Access to Surface refused because Surface is obscured.
+ */
+#define DDERR_SURFACEISOBSCURED			MAKE_DDHRESULT( 440 )
+
+/*
+ * Access to this surface is being refused because the surface is gone.
+ * The DIRECTDRAWSURFACE object representing this surface should
+ * have Restore called on it.
+ */
+#define DDERR_SURFACELOST			MAKE_DDHRESULT( 450 )
+
+/*
+ * The requested surface is not attached.
+ */
+#define DDERR_SURFACENOTATTACHED		MAKE_DDHRESULT( 460 )
+
+/*
+ * Height requested by DirectDraw is too large.
+ */
+#define DDERR_TOOBIGHEIGHT			MAKE_DDHRESULT( 470 )
+
+/*
+ * Size requested by DirectDraw is too large --	 The individual height and
+ * width are OK.
+ */
+#define DDERR_TOOBIGSIZE			MAKE_DDHRESULT( 480 )
+
+/*
+ * Width requested by DirectDraw is too large.
+ */
+#define DDERR_TOOBIGWIDTH			MAKE_DDHRESULT( 490 )
+
+/*
+ * Action not supported.
+ */
+#define DDERR_UNSUPPORTED			E_NOTIMPL
+
+/*
+ * FOURCC format requested is unsupported by DirectDraw
+ */
+#define DDERR_UNSUPPORTEDFORMAT			MAKE_DDHRESULT( 510 )
+
+/*
+ * Bitmask in the pixel format requested is unsupported by DirectDraw
+ */
+#define DDERR_UNSUPPORTEDMASK			MAKE_DDHRESULT( 520 )
+
+/*
+ * The specified stream contains invalid data
+ */
+#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )
+
+/*
+ * vertical blank is in progress
+ */
+#define DDERR_VERTICALBLANKINPROGRESS		MAKE_DDHRESULT( 537 )
+
+/*
+ * Informs DirectDraw that the previous Blt which is transfering information
+ * to or from this Surface is incomplete.
+ */
+#define DDERR_WASSTILLDRAWING			MAKE_DDHRESULT( 540 )
+
+
+/*
+ * Rectangle provided was not horizontally aligned on reqd. boundary
+ */
+#define DDERR_XALIGN				MAKE_DDHRESULT( 560 )
+
+/*
+ * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
+ * identifier.
+ */
+#define DDERR_INVALIDDIRECTDRAWGUID		MAKE_DDHRESULT( 561 )
+
+/*
+ * A DirectDraw object representing this driver has already been created
+ * for this process.
+ */
+#define DDERR_DIRECTDRAWALREADYCREATED		MAKE_DDHRESULT( 562 )
+
+/*
+ * A hardware only DirectDraw object creation was attempted but the driver
+ * did not support any hardware.
+ */
+#define DDERR_NODIRECTDRAWHW			MAKE_DDHRESULT( 563 )
+
+/*
+ * this process already has created a primary surface
+ */
+#define DDERR_PRIMARYSURFACEALREADYEXISTS	MAKE_DDHRESULT( 564 )
+
+/*
+ * software emulation not available.
+ */
+#define DDERR_NOEMULATION			MAKE_DDHRESULT( 565 )
+
+/*
+ * region passed to Clipper::GetClipList is too small.
+ */
+#define DDERR_REGIONTOOSMALL			MAKE_DDHRESULT( 566 )
+
+/*
+ * an attempt was made to set a clip list for a clipper objec that
+ * is already monitoring an hwnd.
+ */
+#define DDERR_CLIPPERISUSINGHWND		MAKE_DDHRESULT( 567 )
+
+/*
+ * No clipper object attached to surface object
+ */
+#define DDERR_NOCLIPPERATTACHED			MAKE_DDHRESULT( 568 )
+
+/*
+ * Clipper notification requires an HWND or
+ * no HWND has previously been set as the CooperativeLevel HWND.
+ */
+#define DDERR_NOHWND				MAKE_DDHRESULT( 569 )
+
+/*
+ * HWND used by DirectDraw CooperativeLevel has been subclassed,
+ * this prevents DirectDraw from restoring state.
+ */
+#define DDERR_HWNDSUBCLASSED			MAKE_DDHRESULT( 570 )
+
+/*
+ * The CooperativeLevel HWND has already been set.
+ * It can not be reset while the process has surfaces or palettes created.
+ */
+#define DDERR_HWNDALREADYSET			MAKE_DDHRESULT( 571 )
+
+/*
+ * No palette object attached to this surface.
+ */
+#define DDERR_NOPALETTEATTACHED			MAKE_DDHRESULT( 572 )
+
+/*
+ * No hardware support for 16 or 256 color palettes.
+ */
+#define DDERR_NOPALETTEHW			MAKE_DDHRESULT( 573 )
+
+/*
+ * If a clipper object is attached to the source surface passed into a
+ * BltFast call.
+ */
+#define DDERR_BLTFASTCANTCLIP			MAKE_DDHRESULT( 574 )
+
+/*
+ * No blter.
+ */
+#define DDERR_NOBLTHW				MAKE_DDHRESULT( 575 )
+
+/*
+ * No DirectDraw ROP hardware.
+ */
+#define DDERR_NODDROPSHW			MAKE_DDHRESULT( 576 )
+
+/*
+ * returned when GetOverlayPosition is called on a hidden overlay
+ */
+#define DDERR_OVERLAYNOTVISIBLE			MAKE_DDHRESULT( 577 )
+
+/*
+ * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
+ * has never been called on to establish a destionation.
+ */
+#define DDERR_NOOVERLAYDEST			MAKE_DDHRESULT( 578 )
+
+/*
+ * returned when the position of the overlay on the destionation is no longer
+ * legal for that destionation.
+ */
+#define DDERR_INVALIDPOSITION			MAKE_DDHRESULT( 579 )
+
+/*
+ * returned when an overlay member is called for a non-overlay surface
+ */
+#define DDERR_NOTAOVERLAYSURFACE		MAKE_DDHRESULT( 580 )
+
+/*
+ * An attempt was made to set the cooperative level when it was already
+ * set to exclusive.
+ */
+#define DDERR_EXCLUSIVEMODEALREADYSET		MAKE_DDHRESULT( 581 )
+
+/*
+ * An attempt has been made to flip a surface that is not flippable.
+ */
+#define DDERR_NOTFLIPPABLE			MAKE_DDHRESULT( 582 )
+
+/*
+ * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
+ * created.
+ */
+#define DDERR_CANTDUPLICATE			MAKE_DDHRESULT( 583 )
+
+/*
+ * Surface was not locked.  An attempt to unlock a surface that was not
+ * locked at all, or by this process, has been attempted.
+ */
+#define DDERR_NOTLOCKED				MAKE_DDHRESULT( 584 )
+
+/*
+ * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
+ * surface when the surface had no palette AND the display mode was not palette-indexed
+ * (in this case DirectDraw cannot select a proper palette into the DC)
+ */
+#define DDERR_CANTCREATEDC			MAKE_DDHRESULT( 585 )
+
+/*
+ * No DC was ever created for this surface.
+ */
+#define DDERR_NODC				MAKE_DDHRESULT( 586 )
+
+/*
+ * This surface can not be restored because it was created in a different
+ * mode.
+ */
+#define DDERR_WRONGMODE				MAKE_DDHRESULT( 587 )
+
+/*
+ * This surface can not be restored because it is an implicitly created
+ * surface.
+ */
+#define DDERR_IMPLICITLYCREATED			MAKE_DDHRESULT( 588 )
+
+/*
+ * The surface being used is not a palette-based surface
+ */
+#define DDERR_NOTPALETTIZED			MAKE_DDHRESULT( 589 )
+
+
+/*
+ * The display is currently in an unsupported mode
+ */
+#define DDERR_UNSUPPORTEDMODE			MAKE_DDHRESULT( 590 )
+
+/*
+ * Operation could not be carried out because there is no mip-map
+ * texture mapping hardware present or available.
+ */
+#define DDERR_NOMIPMAPHW			MAKE_DDHRESULT( 591 )
+
+/*
+ * The requested action could not be performed because the surface was of
+ * the wrong type.
+ */
+#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )
+
+
+
+/*
+ * Device does not support optimized surfaces, therefore no video memory optimized surfaces
+ */
+#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )
+
+/*
+ * Surface is an optimized surface, but has not yet been allocated any memory
+ */
+#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )
+
+/*
+ * Attempt was made to create or set a device window without first setting
+ * the focus window
+ */
+#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )
+
+/*
+ * A DC has already been returned for this surface. Only one DC can be
+ * retrieved per surface.
+ */
+#define DDERR_DCALREADYCREATED			MAKE_DDHRESULT( 620 )
+
+/*
+ * An attempt was made to allocate non-local video memory from a device
+ * that does not support non-local video memory.
+ */
+#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )
+
+/*
+ * The attempt to page lock a surface failed.
+ */
+#define DDERR_CANTPAGELOCK			MAKE_DDHRESULT( 640 )
+
+
+/*
+ * The attempt to page unlock a surface failed.
+ */
+#define DDERR_CANTPAGEUNLOCK			MAKE_DDHRESULT( 660 )
+
+/*
+ * An attempt was made to page unlock a surface with no outstanding page locks.
+ */
+#define DDERR_NOTPAGELOCKED			MAKE_DDHRESULT( 680 )
+
+/*
+ * There is more data available than the specified buffer size could hold
+ */
+#define DDERR_MOREDATA         			MAKE_DDHRESULT( 690 )
+
+/*
+ * The data has expired and is therefore no longer valid.
+ */
+#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )
+
+/*
+ * The video port is not active
+ */
+#define DDERR_VIDEONOTACTIVE   			MAKE_DDHRESULT( 695 )
+
+/*
+ * Surfaces created by one direct draw device cannot be used directly by
+ * another direct draw device.
+ */
+#define DDERR_DEVICEDOESNTOWNSURFACE   		MAKE_DDHRESULT( 699 )
+
+
+/*
+ * An attempt was made to invoke an interface member of a DirectDraw object
+ * created by CoCreateInstance() before it was initialized.
+ */
+#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED
+
+
+/* Alpha bit depth constants */
+
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
+
diff -ruN SDL-1.2.13/include/dinput.h___ SDL-1.2.13_OOx64/include/dinput.h___
--- SDL-1.2.13/include/dinput.h___	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/dinput.h___	1999-11-19 17:32:22 +0000
@@ -0,0 +1,1849 @@
+/****************************************************************************
+ *
+ *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
+ *
+ *  File:       dinput.h
+ *  Content:    DirectInput include file
+ *
+ ****************************************************************************/
+
+#ifndef __DINPUT_INCLUDED__
+#define __DINPUT_INCLUDED__
+
+#ifndef DIJ_RINGZERO
+
+#ifdef _WIN32
+#define COM_NO_WINDOWS_H
+#include <objbase.h>
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef DIRECTINPUT_VERSION
+#define DIRECTINPUT_VERSION         0x0500
+#endif
+
+#ifndef DIJ_RINGZERO
+/****************************************************************************
+ *
+ *      Class IDs
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(CLSID_DirectInput,      0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(CLSID_DirectInputDevice,0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Interfaces
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+
+/****************************************************************************
+ *
+ *      Predefined object types
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Predefined product GUIDs
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Predefined force feedback effects
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Interfaces and Structures...
+ *
+ ****************************************************************************/
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+
+/****************************************************************************
+ *
+ *      IDirectInputEffect
+ *
+ ****************************************************************************/
+
+#define DIEFT_ALL                   0x00000000
+
+#define DIEFT_CONSTANTFORCE         0x00000001
+#define DIEFT_RAMPFORCE             0x00000002
+#define DIEFT_PERIODIC              0x00000003
+#define DIEFT_CONDITION             0x00000004
+#define DIEFT_CUSTOMFORCE           0x00000005
+#define DIEFT_HARDWARE              0x000000FF
+
+#define DIEFT_FFATTACK              0x00000200
+#define DIEFT_FFFADE                0x00000400
+#define DIEFT_SATURATION            0x00000800
+#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
+#define DIEFT_POSNEGSATURATION      0x00002000
+#define DIEFT_DEADBAND              0x00004000
+
+#define DIEFT_GETTYPE(n)            LOBYTE(n)
+
+#define DI_DEGREES                  100
+#define DI_FFNOMINALMAX             10000
+#define DI_SECONDS                  1000000
+
+typedef struct DICONSTANTFORCE {
+    LONG  lMagnitude;
+} DICONSTANTFORCE, *LPDICONSTANTFORCE;
+typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;
+
+typedef struct DIRAMPFORCE {
+    LONG  lStart;
+    LONG  lEnd;
+} DIRAMPFORCE, *LPDIRAMPFORCE;
+typedef const DIRAMPFORCE *LPCDIRAMPFORCE;
+
+typedef struct DIPERIODIC {
+    DWORD dwMagnitude;
+    LONG  lOffset;
+    DWORD dwPhase;
+    DWORD dwPeriod;
+} DIPERIODIC, *LPDIPERIODIC;
+typedef const DIPERIODIC *LPCDIPERIODIC;
+
+typedef struct DICONDITION {
+    LONG  lOffset;
+    LONG  lPositiveCoefficient;
+    LONG  lNegativeCoefficient;
+    DWORD dwPositiveSaturation;
+    DWORD dwNegativeSaturation;
+    LONG  lDeadBand;
+} DICONDITION, *LPDICONDITION;
+typedef const DICONDITION *LPCDICONDITION;
+
+typedef struct DICUSTOMFORCE {
+    DWORD cChannels;
+    DWORD dwSamplePeriod;
+    DWORD cSamples;
+    LPLONG rglForceData;
+} DICUSTOMFORCE, *LPDICUSTOMFORCE;
+typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;
+
+typedef struct DIENVELOPE {
+    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
+    DWORD dwAttackLevel;
+    DWORD dwAttackTime;             /* Microseconds         */
+    DWORD dwFadeLevel;
+    DWORD dwFadeTime;               /* Microseconds         */
+} DIENVELOPE, *LPDIENVELOPE;
+typedef const DIENVELOPE *LPCDIENVELOPE;
+
+typedef struct DIEFFECT {
+    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
+    DWORD dwFlags;                  /* DIEFF_*              */
+    DWORD dwDuration;               /* Microseconds         */
+    DWORD dwSamplePeriod;           /* Microseconds         */
+    DWORD dwGain;
+    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
+    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
+    DWORD cAxes;                    /* Number of axes       */
+    LPDWORD rgdwAxes;               /* Array of axes        */
+    LPLONG rglDirection;            /* Array of directions  */
+    LPDIENVELOPE lpEnvelope;        /* Optional             */
+    DWORD cbTypeSpecificParams;     /* Size of params       */
+    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
+} DIEFFECT, *LPDIEFFECT;
+typedef const DIEFFECT *LPCDIEFFECT;
+
+#define DIEFF_OBJECTIDS             0x00000001
+#define DIEFF_OBJECTOFFSETS         0x00000002
+#define DIEFF_CARTESIAN             0x00000010
+#define DIEFF_POLAR                 0x00000020
+#define DIEFF_SPHERICAL             0x00000040
+
+#define DIEP_DURATION               0x00000001
+#define DIEP_SAMPLEPERIOD           0x00000002
+#define DIEP_GAIN                   0x00000004
+#define DIEP_TRIGGERBUTTON          0x00000008
+#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
+#define DIEP_AXES                   0x00000020
+#define DIEP_DIRECTION              0x00000040
+#define DIEP_ENVELOPE               0x00000080
+#define DIEP_TYPESPECIFICPARAMS     0x00000100
+#define DIEP_ALLPARAMS              0x000001FF
+#define DIEP_START                  0x20000000
+#define DIEP_NORESTART              0x40000000
+#define DIEP_NODOWNLOAD             0x80000000
+#define DIEB_NOTRIGGER              0xFFFFFFFF
+
+#define DIES_SOLO                   0x00000001
+#define DIES_NODOWNLOAD             0x80000000
+
+#define DIEGES_PLAYING              0x00000001
+#define DIEGES_EMULATED             0x00000002
+
+typedef struct DIEFFESCAPE {
+    DWORD   dwSize;
+    DWORD   dwCommand;
+    LPVOID  lpvInBuffer;
+    DWORD   cbInBuffer;
+    LPVOID  lpvOutBuffer;
+    DWORD   cbOutBuffer;
+} DIEFFESCAPE, *LPDIEFFESCAPE;
+
+#ifndef DIJ_RINGZERO
+
+#undef INTERFACE
+#define INTERFACE IDirectInputEffect
+
+DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputEffect methods ***/
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
+    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
+    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
+    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
+    STDMETHOD(Stop)(THIS) PURE;
+    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
+    STDMETHOD(Download)(THIS) PURE;
+    STDMETHOD(Unload)(THIS) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+};
+
+typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
+#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
+#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
+#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
+#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
+#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
+#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
+#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
+#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#else
+#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputEffect_AddRef(p) (p)->AddRef()
+#define IDirectInputEffect_Release(p) (p)->Release()
+#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
+#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
+#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
+#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
+#define IDirectInputEffect_Stop(p) (p)->Stop()
+#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
+#define IDirectInputEffect_Download(p) (p)->Download()
+#define IDirectInputEffect_Unload(p) (p)->Unload()
+#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+/****************************************************************************
+ *
+ *      IDirectInputDevice
+ *
+ ****************************************************************************/
+
+#define DIDEVTYPE_DEVICE    1
+#define DIDEVTYPE_MOUSE     2
+#define DIDEVTYPE_KEYBOARD  3
+#define DIDEVTYPE_JOYSTICK  4
+#define DIDEVTYPE_HID       0x00010000
+
+#define DIDEVTYPEMOUSE_UNKNOWN          1
+#define DIDEVTYPEMOUSE_TRADITIONAL      2
+#define DIDEVTYPEMOUSE_FINGERSTICK      3
+#define DIDEVTYPEMOUSE_TOUCHPAD         4
+#define DIDEVTYPEMOUSE_TRACKBALL        5
+
+#define DIDEVTYPEKEYBOARD_UNKNOWN       0
+#define DIDEVTYPEKEYBOARD_PCXT          1
+#define DIDEVTYPEKEYBOARD_OLIVETTI      2
+#define DIDEVTYPEKEYBOARD_PCAT          3
+#define DIDEVTYPEKEYBOARD_PCENH         4
+#define DIDEVTYPEKEYBOARD_NOKIA1050     5
+#define DIDEVTYPEKEYBOARD_NOKIA9140     6
+#define DIDEVTYPEKEYBOARD_NEC98         7
+#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
+#define DIDEVTYPEKEYBOARD_NEC98106      9
+#define DIDEVTYPEKEYBOARD_JAPAN106     10
+#define DIDEVTYPEKEYBOARD_JAPANAX      11
+#define DIDEVTYPEKEYBOARD_J3100        12
+
+#define DIDEVTYPEJOYSTICK_UNKNOWN       1
+#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
+#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
+#define DIDEVTYPEJOYSTICK_GAMEPAD       4
+#define DIDEVTYPEJOYSTICK_RUDDER        5
+#define DIDEVTYPEJOYSTICK_WHEEL         6
+#define DIDEVTYPEJOYSTICK_HEADTRACKER   7
+
+#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
+#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* This structure is defined for DirectX 3.0 compatibility */
+
+typedef struct DIDEVCAPS_DX3 {
+    DWORD   dwSize;
+    DWORD   dwFlags;
+    DWORD   dwDevType;
+    DWORD   dwAxes;
+    DWORD   dwButtons;
+    DWORD   dwPOVs;
+} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVCAPS {
+    DWORD   dwSize;
+    DWORD   dwFlags;
+    DWORD   dwDevType;
+    DWORD   dwAxes;
+    DWORD   dwButtons;
+    DWORD   dwPOVs;
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFSamplePeriod;
+    DWORD   dwFFMinTimeResolution;
+    DWORD   dwFirmwareRevision;
+    DWORD   dwHardwareRevision;
+    DWORD   dwFFDriverVersion;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVCAPS, *LPDIDEVCAPS;
+
+#define DIDC_ATTACHED           0x00000001
+#define DIDC_POLLEDDEVICE       0x00000002
+#define DIDC_EMULATED           0x00000004
+#define DIDC_POLLEDDATAFORMAT   0x00000008
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIDC_FORCEFEEDBACK      0x00000100
+#define DIDC_FFATTACK           0x00000200
+#define DIDC_FFFADE             0x00000400
+#define DIDC_SATURATION         0x00000800
+#define DIDC_POSNEGCOEFFICIENTS 0x00001000
+#define DIDC_POSNEGSATURATION   0x00002000
+#define DIDC_DEADBAND           0x00004000
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+#define DIDFT_ALL           0x00000000
+
+#define DIDFT_RELAXIS       0x00000001
+#define DIDFT_ABSAXIS       0x00000002
+#define DIDFT_AXIS          0x00000003
+
+#define DIDFT_PSHBUTTON     0x00000004
+#define DIDFT_TGLBUTTON     0x00000008
+#define DIDFT_BUTTON        0x0000000C
+
+#define DIDFT_POV           0x00000010
+
+#define DIDFT_COLLECTION    0x00000040
+#define DIDFT_NODATA        0x00000080
+
+#define DIDFT_ANYINSTANCE   0x00FFFF00
+#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
+#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
+#define DIDFT_GETTYPE(n)     LOBYTE(n)
+#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
+#define DIDFT_FFACTUATOR        0x01000000
+#define DIDFT_FFEFFECTTRIGGER   0x02000000
+
+#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
+#define DIDFT_NOCOLLECTION      0x00FFFF00
+
+
+#ifndef DIJ_RINGZERO
+
+typedef struct _DIOBJECTDATAFORMAT {
+    const GUID *pguid;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
+typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;
+
+typedef struct _DIDATAFORMAT {
+    DWORD   dwSize;
+    DWORD   dwObjSize;
+    DWORD   dwFlags;
+    DWORD   dwDataSize;
+    DWORD   dwNumObjs;
+    LPDIOBJECTDATAFORMAT rgodf;
+} DIDATAFORMAT, *LPDIDATAFORMAT;
+typedef const DIDATAFORMAT *LPCDIDATAFORMAT;
+
+#define DIDF_ABSAXIS            0x00000001
+#define DIDF_RELAXIS            0x00000002
+
+extern const DIDATAFORMAT c_dfDIMouse;
+extern const DIDATAFORMAT c_dfDIKeyboard;
+extern const DIDATAFORMAT c_dfDIJoystick;
+extern const DIDATAFORMAT c_dfDIJoystick2;
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* These structures are defined for DirectX 3.0 compatibility */
+
+typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    CHAR    tszName[MAX_PATH];
+} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
+typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    WCHAR   tszName[MAX_PATH];
+} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
+#ifdef UNICODE
+typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
+typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
+#else
+typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
+typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
+#endif // UNICODE
+typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
+typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
+typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVICEOBJECTINSTANCEA {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    CHAR    tszName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFMaxForce;
+    DWORD   dwFFForceResolution;
+    WORD    wCollectionNumber;
+    WORD    wDesignatorIndex;
+    WORD    wUsagePage;
+    WORD    wUsage;
+    DWORD   dwDimension;
+    WORD    wExponent;
+    WORD    wReserved;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
+typedef struct DIDEVICEOBJECTINSTANCEW {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    WCHAR   tszName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFMaxForce;
+    DWORD   dwFFForceResolution;
+    WORD    wCollectionNumber;
+    WORD    wDesignatorIndex;
+    WORD    wUsagePage;
+    WORD    wUsage;
+    DWORD   dwDimension;
+    WORD    wExponent;
+    WORD    wReserved;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
+#ifdef UNICODE
+typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
+typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
+#else
+typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
+typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
+#endif // UNICODE
+typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
+typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
+typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;
+
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
+#else
+#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
+#endif // !UNICODE
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIDOI_FFACTUATOR        0x00000001
+#define DIDOI_FFEFFECTTRIGGER   0x00000002
+#define DIDOI_POLLED            0x00008000
+#define DIDOI_ASPECTPOSITION    0x00000100
+#define DIDOI_ASPECTVELOCITY    0x00000200
+#define DIDOI_ASPECTACCEL       0x00000300
+#define DIDOI_ASPECTFORCE       0x00000400
+#define DIDOI_ASPECTMASK        0x00000F00
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIPROPHEADER {
+    DWORD   dwSize;
+    DWORD   dwHeaderSize;
+    DWORD   dwObj;
+    DWORD   dwHow;
+} DIPROPHEADER, *LPDIPROPHEADER;
+typedef const DIPROPHEADER *LPCDIPROPHEADER;
+
+#define DIPH_DEVICE             0
+#define DIPH_BYOFFSET           1
+#define DIPH_BYID               2
+
+typedef struct DIPROPDWORD {
+    DIPROPHEADER diph;
+    DWORD   dwData;
+} DIPROPDWORD, *LPDIPROPDWORD;
+typedef const DIPROPDWORD *LPCDIPROPDWORD;
+
+typedef struct DIPROPRANGE {
+    DIPROPHEADER diph;
+    LONG    lMin;
+    LONG    lMax;
+} DIPROPRANGE, *LPDIPROPRANGE;
+typedef const DIPROPRANGE *LPCDIPROPRANGE;
+
+#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
+#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)
+
+#ifdef __cplusplus
+#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
+#else
+#define MAKEDIPROP(prop)    ((REFGUID)(prop))
+#endif
+
+#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)
+
+#define DIPROP_AXISMODE         MAKEDIPROP(2)
+
+#define DIPROPAXISMODE_ABS      0
+#define DIPROPAXISMODE_REL      1
+
+#define DIPROP_GRANULARITY      MAKEDIPROP(3)
+
+#define DIPROP_RANGE            MAKEDIPROP(4)
+
+#define DIPROP_DEADZONE         MAKEDIPROP(5)
+
+#define DIPROP_SATURATION       MAKEDIPROP(6)
+
+#define DIPROP_FFGAIN           MAKEDIPROP(7)
+
+#define DIPROP_FFLOAD           MAKEDIPROP(8)
+
+#define DIPROP_AUTOCENTER       MAKEDIPROP(9)
+
+#define DIPROPAUTOCENTER_OFF    0
+#define DIPROPAUTOCENTER_ON     1
+
+#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)
+
+#define DIPROPCALIBRATIONMODE_COOKED    0
+#define DIPROPCALIBRATIONMODE_RAW       1
+
+typedef struct DIDEVICEOBJECTDATA {
+    DWORD   dwOfs;
+    DWORD   dwData;
+    DWORD   dwTimeStamp;
+    DWORD   dwSequence;
+} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
+typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;
+
+#define DIGDD_PEEK          0x00000001
+
+#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
+                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
+#define DISCL_EXCLUSIVE     0x00000001
+#define DISCL_NONEXCLUSIVE  0x00000002
+#define DISCL_FOREGROUND    0x00000004
+#define DISCL_BACKGROUND    0x00000008
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* These structures are defined for DirectX 3.0 compatibility */
+
+typedef struct DIDEVICEINSTANCE_DX3A {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    CHAR    tszInstanceName[MAX_PATH];
+    CHAR    tszProductName[MAX_PATH];
+} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
+typedef struct DIDEVICEINSTANCE_DX3W {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    WCHAR   tszInstanceName[MAX_PATH];
+    WCHAR   tszProductName[MAX_PATH];
+} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
+#ifdef UNICODE
+typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
+typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
+#else
+typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
+typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
+#endif // UNICODE
+typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
+typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
+typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVICEINSTANCEA {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    CHAR    tszInstanceName[MAX_PATH];
+    CHAR    tszProductName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    GUID    guidFFDriver;
+    WORD    wUsagePage;
+    WORD    wUsage;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
+typedef struct DIDEVICEINSTANCEW {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    WCHAR   tszInstanceName[MAX_PATH];
+    WCHAR   tszProductName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    GUID    guidFFDriver;
+    WORD    wUsagePage;
+    WORD    wUsage;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
+#ifdef UNICODE
+typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
+typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
+#else
+typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
+typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
+#endif // UNICODE
+typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
+typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
+typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDeviceW
+
+DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceW methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+};
+
+typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDeviceA
+
+DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceA methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+};
+
+typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice IID_IDirectInputDeviceW
+#define IDirectInputDevice IDirectInputDeviceW
+#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
+#else
+#define IID_IDirectInputDevice IID_IDirectInputDeviceA
+#define IDirectInputDevice IDirectInputDeviceA
+#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
+#endif
+typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#else
+#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice_Release(p) (p)->Release()
+#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+
+#define DISFFC_RESET            0x00000001
+#define DISFFC_STOPALL          0x00000002
+#define DISFFC_PAUSE            0x00000004
+#define DISFFC_CONTINUE         0x00000008
+#define DISFFC_SETACTUATORSON   0x00000010
+#define DISFFC_SETACTUATORSOFF  0x00000020
+
+#define DIGFFS_EMPTY            0x00000001
+#define DIGFFS_STOPPED          0x00000002
+#define DIGFFS_PAUSED           0x00000004
+#define DIGFFS_ACTUATORSON      0x00000010
+#define DIGFFS_ACTUATORSOFF     0x00000020
+#define DIGFFS_POWERON          0x00000040
+#define DIGFFS_POWEROFF         0x00000080
+#define DIGFFS_SAFETYSWITCHON   0x00000100
+#define DIGFFS_SAFETYSWITCHOFF  0x00000200
+#define DIGFFS_USERFFSWITCHON   0x00000400
+#define DIGFFS_USERFFSWITCHOFF  0x00000800
+#define DIGFFS_DEVICELOST       0x80000000
+
+#ifndef DIJ_RINGZERO
+
+typedef struct DIEFFECTINFOA {
+    DWORD   dwSize;
+    GUID    guid;
+    DWORD   dwEffType;
+    DWORD   dwStaticParams;
+    DWORD   dwDynamicParams;
+    CHAR    tszName[MAX_PATH];
+} DIEFFECTINFOA, *LPDIEFFECTINFOA;
+typedef struct DIEFFECTINFOW {
+    DWORD   dwSize;
+    GUID    guid;
+    DWORD   dwEffType;
+    DWORD   dwStaticParams;
+    DWORD   dwDynamicParams;
+    WCHAR   tszName[MAX_PATH];
+} DIEFFECTINFOW, *LPDIEFFECTINFOW;
+#ifdef UNICODE
+typedef DIEFFECTINFOW DIEFFECTINFO;
+typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
+#else
+typedef DIEFFECTINFOA DIEFFECTINFO;
+typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
+#endif // UNICODE
+typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
+typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
+typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;
+
+typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
+#else
+#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
+#endif // !UNICODE
+typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice2W
+
+DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceW methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+
+    /*** IDirectInputDevice2W methods ***/
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice2A
+
+DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceA methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+
+    /*** IDirectInputDevice2A methods ***/
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
+#define IDirectInputDevice2 IDirectInputDevice2W
+#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
+#else
+#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
+#define IDirectInputDevice2 IDirectInputDevice2A
+#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
+#endif
+typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
+#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
+#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
+#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
+#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
+#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
+#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
+#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
+#else
+#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice2_Release(p) (p)->Release()
+#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
+#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
+#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
+#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
+#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
+#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
+#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
+#define IDirectInputDevice2_Poll(p) (p)->Poll()
+#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+/****************************************************************************
+ *
+ *      Mouse
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+typedef struct _DIMOUSESTATE {
+    LONG    lX;
+    LONG    lY;
+    LONG    lZ;
+    BYTE    rgbButtons[4];
+} DIMOUSESTATE, *LPDIMOUSESTATE;
+
+#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
+#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
+#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
+#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
+#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
+#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
+#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Keyboard
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+/****************************************************************************
+ *
+ *      DirectInput keyboard scan codes
+ *
+ ****************************************************************************/
+
+#define DIK_ESCAPE          0x01
+#define DIK_1               0x02
+#define DIK_2               0x03
+#define DIK_3               0x04
+#define DIK_4               0x05
+#define DIK_5               0x06
+#define DIK_6               0x07
+#define DIK_7               0x08
+#define DIK_8               0x09
+#define DIK_9               0x0A
+#define DIK_0               0x0B
+#define DIK_MINUS           0x0C    /* - on main keyboard */
+#define DIK_EQUALS          0x0D
+#define DIK_BACK            0x0E    /* backspace */
+#define DIK_TAB             0x0F
+#define DIK_Q               0x10
+#define DIK_W               0x11
+#define DIK_E               0x12
+#define DIK_R               0x13
+#define DIK_T               0x14
+#define DIK_Y               0x15
+#define DIK_U               0x16
+#define DIK_I               0x17
+#define DIK_O               0x18
+#define DIK_P               0x19
+#define DIK_LBRACKET        0x1A
+#define DIK_RBRACKET        0x1B
+#define DIK_RETURN          0x1C    /* Enter on main keyboard */
+#define DIK_LCONTROL        0x1D
+#define DIK_A               0x1E
+#define DIK_S               0x1F
+#define DIK_D               0x20
+#define DIK_F               0x21
+#define DIK_G               0x22
+#define DIK_H               0x23
+#define DIK_J               0x24
+#define DIK_K               0x25
+#define DIK_L               0x26
+#define DIK_SEMICOLON       0x27
+#define DIK_APOSTROPHE      0x28
+#define DIK_GRAVE           0x29    /* accent grave */
+#define DIK_LSHIFT          0x2A
+#define DIK_BACKSLASH       0x2B
+#define DIK_Z               0x2C
+#define DIK_X               0x2D
+#define DIK_C               0x2E
+#define DIK_V               0x2F
+#define DIK_B               0x30
+#define DIK_N               0x31
+#define DIK_M               0x32
+#define DIK_COMMA           0x33
+#define DIK_PERIOD          0x34    /* . on main keyboard */
+#define DIK_SLASH           0x35    /* / on main keyboard */
+#define DIK_RSHIFT          0x36
+#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
+#define DIK_LMENU           0x38    /* left Alt */
+#define DIK_SPACE           0x39
+#define DIK_CAPITAL         0x3A
+#define DIK_F1              0x3B
+#define DIK_F2              0x3C
+#define DIK_F3              0x3D
+#define DIK_F4              0x3E
+#define DIK_F5              0x3F
+#define DIK_F6              0x40
+#define DIK_F7              0x41
+#define DIK_F8              0x42
+#define DIK_F9              0x43
+#define DIK_F10             0x44
+#define DIK_NUMLOCK         0x45
+#define DIK_SCROLL          0x46    /* Scroll Lock */
+#define DIK_NUMPAD7         0x47
+#define DIK_NUMPAD8         0x48
+#define DIK_NUMPAD9         0x49
+#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
+#define DIK_NUMPAD4         0x4B
+#define DIK_NUMPAD5         0x4C
+#define DIK_NUMPAD6         0x4D
+#define DIK_ADD             0x4E    /* + on numeric keypad */
+#define DIK_NUMPAD1         0x4F
+#define DIK_NUMPAD2         0x50
+#define DIK_NUMPAD3         0x51
+#define DIK_NUMPAD0         0x52
+#define DIK_DECIMAL         0x53    /* . on numeric keypad */
+#define DIK_F11             0x57
+#define DIK_F12             0x58
+
+#define DIK_F13             0x64    /*                     (NEC PC98) */
+#define DIK_F14             0x65    /*                     (NEC PC98) */
+#define DIK_F15             0x66    /*                     (NEC PC98) */
+
+#define DIK_KANA            0x70    /* (Japanese keyboard)            */
+#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
+#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
+#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
+#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
+#define DIK_CIRCUMFLEX      0x90    /* (Japanese keyboard)            */
+#define DIK_AT              0x91    /*                     (NEC PC98) */
+#define DIK_COLON           0x92    /*                     (NEC PC98) */
+#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
+#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
+#define DIK_STOP            0x95    /*                     (NEC PC98) */
+#define DIK_AX              0x96    /*                     (Japan AX) */
+#define DIK_UNLABELED       0x97    /*                        (J3100) */
+#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
+#define DIK_RCONTROL        0x9D
+#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
+#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
+#define DIK_SYSRQ           0xB7
+#define DIK_RMENU           0xB8    /* right Alt */
+#define DIK_HOME            0xC7    /* Home on arrow keypad */
+#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
+#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
+#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
+#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
+#define DIK_END             0xCF    /* End on arrow keypad */
+#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
+#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
+#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
+#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
+#define DIK_LWIN            0xDB    /* Left Windows key */
+#define DIK_RWIN            0xDC    /* Right Windows key */
+#define DIK_APPS            0xDD    /* AppMenu key */
+
+/*
+ *  Alternate names for keys, to facilitate transition from DOS.
+ */
+#define DIK_BACKSPACE       DIK_BACK            /* backspace */
+#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
+#define DIK_LALT            DIK_LMENU           /* left Alt */
+#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
+#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
+#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
+#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
+#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
+#define DIK_RALT            DIK_RMENU           /* right Alt */
+#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
+#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
+#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
+#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
+#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
+#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Joystick
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+typedef struct DIJOYSTATE {
+    LONG    lX;                     /* x-axis position              */
+    LONG    lY;                     /* y-axis position              */
+    LONG    lZ;                     /* z-axis position              */
+    LONG    lRx;                    /* x-axis rotation              */
+    LONG    lRy;                    /* y-axis rotation              */
+    LONG    lRz;                    /* z-axis rotation              */
+    LONG    rglSlider[2];           /* extra axes positions         */
+    DWORD   rgdwPOV[4];             /* POV directions               */
+    BYTE    rgbButtons[32];         /* 32 buttons                   */
+} DIJOYSTATE, *LPDIJOYSTATE;
+
+typedef struct DIJOYSTATE2 {
+    LONG    lX;                     /* x-axis position              */
+    LONG    lY;                     /* y-axis position              */
+    LONG    lZ;                     /* z-axis position              */
+    LONG    lRx;                    /* x-axis rotation              */
+    LONG    lRy;                    /* y-axis rotation              */
+    LONG    lRz;                    /* z-axis rotation              */
+    LONG    rglSlider[2];           /* extra axes positions         */
+    DWORD   rgdwPOV[4];             /* POV directions               */
+    BYTE    rgbButtons[128];        /* 128 buttons                  */
+    LONG    lVX;                    /* x-axis velocity              */
+    LONG    lVY;                    /* y-axis velocity              */
+    LONG    lVZ;                    /* z-axis velocity              */
+    LONG    lVRx;                   /* x-axis angular velocity      */
+    LONG    lVRy;                   /* y-axis angular velocity      */
+    LONG    lVRz;                   /* z-axis angular velocity      */
+    LONG    rglVSlider[2];          /* extra axes velocities        */
+    LONG    lAX;                    /* x-axis acceleration          */
+    LONG    lAY;                    /* y-axis acceleration          */
+    LONG    lAZ;                    /* z-axis acceleration          */
+    LONG    lARx;                   /* x-axis angular acceleration  */
+    LONG    lARy;                   /* y-axis angular acceleration  */
+    LONG    lARz;                   /* z-axis angular acceleration  */
+    LONG    rglASlider[2];          /* extra axes accelerations     */
+    LONG    lFX;                    /* x-axis force                 */
+    LONG    lFY;                    /* y-axis force                 */
+    LONG    lFZ;                    /* z-axis force                 */
+    LONG    lFRx;                   /* x-axis torque                */
+    LONG    lFRy;                   /* y-axis torque                */
+    LONG    lFRz;                   /* z-axis torque                */
+    LONG    rglFSlider[2];          /* extra axes forces            */
+} DIJOYSTATE2, *LPDIJOYSTATE2;
+
+#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
+#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
+#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
+#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
+#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
+#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
+#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
+                                                        (n) * sizeof(LONG))
+#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
+                                                        (n) * sizeof(DWORD))
+#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
+#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
+#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
+#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
+#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
+#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
+#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
+#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
+#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
+#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
+#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
+#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
+#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
+#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
+#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
+#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
+#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
+#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
+#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
+#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
+#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
+#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
+#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
+#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
+#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
+#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
+#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
+#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
+#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
+#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
+#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
+#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
+#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)
+
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *  IDirectInput
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+#define DIENUM_STOP             0
+#define DIENUM_CONTINUE         1
+
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
+#else
+#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
+#endif // !UNICODE
+
+#define DIEDFL_ALLDEVICES       0x00000000
+#define DIEDFL_ATTACHEDONLY     0x00000001
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIEDFL_FORCEFEEDBACK    0x00000100
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+#undef INTERFACE
+#define INTERFACE IDirectInputW
+
+DECLARE_INTERFACE_(IDirectInputW, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputW methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+};
+
+typedef struct IDirectInputW *LPDIRECTINPUTW;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputA
+
+DECLARE_INTERFACE_(IDirectInputA, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputA methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+};
+
+typedef struct IDirectInputA *LPDIRECTINPUTA;
+
+#ifdef UNICODE
+#define IID_IDirectInput IID_IDirectInputW
+#define IDirectInput IDirectInputW
+#define IDirectInputVtbl IDirectInputWVtbl
+#else
+#define IID_IDirectInput IID_IDirectInputA
+#define IDirectInput IDirectInputA
+#define IDirectInputVtbl IDirectInputAVtbl
+#endif
+typedef struct IDirectInput *LPDIRECTINPUT;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#else
+#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput_AddRef(p) (p)->AddRef()
+#define IDirectInput_Release(p) (p)->Release()
+#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
+#endif
+
+#undef INTERFACE
+#define INTERFACE IDirectInput2W
+
+DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputW methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+
+    /*** IDirectInput2W methods ***/
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
+};
+
+typedef struct IDirectInput2W *LPDIRECTINPUT2W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInput2A
+
+DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputA methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+
+    /*** IDirectInput2A methods ***/
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
+};
+
+typedef struct IDirectInput2A *LPDIRECTINPUT2A;
+
+#ifdef UNICODE
+#define IID_IDirectInput2 IID_IDirectInput2W
+#define IDirectInput2 IDirectInput2W
+#define IDirectInput2Vtbl IDirectInput2WVtbl
+#else
+#define IID_IDirectInput2 IID_IDirectInput2A
+#define IDirectInput2 IDirectInput2A
+#define IDirectInput2Vtbl IDirectInput2AVtbl
+#endif
+typedef struct IDirectInput2 *LPDIRECTINPUT2;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
+#else
+#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput2_AddRef(p) (p)->AddRef()
+#define IDirectInput2_Release(p) (p)->Release()
+#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
+#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
+#endif
+
+extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
+extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
+#ifdef UNICODE
+#define DirectInputCreate  DirectInputCreateW
+#else
+#define DirectInputCreate  DirectInputCreateA
+#endif // !UNICODE
+
+#endif /* DIJ_RINGZERO */
+
+
+/****************************************************************************
+ *
+ *  Return Codes
+ *
+ ****************************************************************************/
+
+/*
+ *  The operation completed successfully.
+ */
+#define DI_OK                           S_OK
+
+/*
+ *  The device exists but is not currently attached.
+ */
+#define DI_NOTATTACHED                  S_FALSE
+
+/*
+ *  The device buffer overflowed.  Some input was lost.
+ */
+#define DI_BUFFEROVERFLOW               S_FALSE
+
+/*
+ *  The change in device properties had no effect.
+ */
+#define DI_PROPNOEFFECT                 S_FALSE
+
+/*
+ *  The operation had no effect.
+ */
+#define DI_NOEFFECT                     S_FALSE
+
+/*
+ *  The device is a polled device.  As a result, device buffering
+ *  will not collect any data and event notifications will not be
+ *  signalled until GetDeviceState is called.
+ */
+#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but the effect was not
+ *  downloaded because the device is not exclusively acquired
+ *  or because the DIEP_NODOWNLOAD flag was passed.
+ */
+#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but in order to change
+ *  the parameters, the effect needed to be restarted.
+ */
+#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but some of them were
+ *  beyond the capabilities of the device and were truncated.
+ */
+#define DI_TRUNCATED                    ((HRESULT)0x00000008L)
+
+/*
+ *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
+ */
+#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)
+
+/*
+ *  The application requires a newer version of DirectInput.
+ */
+#define DIERR_OLDDIRECTINPUTVERSION     \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)
+
+/*
+ *  The application was written for an unsupported prerelease version
+ *  of DirectInput.
+ */
+#define DIERR_BETADIRECTINPUTVERSION    \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)
+
+/*
+ *  The object could not be created due to an incompatible driver version
+ *  or mismatched or incomplete driver components.
+ */
+#define DIERR_BADDRIVERVER              \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)
+
+/*
+ * The device or device instance or effect is not registered with DirectInput.
+ */
+#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG
+
+/*
+ * The requested object does not exist.
+ */
+#define DIERR_NOTFOUND                  \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
+
+/*
+ * The requested object does not exist.
+ */
+#define DIERR_OBJECTNOTFOUND            \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
+
+/*
+ * An invalid parameter was passed to the returning function,
+ * or the object was not in a state that admitted the function
+ * to be called.
+ */
+#define DIERR_INVALIDPARAM              E_INVALIDARG
+
+/*
+ * The specified interface is not supported by the object
+ */
+#define DIERR_NOINTERFACE               E_NOINTERFACE
+
+/*
+ * An undetermined error occured inside the DInput subsystem
+ */
+#define DIERR_GENERIC                   E_FAIL
+
+/*
+ * The DInput subsystem couldn't allocate sufficient memory to complete the
+ * caller's request.
+ */
+#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY
+
+/*
+ * The function called is not supported at this time
+ */
+#define DIERR_UNSUPPORTED               E_NOTIMPL
+
+/*
+ * This object has not been initialized
+ */
+#define DIERR_NOTINITIALIZED            \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)
+
+/*
+ * This object is already initialized
+ */
+#define DIERR_ALREADYINITIALIZED        \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)
+
+/*
+ * This object does not support aggregation
+ */
+#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
+
+/*
+ * Another app has a higher priority level, preventing this call from
+ * succeeding.
+ */
+#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED
+
+/*
+ * Access to the device has been lost.  It must be re-acquired.
+ */
+#define DIERR_INPUTLOST                 \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)
+
+/*
+ * The operation cannot be performed while the device is acquired.
+ */
+#define DIERR_ACQUIRED                  \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)
+
+/*
+ * The operation cannot be performed unless the device is acquired.
+ */
+#define DIERR_NOTACQUIRED               \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)
+
+/*
+ * The specified property cannot be changed.
+ */
+#define DIERR_READONLY                  E_ACCESSDENIED
+
+/*
+ * The device already has an event notification associated with it.
+ */
+#define DIERR_HANDLEEXISTS              E_ACCESSDENIED
+
+/*
+ * Data is not yet available.
+ */
+#ifndef E_PENDING
+#define E_PENDING                       0x80070007L
+#endif
+
+/*
+ * Unable to IDirectInputJoyConfig_Acquire because the user
+ * does not have sufficient privileges to change the joystick
+ * configuration.
+ */
+#define DIERR_INSUFFICIENTPRIVS         0x80040200L
+
+/*
+ * The device is full.
+ */
+#define DIERR_DEVICEFULL                0x80040201L
+
+/*
+ * Not all the requested information fit into the buffer.
+ */
+#define DIERR_MOREDATA                  0x80040202L
+
+/*
+ * The effect is not downloaded.
+ */
+#define DIERR_NOTDOWNLOADED             0x80040203L
+
+/*
+ *  The device cannot be reinitialized because there are still effects
+ *  attached to it.
+ */
+#define DIERR_HASEFFECTS                0x80040204L
+
+/*
+ *  The operation cannot be performed unless the device is acquired
+ *  in DISCL_EXCLUSIVE mode.
+ */
+#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L
+
+/*
+ *  The effect could not be downloaded because essential information
+ *  is missing.  For example, no axes have been associated with the
+ *  effect, or no type-specific information has been created.
+ */
+#define DIERR_INCOMPLETEEFFECT          0x80040206L
+
+/*
+ *  Attempted to read buffered device data from a device that is
+ *  not buffered.
+ */
+#define DIERR_NOTBUFFERED               0x80040207L
+
+/*
+ *  An attempt was made to modify parameters of an effect while it is
+ *  playing.  Not all hardware devices support altering the parameters
+ *  of an effect while it is playing.
+ */
+#define DIERR_EFFECTPLAYING             0x80040208L
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif  /* __DINPUT_INCLUDED__ */
+
+/****************************************************************************
+ *
+ *  Definitions for non-IDirectInput (VJoyD) features defined more recently
+ *  than the current sdk files
+ *
+ ****************************************************************************/
+
+#ifdef _INC_MMSYSTEM
+#ifndef MMNOJOY
+
+#ifndef __VJOYDX_INCLUDED__
+#define __VJOYDX_INCLUDED__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
+ * contains mini-driver specific data to be passed by VJoyD to the mini-
+ * driver instead of doing a poll.
+ */
+#define JOY_PASSDRIVERDATA          0x10000000l
+
+/*
+ * Informs the joystick driver that the configuration has been changed
+ * and should be reloaded from the registery.
+ * dwFlags is reserved and should be set to zero
+ */
+WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );
+
+/*
+ * Hardware Setting indicating that the device is a headtracker
+ */
+#define JOY_HWS_ISHEADTRACKER       0x02000000l
+
+/*
+ * Hardware Setting indicating that the VxD is used to replace
+ * the standard analog polling
+ */
+#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l
+
+/*
+ * Hardware Setting indicating that the driver needs a standard
+ * gameport in order to communicate with the device.
+ */
+#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l 
+
+/*
+ * Hardware Setting indicating that VJoyD should not load this 
+ * driver, it will be loaded externally and will register with
+ * VJoyD of it's own accord.
+ */
+#define JOY_HWS_AUTOLOAD            0x10000000l
+
+/*
+ * Hardware Setting indicating that the driver acquires any 
+ * resources needed without needing a devnode through VJoyD.
+ */
+#define JOY_HWS_NODEVNODE           0x20000000l
+
+/*
+ * Hardware Setting indicating that the VxD can be used as
+ * a port 201h emulator.
+ */
+#define JOY_HWS_ISGAMEPORTEMULATOR  0x40000000l
+
+
+/*
+ * Usage Setting indicating that the settings are volatile and
+ * should be removed if still present on a reboot.
+ */
+#define JOY_US_VOLATILE             0x00000008L
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif  /* __VJOYDX_INCLUDED__ */
+
+#endif  /* not MMNOJOY */
+#endif  /* _INC_MMSYSTEM */
+
+/****************************************************************************
+ *
+ *  Definitions for non-IDirectInput (VJoyD) features defined more recently
+ *  than the current ddk files
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+#ifdef _INC_MMDDK
+#ifndef MMNOJOYDEV
+
+#ifndef __VJOYDXD_INCLUDED__
+#define __VJOYDXD_INCLUDED__
+/*
+ * Poll type in which the do_other field of the JOYOEMPOLLDATA
+ * structure contains mini-driver specific data passed from an app.
+ */
+#define JOY_OEMPOLL_PASSDRIVERDATA  7
+
+#endif  /* __VJOYDXD_INCLUDED__ */
+
+#endif  /* not MMNOJOYDEV */
+#endif  /* _INC_MMDDK */
+
+#endif /* DIJ_RINGZERO */
diff -ruN SDL-1.2.13/include/directx.h SDL-1.2.13_OOx64/include/directx.h
--- SDL-1.2.13/include/directx.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/directx.h	1999-11-19 17:32:22 +0000
@@ -0,0 +1,79 @@
+
+#ifndef _directx_h_
+#define _directx_h
+
+/* Include all of the DirectX 5.0 headers and adds any necessary tweaks */
+
+#include <windows.h>
+#include <mmsystem.h>
+#ifndef WIN32
+#define WIN32
+#endif
+#undef  WINNT
+
+/* Far pointers don't exist in 32-bit code */
+#ifndef FAR
+#define FAR
+#endif
+
+/* Error codes not yet included in Win32 API header files */
+#ifndef MAKE_HRESULT
+#define MAKE_HRESULT(sev,fac,code) \
+	((HRESULT)(((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))))
+#endif
+
+#ifndef S_OK
+#define S_OK		(HRESULT)0x00000000L
+#endif
+
+#ifndef SUCCEEDED
+#define SUCCEEDED(x)	((HRESULT)(x) >= 0)
+#endif
+#ifndef FAILED
+#define FAILED(x)	((HRESULT)(x)<0)
+#endif
+
+#ifndef E_FAIL
+#define E_FAIL		(HRESULT)0x80000008L
+#endif
+#ifndef E_NOINTERFACE
+#define E_NOINTERFACE	(HRESULT)0x80004002L
+#endif
+#ifndef E_OUTOFMEMORY
+#define E_OUTOFMEMORY	(HRESULT)0x8007000EL
+#endif
+#ifndef E_INVALIDARG
+#define E_INVALIDARG	(HRESULT)0x80070057L
+#endif
+#ifndef E_NOTIMPL
+#define E_NOTIMPL	(HRESULT)0x80004001L
+#endif
+#ifndef REGDB_E_CLASSNOTREG
+#define REGDB_E_CLASSNOTREG	(HRESULT)0x80040154L
+#endif
+
+/* Severity codes */
+#ifndef SEVERITY_ERROR
+#define SEVERITY_ERROR	1
+#endif
+
+/* Error facility codes */
+#ifndef FACILITY_WIN32
+#define FACILITY_WIN32	7
+#endif
+
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
+#endif
+
+/* DirectX 6.0 header includes
+   (if it isn't included, I haven't tested it yet)
+ */
+#ifdef __GNUC__
+#define NONAMELESSUNION
+#endif
+#include <ddraw.h>
+#include <dsound.h>
+#include <dinput.h>
+
+#endif /* _directx_h */
diff -ruN SDL-1.2.13/include/dsound.h SDL-1.2.13_OOx64/include/dsound.h
--- SDL-1.2.13/include/dsound.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/include/dsound.h	2002-05-18 08:58:56 +0000
@@ -0,0 +1,863 @@
+/*==========================================================================;
+ *
+ *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
+ *
+ *  File:       dsound.h
+ *  Content:    DirectSound include file
+ *
+ **************************************************************************/
+
+#ifndef __DSOUND_INCLUDED__
+#define __DSOUND_INCLUDED__
+
+#include <d3dtypes.h>
+
+#define COM_NO_WINDOWS_H
+#include <objbase.h>
+
+#define _FACDS  0x878
+#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+// Direct Sound Component GUID {47D4D946-62E8-11cf-93BC-444553540000}
+DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
+
+// DirectSound Capture Component GUID {B0210780-89CD-11d0-AF08-00A0C925CD16}
+DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
+
+//
+// Structures
+// 
+
+#ifdef __cplusplus
+// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
+struct IDirectSound;
+struct IDirectSoundBuffer;
+struct IDirectSound3DListener;
+struct IDirectSound3DBuffer;
+struct IDirectSoundCapture;
+struct IDirectSoundCaptureBuffer;
+struct IDirectSoundNotify;
+#endif // __cplusplus
+
+typedef struct IDirectSound *LPDIRECTSOUND;
+typedef struct IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
+typedef struct IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
+typedef struct IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
+typedef struct IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
+typedef struct IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
+typedef struct IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;
+
+typedef struct _DSCAPS
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwMinSecondarySampleRate;
+    DWORD           dwMaxSecondarySampleRate;
+    DWORD           dwPrimaryBuffers;
+    DWORD           dwMaxHwMixingAllBuffers;
+    DWORD           dwMaxHwMixingStaticBuffers;
+    DWORD           dwMaxHwMixingStreamingBuffers;
+    DWORD           dwFreeHwMixingAllBuffers;
+    DWORD           dwFreeHwMixingStaticBuffers;
+    DWORD           dwFreeHwMixingStreamingBuffers;
+    DWORD           dwMaxHw3DAllBuffers;
+    DWORD           dwMaxHw3DStaticBuffers;
+    DWORD           dwMaxHw3DStreamingBuffers;
+    DWORD           dwFreeHw3DAllBuffers;
+    DWORD           dwFreeHw3DStaticBuffers;
+    DWORD           dwFreeHw3DStreamingBuffers;
+    DWORD           dwTotalHwMemBytes;
+    DWORD           dwFreeHwMemBytes;
+    DWORD           dwMaxContigFreeHwMemBytes;
+    DWORD           dwUnlockTransferRateHwBuffers;
+    DWORD           dwPlayCpuOverheadSwBuffers;
+    DWORD           dwReserved1;
+    DWORD           dwReserved2;
+} DSCAPS, *LPDSCAPS;
+
+typedef const DSCAPS *LPCDSCAPS;
+
+typedef struct _DSBCAPS
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwBufferBytes;
+    DWORD           dwUnlockTransferRate;
+    DWORD           dwPlayCpuOverhead;
+} DSBCAPS, *LPDSBCAPS;
+
+typedef const DSBCAPS *LPCDSBCAPS;
+
+typedef struct _DSBUFFERDESC
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwBufferBytes;
+    DWORD           dwReserved;
+    LPWAVEFORMATEX  lpwfxFormat;
+} DSBUFFERDESC, *LPDSBUFFERDESC;
+
+typedef const DSBUFFERDESC *LPCDSBUFFERDESC;
+
+typedef struct _DS3DBUFFER
+{
+    DWORD           dwSize;
+    D3DVECTOR       vPosition;
+    D3DVECTOR       vVelocity;
+    DWORD           dwInsideConeAngle;
+    DWORD           dwOutsideConeAngle;
+    D3DVECTOR       vConeOrientation;
+    LONG            lConeOutsideVolume;
+    D3DVALUE        flMinDistance;
+    D3DVALUE        flMaxDistance;
+    DWORD           dwMode;
+} DS3DBUFFER, *LPDS3DBUFFER;
+
+typedef const DS3DBUFFER *LPCDS3DBUFFER;
+
+typedef struct _DS3DLISTENER
+{
+    DWORD           dwSize;
+    D3DVECTOR       vPosition;
+    D3DVECTOR       vVelocity;
+    D3DVECTOR       vOrientFront;
+    D3DVECTOR       vOrientTop;
+    D3DVALUE        flDistanceFactor;
+    D3DVALUE        flRolloffFactor;
+    D3DVALUE        flDopplerFactor;
+} DS3DLISTENER, *LPDS3DLISTENER;
+
+typedef const DS3DLISTENER *LPCDS3DLISTENER;
+
+typedef struct _DSCCAPS
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwFormats;
+    DWORD           dwChannels;
+} DSCCAPS, *LPDSCCAPS;
+
+typedef const DSCCAPS *LPCDSCCAPS;
+
+typedef struct _DSCBUFFERDESC
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwBufferBytes;
+    DWORD           dwReserved;
+    LPWAVEFORMATEX  lpwfxFormat;
+} DSCBUFFERDESC, *LPDSCBUFFERDESC;
+
+typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;
+
+typedef struct _DSCBCAPS 
+{
+    DWORD           dwSize;
+    DWORD           dwFlags;
+    DWORD           dwBufferBytes;
+    DWORD           dwReserved;
+} DSCBCAPS, *LPDSCBCAPS;
+
+typedef const DSCBCAPS *LPCDSCBCAPS;
+
+typedef struct _DSBPOSITIONNOTIFY
+{
+    DWORD           dwOffset;
+    HANDLE          hEventNotify;
+} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;
+
+typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;
+
+//
+// Compatibility typedefs
+//
+
+typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
+typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
+typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
+typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
+typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
+typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
+typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;
+typedef LPVOID *LPLPVOID;
+//typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
+
+//
+// DirectSound API
+//
+
+typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);
+typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
+
+extern HRESULT WINAPI DirectSoundCreate(LPGUID, LPDIRECTSOUND *, LPUNKNOWN);
+extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW, LPVOID);
+extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA, LPVOID);
+
+extern HRESULT WINAPI DirectSoundCaptureCreate(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
+extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW, LPVOID);
+extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA, LPVOID);
+
+#ifdef UNICODE
+#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
+#define DirectSoundEnumerate        DirectSoundEnumerateW
+#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
+#else // UNICODE
+#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
+#define DirectSoundEnumerate        DirectSoundEnumerateA
+#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
+#endif // UNICODE
+
+//
+// IDirectSound
+//
+
+DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
+
+#undef INTERFACE
+#define INTERFACE IDirectSound
+
+DECLARE_INTERFACE_(IDirectSound, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
+    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
+    STDMETHOD_(ULONG,Release)       (THIS) PURE;
+    
+    // IDirectSound methods
+    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN) PURE;
+    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS) PURE;
+    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *) PURE;
+    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND, DWORD) PURE;
+    STDMETHOD(Compact)              (THIS) PURE;
+    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD) PURE;
+    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD) PURE;
+    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSound_AddRef(p)                   (p)->lpVtbl->AddRef(p)
+#define IDirectSound_Release(p)                  (p)->lpVtbl->Release(p)
+#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
+#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
+#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
+#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
+#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
+#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
+#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
+#define IDirectSound_AddRef(p)                   (p)->AddRef()
+#define IDirectSound_Release(p)                  (p)->Release()
+#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
+#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
+#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
+#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
+#define IDirectSound_Compact(p)                  (p)->Compact()
+#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
+#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
+#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSoundBuffer
+//
+
+DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
+
+#undef INTERFACE
+#define INTERFACE IDirectSoundBuffer
+
+DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
+    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
+    STDMETHOD_(ULONG,Release)       (THIS) PURE;
+    
+    // IDirectSoundBuffer methods
+    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS) PURE;
+    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD) PURE;
+    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD) PURE;
+    STDMETHOD(GetVolume)            (THIS_ LPLONG) PURE;
+    STDMETHOD(GetPan)               (THIS_ LPLONG) PURE;
+    STDMETHOD(GetFrequency)         (THIS_ LPDWORD) PURE;
+    STDMETHOD(GetStatus)            (THIS_ LPDWORD) PURE;
+    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND, LPCDSBUFFERDESC) PURE;
+    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
+    STDMETHOD(Play)                 (THIS_ DWORD, DWORD, DWORD) PURE;
+    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD) PURE;
+    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX) PURE;
+    STDMETHOD(SetVolume)            (THIS_ LONG) PURE;
+    STDMETHOD(SetPan)               (THIS_ LONG) PURE;
+    STDMETHOD(SetFrequency)         (THIS_ DWORD) PURE;
+    STDMETHOD(Stop)                 (THIS) PURE;
+    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
+    STDMETHOD(Restore)              (THIS) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSoundBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectSoundBuffer_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
+#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
+#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
+#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
+#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
+#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
+#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
+#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
+#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
+#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
+#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
+#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
+#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
+#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
+#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
+#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
+#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectSoundBuffer_AddRef(p)                    (p)->AddRef()
+#define IDirectSoundBuffer_Release(p)                   (p)->Release()
+#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
+#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
+#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
+#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
+#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
+#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
+#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
+#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
+#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
+#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
+#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
+#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
+#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
+#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
+#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
+#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
+#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSound3DListener
+//
+
+DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
+
+#undef INTERFACE
+#define INTERFACE IDirectSound3DListener
+
+DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
+    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
+    STDMETHOD_(ULONG,Release)           (THIS) PURE;
+
+    // IDirectSound3D methods
+    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER) PURE;
+    STDMETHOD(GetDistanceFactor)        (THIS_ LPD3DVALUE) PURE;
+    STDMETHOD(GetDopplerFactor)         (THIS_ LPD3DVALUE) PURE;
+    STDMETHOD(GetOrientation)           (THIS_ LPD3DVECTOR, LPD3DVECTOR) PURE;
+    STDMETHOD(GetPosition)              (THIS_ LPD3DVECTOR) PURE;
+    STDMETHOD(GetRolloffFactor)         (THIS_ LPD3DVALUE) PURE;
+    STDMETHOD(GetVelocity)              (THIS_ LPD3DVECTOR) PURE;
+    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER, DWORD) PURE;
+    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetPosition)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSound3DListener_AddRef(p)                        (p)->lpVtbl->AddRef(p)
+#define IDirectSound3DListener_Release(p)                       (p)->lpVtbl->Release(p)
+#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
+#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
+#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
+#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
+#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
+#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
+#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
+#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
+#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
+#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
+#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
+#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
+#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
+#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
+#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
+#define IDirectSound3DListener_AddRef(p)                        (p)->AddRef()
+#define IDirectSound3DListener_Release(p)                       (p)->Release()
+#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
+#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
+#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
+#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
+#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
+#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
+#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
+#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
+#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
+#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
+#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
+#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
+#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
+#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
+#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSound3DBuffer
+//
+
+DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
+
+#undef INTERFACE
+#define INTERFACE IDirectSound3DBuffer
+
+DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
+    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
+    STDMETHOD_(ULONG,Release)       (THIS) PURE;
+
+    // IDirectSoundBuffer3D methods
+    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER) PURE;
+    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD, LPDWORD) PURE;
+    STDMETHOD(GetConeOrientation)   (THIS_ LPD3DVECTOR) PURE;
+    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG) PURE;
+    STDMETHOD(GetMaxDistance)       (THIS_ LPD3DVALUE) PURE;
+    STDMETHOD(GetMinDistance)       (THIS_ LPD3DVALUE) PURE;
+    STDMETHOD(GetMode)              (THIS_ LPDWORD) PURE;
+    STDMETHOD(GetPosition)          (THIS_ LPD3DVECTOR) PURE;
+    STDMETHOD(GetVelocity)          (THIS_ LPD3DVECTOR) PURE;
+    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER, DWORD) PURE;
+    STDMETHOD(SetConeAngles)        (THIS_ DWORD, DWORD, DWORD) PURE;
+    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG, DWORD) PURE;
+    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetMode)              (THIS_ DWORD, DWORD) PURE;
+    STDMETHOD(SetPosition)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSound3DBuffer_AddRef(p)                  (p)->lpVtbl->AddRef(p)
+#define IDirectSound3DBuffer_Release(p)                 (p)->lpVtbl->Release(p)
+#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
+#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->lpVtbl->GetConeAngles(p,a,b)
+#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->lpVtbl->GetConeOrientation(p,a)
+#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->lpVtbl->GetConeOutsideVolume(p,a)
+#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->lpVtbl->GetPosition(p,a)
+#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->lpVtbl->GetMinDistance(p,a)
+#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->lpVtbl->GetMaxDistance(p,a)
+#define IDirectSound3DBuffer_GetMode(p,a)               (p)->lpVtbl->GetMode(p,a)
+#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->lpVtbl->GetVelocity(p,a)
+#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->lpVtbl->SetAllParameters(p,a,b)
+#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->lpVtbl->SetConeAngles(p,a,b,c)
+#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
+#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->lpVtbl->SetConeOutsideVolume(p,a,b)
+#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->lpVtbl->SetPosition(p,a,b,c,d)
+#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->lpVtbl->SetMinDistance(p,a,b)
+#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->lpVtbl->SetMaxDistance(p,a,b)
+#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->lpVtbl->SetMode(p,a,b)
+#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->lpVtbl->SetVelocity(p,a,b,c,d)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
+#define IDirectSound3DBuffer_AddRef(p)                  (p)->AddRef()
+#define IDirectSound3DBuffer_Release(p)                 (p)->Release()
+#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->GetAllParameters(a)
+#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->GetConeAngles(a,b)
+#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->GetConeOrientation(a)
+#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->GetConeOutsideVolume(a)
+#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->GetPosition(a)
+#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->GetMinDistance(a)
+#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->GetMaxDistance(a)
+#define IDirectSound3DBuffer_GetMode(p,a)               (p)->GetMode(a)
+#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->GetVelocity(a)
+#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->SetAllParameters(a,b)
+#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->SetConeAngles(a,b,c)
+#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->SetConeOrientation(a,b,c,d)
+#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->SetConeOutsideVolume(a,b)
+#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->SetPosition(a,b,c,d)
+#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->SetMinDistance(a,b)
+#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->SetMaxDistance(a,b)
+#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->SetMode(a,b)
+#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->SetVelocity(a,b,c,d)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSoundCapture
+//
+
+DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
+
+#undef INTERFACE
+#define INTERFACE IDirectSoundCapture
+
+DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
+    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
+    STDMETHOD_(ULONG,Release)       (THIS) PURE;
+
+    // IDirectSoundCapture methods
+    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN) PURE;
+    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS ) PURE;
+    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSoundCapture_AddRef(p)                       (p)->lpVtbl->AddRef(p)
+#define IDirectSoundCapture_Release(p)                      (p)->lpVtbl->Release(p)
+#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
+#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
+#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
+#define IDirectSoundCapture_AddRef(p)                       (p)->AddRef()
+#define IDirectSoundCapture_Release(p)                      (p)->Release()
+#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
+#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
+#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSoundCaptureBuffer
+//
+
+DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
+
+#undef INTERFACE
+#define INTERFACE IDirectSoundCaptureBuffer
+
+DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
+    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
+    STDMETHOD_(ULONG,Release)       (THIS) PURE;
+
+    // IDirectSoundCaptureBuffer methods
+    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS ) PURE;
+    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD ) PURE;
+    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD ) PURE;
+    STDMETHOD(GetStatus)            (THIS_ LPDWORD ) PURE;
+    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC) PURE;
+    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
+    STDMETHOD(Start)                (THIS_ DWORD) PURE;
+    STDMETHOD(Stop)                 (THIS) PURE;
+    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
+#define IDirectSoundCaptureBuffer_Release(p)                   (p)->lpVtbl->Release(p)
+#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
+#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
+#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
+#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
+#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
+#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->lpVtbl->Start(p,a)
+#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
+#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
+#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->AddRef()
+#define IDirectSoundCaptureBuffer_Release(p)                   (p)->Release()
+#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
+#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
+#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
+#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->GetStatus(a)
+#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
+#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
+#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->Start(a)
+#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->Stop()
+#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IDirectSoundNotify
+//
+
+DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
+
+#undef INTERFACE
+#define INTERFACE IDirectSoundNotify
+
+DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
+    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
+    STDMETHOD_(ULONG,Release)           (THIS) PURE;
+
+    // IDirectSoundNotify methods
+    STDMETHOD(SetNotificationPositions) (THIS_ DWORD, LPCDSBPOSITIONNOTIFY) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectSoundNotify_AddRef(p)                        (p)->lpVtbl->AddRef(p)
+#define IDirectSoundNotify_Release(p)                       (p)->lpVtbl->Release(p)
+#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
+#define IDirectSoundNotify_AddRef(p)                        (p)->AddRef()
+#define IDirectSoundNotify_Release(p)                       (p)->Release()
+#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+//
+// IKsPropertySet
+//
+
+#ifndef _IKsPropertySet_
+#define _IKsPropertySet_
+
+#ifdef __cplusplus
+// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
+struct IKsPropertySet;
+#endif // __cplusplus
+
+typedef struct IKsPropertySet *LPKSPROPERTYSET;
+
+#define KSPROPERTY_SUPPORT_GET  0x00000001
+#define KSPROPERTY_SUPPORT_SET  0x00000002
+
+DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);
+
+#undef INTERFACE
+#define INTERFACE IKsPropertySet
+
+DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
+{
+    // IUnknown methods
+    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
+    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
+    STDMETHOD_(ULONG,Release)   (THIS) PURE;
+
+    // IKsPropertySet methods
+    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
+    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
+    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IKsPropertySet_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
+#define IKsPropertySet_AddRef(p)                   (p)->lpVtbl->AddRef(p)
+#define IKsPropertySet_Release(p)                  (p)->lpVtbl->Release(p)
+#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
+#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
+#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
+#else // !defined(__cplusplus) || defined(CINTERFACE)
+#define IKsPropertySet_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
+#define IKsPropertySet_AddRef(p)                   (p)->AddRef()
+#define IKsPropertySet_Release(p)                  (p)->Release()
+#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
+#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
+#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
+#endif // !defined(__cplusplus) || defined(CINTERFACE)
+
+#endif // _IKsPropertySet_
+
+//
+// Return Codes
+//
+
+#define DS_OK                           0
+
+// The call failed because resources (such as a priority level)
+// were already being used by another caller.
+#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)
+
+// The control (vol,pan,etc.) requested by the caller is not available.
+#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)
+
+// An invalid parameter was passed to the returning function
+#define DSERR_INVALIDPARAM              E_INVALIDARG
+
+// This call is not valid for the current state of this object
+#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)
+
+// An undetermined error occured inside the DirectSound subsystem
+#define DSERR_GENERIC                   E_FAIL
+
+// The caller does not have the priority level required for the function to
+// succeed.
+#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)
+
+// Not enough free memory is available to complete the operation
+#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY
+
+// The specified WAVE format is not supported
+#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)
+
+// The function called is not supported at this time
+#define DSERR_UNSUPPORTED               E_NOTIMPL
+
+// No sound driver is available for use
+#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)
+
+// This object is already initialized
+#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)
+
+// This object does not support aggregation
+#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
+
+// The buffer memory has been lost, and must be restored.
+#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)
+
+// Another app has a higher priority level, preventing this call from
+// succeeding.
+#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)
+
+// This object has not been initialized
+#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)
+
+// The requested COM interface is not available
+#define DSERR_NOINTERFACE               E_NOINTERFACE
+
+//
+// Flags
+//
+
+#define DSCAPS_PRIMARYMONO          0x00000001
+#define DSCAPS_PRIMARYSTEREO        0x00000002
+#define DSCAPS_PRIMARY8BIT          0x00000004
+#define DSCAPS_PRIMARY16BIT         0x00000008
+#define DSCAPS_CONTINUOUSRATE       0x00000010
+#define DSCAPS_EMULDRIVER           0x00000020
+#define DSCAPS_CERTIFIED            0x00000040
+#define DSCAPS_SECONDARYMONO        0x00000100
+#define DSCAPS_SECONDARYSTEREO      0x00000200
+#define DSCAPS_SECONDARY8BIT        0x00000400
+#define DSCAPS_SECONDARY16BIT       0x00000800
+
+#define DSBPLAY_LOOPING             0x00000001
+      
+#define DSBSTATUS_PLAYING           0x00000001
+#define DSBSTATUS_BUFFERLOST        0x00000002
+#define DSBSTATUS_LOOPING           0x00000004
+
+#define DSBLOCK_FROMWRITECURSOR     0x00000001
+#define DSBLOCK_ENTIREBUFFER        0x00000002
+
+#define DSSCL_NORMAL                0x00000001
+#define DSSCL_PRIORITY              0x00000002
+#define DSSCL_EXCLUSIVE             0x00000003
+#define DSSCL_WRITEPRIMARY          0x00000004
+
+#define DS3DMODE_NORMAL             0x00000000
+#define DS3DMODE_HEADRELATIVE       0x00000001
+#define DS3DMODE_DISABLE            0x00000002
+
+#define DS3D_IMMEDIATE              0x00000000
+#define DS3D_DEFERRED               0x00000001
+
+#define DS3D_MINDISTANCEFACTOR      0.0f
+#define DS3D_MAXDISTANCEFACTOR      10.0f
+#define DS3D_DEFAULTDISTANCEFACTOR  1.0f
+
+#define DS3D_MINROLLOFFFACTOR       0.0f
+#define DS3D_MAXROLLOFFFACTOR       10.0f
+#define DS3D_DEFAULTROLLOFFFACTOR   1.0f
+
+#define DS3D_MINDOPPLERFACTOR       0.0f
+#define DS3D_MAXDOPPLERFACTOR       10.0f
+#define DS3D_DEFAULTDOPPLERFACTOR   1.0f
+
+#define DS3D_DEFAULTMINDISTANCE     1.0f
+#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f
+
+#define DS3D_MINCONEANGLE           0
+#define DS3D_MAXCONEANGLE           360
+#define DS3D_DEFAULTCONEANGLE       360
+
+#define DS3D_DEFAULTCONEOUTSIDEVOLUME   0
+
+#define DSBCAPS_PRIMARYBUFFER       0x00000001
+#define DSBCAPS_STATIC              0x00000002
+#define DSBCAPS_LOCHARDWARE         0x00000004
+#define DSBCAPS_LOCSOFTWARE         0x00000008
+#define DSBCAPS_CTRL3D              0x00000010
+#define DSBCAPS_CTRLFREQUENCY       0x00000020
+#define DSBCAPS_CTRLPAN             0x00000040
+#define DSBCAPS_CTRLVOLUME          0x00000080
+#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
+#define DSBCAPS_CTRLDEFAULT         0x000000E0
+#define DSBCAPS_CTRLALL             0x000001F0
+#define DSBCAPS_STICKYFOCUS         0x00004000
+#define DSBCAPS_GLOBALFOCUS         0x00008000 
+#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
+#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
+
+#define DSCBCAPS_WAVEMAPPED         0x80000000
+
+#define DSSPEAKER_HEADPHONE         0x00000001
+#define DSSPEAKER_MONO              0x00000002
+#define DSSPEAKER_QUAD              0x00000003
+#define DSSPEAKER_STEREO            0x00000004
+#define DSSPEAKER_SURROUND          0x00000005
+
+#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
+#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
+#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
+#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees
+
+#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
+#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
+#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))
+
+#define DSCCAPS_EMULDRIVER          0x00000020
+
+#define DSCBLOCK_ENTIREBUFFER       0x00000001
+
+#define DSCBSTATUS_CAPTURING        0x00000001
+#define DSCBSTATUS_LOOPING          0x00000002
+
+#define DSCBSTART_LOOPING           0x00000001
+
+#define DSBFREQUENCY_MIN            100
+#define DSBFREQUENCY_MAX            100000
+#define DSBFREQUENCY_ORIGINAL       0
+
+#define DSBPAN_LEFT                 -10000
+#define DSBPAN_CENTER               0
+#define DSBPAN_RIGHT                10000
+
+#define DSBVOLUME_MIN               -10000
+#define DSBVOLUME_MAX               0
+
+#define DSBSIZE_MIN                 4
+#define DSBSIZE_MAX                 0x0FFFFFFF
+
+#define DSBPN_OFFSETSTOP            0xFFFFFFFF
+
+#ifdef __cplusplus
+};
+#endif // __cplusplus
+
+#endif  // __DSOUND_INCLUDED__ 
Files SDL-1.2.13/lib/libddraw.a and SDL-1.2.13_OOx64/lib/libddraw.a differ
Files SDL-1.2.13/lib/libdinput.a and SDL-1.2.13_OOx64/lib/libdinput.a differ
Files SDL-1.2.13/lib/libdplayx.a and SDL-1.2.13_OOx64/lib/libdplayx.a differ
Files SDL-1.2.13/lib/libdsound.a and SDL-1.2.13_OOx64/lib/libdsound.a differ
Files SDL-1.2.13/lib/libdxguid.a and SDL-1.2.13_OOx64/lib/libdxguid.a differ
diff -ruN SDL-1.2.13/libtool SDL-1.2.13_OOx64/libtool
--- SDL-1.2.13/libtool	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/libtool	2017-12-19 18:34:53 +0000
@@ -0,0 +1,7546 @@
+#! /bin/sh
+
+# libtoolT - Provide generalized library-building support services.
+# Generated automatically by  (GNU  )
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001
+# Free Software Foundation, Inc.
+#
+# This file is part of GNU Libtool:
+# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# A sed program that does not truncate output.
+SED="/bin/sed"
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="/bin/sed -e 1s/^X//"
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+# The names of the tagged configurations supported by this script.
+available_tags=" CXX"
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Libtool was configured on host LAPTOP-8NENSNNN:
+
+# Shell to use when invoking shell scripts.
+SHELL="/bin/sh"
+
+# Whether or not to build shared libraries.
+build_libtool_libs=yes
+
+# Whether or not to build static libraries.
+build_old_libs=yes
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=yes
+
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=yes
+
+# Whether or not to optimize for fast installation.
+fast_install=needless
+
+# The host system.
+host_alias=
+host=i686-pc-mingw32
+host_os=mingw32
+
+# The build system.
+build_alias=
+build=i686-pc-mingw32
+build_os=mingw32
+
+# An echo program that does not interpret backslashes.
+echo="echo"
+
+# The archiver.
+AR="ar"
+AR_FLAGS="cru"
+
+# A C compiler.
+LTCC="gcc"
+
+# LTCC compiler flags.
+LTCFLAGS="-g -O2 -I./include -D_GNU_SOURCE=1"
+
+# A language-specific compiler.
+CC="gcc"
+
+# Is the compiler the GNU C compiler?
+with_gcc=yes
+
+# An ERE matcher.
+EGREP="/bin/grep -E"
+
+# The linker used to build libraries.
+LD="c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe"
+
+# Whether we need hard or soft links.
+LN_S="ln -s"
+
+# A BSD-compatible nm program.
+NM="/mingw/bin/nm"
+
+# A symbol stripping program
+STRIP="strip"
+
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=file
+
+# Used on cygwin: DLL creation program.
+DLLTOOL="dlltool"
+
+# Used on cygwin: object dumper.
+OBJDUMP="objdump"
+
+# Used on cygwin: assembler.
+AS="as"
+
+# The name of the directory that contains temporary libtool files.
+objdir=.libs
+
+# How to create reloadable object files.
+reload_flag=" -r"
+reload_cmds="\$LD\$reload_flag -o \$output\$reload_objs"
+
+# How to pass a linker flag through the compiler.
+wl="-Wl,"
+
+# Object file suffix (normally "o").
+objext="o"
+
+# Old archive suffix (normally "a").
+libext="a"
+
+# Shared library suffix (normally ".so").
+shrext_cmds='.dll'
+
+# Executable file suffix (normally "").
+exeext=""
+
+# Additional compiler flags for building library objects.
+pic_flag=" -DDLL_EXPORT -DPIC"
+pic_mode=default
+
+# What is the maximum length of a command?
+max_cmd_len=8192
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o="yes"
+
+# Must we lock files when doing compilation?
+need_locks="no"
+
+# Do we need the lib prefix for modules?
+need_lib_prefix=no
+
+# Do we need a version for libraries?
+need_version=no
+
+# Whether dlopen is supported.
+dlopen_support=unknown
+
+# Whether dlopen of programs is supported.
+dlopen_self=unknown
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=unknown
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag="-static"
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=" -fno-builtin"
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec="\${wl}--export-dynamic"
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec="\${wl}--whole-archive\$convenience \${wl}--no-whole-archive"
+
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=""
+
+# Library versioning type.
+version_type=windows
+
+# Format of library name prefix.
+libname_spec="lib\$name"
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec="\$libname.dll.a"
+
+# The coded name of the library, if different from the real name.
+soname_spec="\`echo \${libname} | sed -e s/^lib//\`\${shared_ext}"
+
+# Commands used to build and install an old-style archive.
+RANLIB="ranlib"
+old_archive_cmds="\$AR \$AR_FLAGS \$oldlib\$oldobjs\$old_deplibs~\$RANLIB \$oldlib"
+old_postinstall_cmds="chmod 644 \$oldlib~\$RANLIB \$oldlib"
+old_postuninstall_cmds=""
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=""
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=""
+
+# Commands used to build and install a shared archive.
+archive_cmds="\$CC -shared \$libobjs \$deplibs \$compiler_flags -o \$output_objdir/\$soname \${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker \$lib"
+archive_expsym_cmds="if test \\\"x\\\`\$SED 1q \$export_symbols\\\`\\\" = xEXPORTS; then
+	  cp \$export_symbols \$output_objdir/\$soname.def;
+	else
+	  echo EXPORTS > \$output_objdir/\$soname.def;
+	  cat \$export_symbols >> \$output_objdir/\$soname.def;
+	fi~
+	\$CC -shared \$output_objdir/\$soname.def \$libobjs \$deplibs \$compiler_flags -o \$output_objdir/\$soname \${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker \$lib"
+postinstall_cmds="base_file=\\\`basename \\\${file}\\\`~
+      dlpath=\\\`\$SHELL 2>&1 -c '. \$dir/'\\\${base_file}'i;echo \\\$dlname'\\\`~
+      dldir=\$destdir/\\\`dirname \\\$dlpath\\\`~
+      test -d \\\$dldir || mkdir -p \\\$dldir~
+      \$install_prog \$dir/\$dlname \\\$dldir/\$dlname~
+      chmod a+x \\\$dldir/\$dlname"
+postuninstall_cmds="dldll=\\\`\$SHELL 2>&1 -c '. \$file; echo \\\$dlname'\\\`~
+      dlpath=\$dir/\\\$dldll~
+       \$rm \\\$dlpath"
+
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=""
+module_expsym_cmds=""
+
+# Commands to strip libraries.
+old_striplib="strip --strip-debug"
+striplib="strip --strip-unneeded"
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=""
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=""
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=""
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=""
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=""
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method="pass_all"
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd="\$OBJDUMP -f"
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag="unsupported"
+
+# Flag that forces no undefined symbols.
+no_undefined_flag=""
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=""
+
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=""
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe="sed -n -e 's/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)
+\\{0,1\\}\$/\\1 \\2 \\2/p'"
+
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl="sed -n -e 's/^. .* \\(.*\\)\$/extern int \\1;/p'"
+
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p' -e 's/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'"
+
+# This is the shared library runtime path variable.
+runpath_var=LD_RUN_PATH
+
+# This is the shared library path variable.
+shlibpath_var=PATH
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=yes
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=immediate
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=no
+
+# Flag to hardcode $libdir into a binary during linking.
+# This must work even if $libdir does not exist.
+hardcode_libdir_flag_spec="-L\$libdir"
+
+# If ld is used when linking, flag to hardcode $libdir into
+# a binary during linking. This must work even if $libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=""
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=""
+
+# Set to yes if using DIR/libNAME during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=no
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=no
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=unsupported
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=no
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="PATH PATH LD_RUN_PATH GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=unknown
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=" =c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../"
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+
+# Fix the shell variable $srcfile for the compiler.
+fix_srcfile_path=""
+
+# Set to yes if exported symbols are required.
+always_export_symbols=no
+
+# The commands to list exported symbols.
+export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED -e '/^[BCDGRS] /s/.* \\\\([^ ]*\\\\)/\\\\1 DATA/' | \$SED -e '/^[AITW] /s/.* //' | sort | uniq > \$export_symbols"
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=""
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms="_GLOBAL_OFFSET_TABLE_"
+
+# Symbols that must always be exported.
+include_expsyms=""
+
+# ### END LIBTOOL CONFIG
+
+# Based on libtool-1.5.22
+# ltmain.sh - Provide generalized library-building support services.
+# NOTE: Changing this file will not affect anything until you rerun configure.
+#
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+basename="s,^.*/,,g"
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+progname=`echo "$progpath" | $SED $basename`
+modename="$progname"
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION=1.5.22
+TIMESTAMP=" (1.1220.2.365 2005/12/18 22:14:06)"
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes.
+if test -n "${ZSH_VERSION+set}" ; then
+  setopt NO_GLOB_SUBST
+fi
+
+# Check that we have a working $echo.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`($echo '\t') 2>/dev/null`" = 'X\t'; then
+  # Yippee, $echo works!
+  :
+else
+  # Restart under the correct shell, and then maybe $echo will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+default_mode=
+help="Try \`$progname --help' for more information."
+magic="%%%MAGIC variable%%%"
+mkdir="mkdir"
+mv="mv -f"
+rm="rm -f"
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([\\`\\"$\\\\]\)/\\\1/g'
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  SP2NL='tr \040 \012'
+  NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  SP2NL='tr \100 \n'
+  NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+# NLS nuisances.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+# We save the old values to restore during execute mode.
+if test "${LC_ALL+set}" = set; then
+  save_LC_ALL="$LC_ALL"; LC_ALL=C; export LC_ALL
+fi
+if test "${LANG+set}" = set; then
+  save_LANG="$LANG"; LANG=C; export LANG
+fi
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+  $echo "$modename: not configured to build any kind of library" 1>&2
+  $echo "Fatal configuration error.  See the $PACKAGE docs for more information." 1>&2
+  exit $EXIT_FAILURE
+fi
+
+# Global variables.
+mode=$default_mode
+nonopt=
+prev=
+prevopt=
+run=
+show="$echo"
+show_help=
+execute_dlfiles=
+duplicate_deps=no
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+
+#####################################
+# Shell function definitions:
+# This seems to be the best place for them
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+	# Failing that, at least try and use $RANDOM to avoid a race
+	my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+	save_mktempdir_umask=`umask`
+	umask 0077
+	$mkdir "$my_tmpdir"
+	umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || {
+        $echo "cannot create temporary directory \`$my_tmpdir'" 1>&2
+	exit $EXIT_FAILURE
+      }
+    fi
+
+    $echo "X$my_tmpdir" | $Xsed
+}
+
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null | \
+      $EGREP -e 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 | \
+	$SED -n -e '1,100{/ I /{s,.*,import,;p;q;};}'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $echo $win32_libid_type
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+	case $arg in
+	  *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	  arg="\"$arg\""
+	  ;;
+	esac
+	CC_quoted="$CC_quoted $arg"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$echo $CC` "* | "`$echo $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$echo $CC_quoted` "* | "`$echo $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if grep "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	    # Double-quote args containing other shell metacharacters.
+	    case $arg in
+	      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	      arg="\"$arg\""
+	      ;;
+	    esac
+	    CC_quoted="$CC_quoted $arg"
+	  done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$echo $CC` "* | "`$echo $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$echo $CC_quoted` "* | "`$echo $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  $echo "$modename: unable to infer tagged configuration"
+	  $echo "$modename: specify a tag with \`--tag'" 1>&2
+	  exit $EXIT_FAILURE
+#        else
+#          $echo "$modename: using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+
+    $show "(cd $f_ex_an_ar_dir && $AR x $f_ex_an_ar_oldlib)"
+    $run eval "(cd \$f_ex_an_ar_dir && $AR x \$f_ex_an_ar_oldlib)" || exit $?
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      $echo "$modename: ERROR: object name conflicts: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib" 1>&2
+      exit $EXIT_FAILURE
+    fi
+}
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+    my_status=""
+
+    $show "${rm}r $my_gentop"
+    $run ${rm}r "$my_gentop"
+    $show "$mkdir $my_gentop"
+    $run $mkdir "$my_gentop"
+    my_status=$?
+    if test "$my_status" -ne 0 && test ! -d "$my_gentop"; then
+      exit $my_status
+    fi
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      my_xlib=`$echo "X$my_xlib" | $Xsed -e 's%^.*/%%'`
+      my_xdir="$my_gentop/$my_xlib"
+
+      $show "${rm}r $my_xdir"
+      $run ${rm}r "$my_xdir"
+      $show "$mkdir $my_xdir"
+      $run $mkdir "$my_xdir"
+      exit_status=$?
+      if test "$exit_status" -ne 0 && test ! -d "$my_xdir"; then
+	exit $exit_status
+      fi
+      case $host in
+      *-darwin*)
+	$show "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	if test -z "$run"; then
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`$echo "X$darwin_archive" | $Xsed -e 's%^.*/%%'`
+	  darwin_arches=`lipo -info "$darwin_archive" 2>/dev/null | $EGREP Architectures 2>/dev/null`
+	  if test -n "$darwin_arches"; then 
+	    darwin_arches=`echo "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    $show "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      mkdir -p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      lipo -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $rm "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+      ## Okay now we have a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print| xargs basename | sort -u | $NL2SP`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      lipo -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    ${rm}r unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd "$darwin_orig_dir"
+ 	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	fi # $run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+        ;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+    func_extract_archives_result="$my_oldobjs"
+}
+# End of Shell function definitions
+#####################################
+
+# Darwin sucks
+eval std_shrext=\"$shrext_cmds\"
+
+disable_libs=no
+
+# Parse our command line options once, thoroughly.
+while test "$#" -gt 0
+do
+  arg="$1"
+  shift
+
+  case $arg in
+  -*=*) optarg=`$echo "X$arg" | $Xsed -e 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$prev"; then
+    case $prev in
+    execute_dlfiles)
+      execute_dlfiles="$execute_dlfiles $arg"
+      ;;
+    tag)
+      tagname="$arg"
+      preserve_args="${preserve_args}=$arg"
+
+      # Check whether tagname contains only valid characters
+      case $tagname in
+      *[!-_A-Za-z0-9,/]*)
+	$echo "$progname: invalid tag name: $tagname" 1>&2
+	exit $EXIT_FAILURE
+	;;
+      esac
+
+      case $tagname in
+      CC)
+	# Don't test for the "default" C tag, as we know, it's there, but
+	# not specially marked.
+	;;
+      *)
+	if grep "^# ### BEGIN LIBTOOL TAG CONFIG: $tagname$" < "$progpath" > /dev/null; then
+	  taglist="$taglist $tagname"
+	  # Evaluate the configuration.
+	  eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$tagname'$/,/^# ### END LIBTOOL TAG CONFIG: '$tagname'$/p' < $progpath`"
+	else
+	  $echo "$progname: ignoring unknown tag $tagname" 1>&2
+	fi
+	;;
+      esac
+      ;;
+    *)
+      eval "$prev=\$arg"
+      ;;
+    esac
+
+    prev=
+    prevopt=
+    continue
+  fi
+
+  # Have we seen a non-optional argument yet?
+  case $arg in
+  --help)
+    show_help=yes
+    ;;
+
+  --version)
+    $echo "$PROGRAM (GNU $PACKAGE) $VERSION$TIMESTAMP"
+    $echo
+    $echo "Copyright (C) 2005  Free Software Foundation, Inc."
+    $echo "This is free software; see the source for copying conditions.  There is NO"
+    $echo "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+    exit $?
+    ;;
+
+  --config)
+    ${SED} -e '1,/^# ### BEGIN LIBTOOL CONFIG/d' -e '/^# ### END LIBTOOL CONFIG/,$d' $progpath
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      ${SED} -n -e "/^# ### BEGIN LIBTOOL TAG CONFIG: $tagname$/,/^# ### END LIBTOOL TAG CONFIG: $tagname$/p" < "$progpath"
+    done
+    exit $?
+    ;;
+
+  --debug)
+    $echo "$progname: enabling shell trace mode"
+    set -x
+    preserve_args="$preserve_args $arg"
+    ;;
+
+  --dry-run | -n)
+    run=:
+    ;;
+
+  --features)
+    $echo "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $echo "enable shared libraries"
+    else
+      $echo "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $echo "enable static libraries"
+    else
+      $echo "disable static libraries"
+    fi
+    exit $?
+    ;;
+
+  --finish) mode="finish" ;;
+
+  --mode) prevopt="--mode" prev=mode ;;
+  --mode=*) mode="$optarg" ;;
+
+  --preserve-dup-deps) duplicate_deps="yes" ;;
+
+  --quiet | --silent)
+    show=:
+    preserve_args="$preserve_args $arg"
+    ;;
+
+  --tag)
+    prevopt="--tag"
+    prev=tag
+    preserve_args="$preserve_args --tag"
+    ;;
+  --tag=*)
+    set tag "$optarg" ${1+"$@"}
+    shift
+    prev=tag
+    preserve_args="$preserve_args --tag"
+    ;;
+
+  -dlopen)
+    prevopt="-dlopen"
+    prev=execute_dlfiles
+    ;;
+
+  -*)
+    $echo "$modename: unrecognized option \`$arg'" 1>&2
+    $echo "$help" 1>&2
+    exit $EXIT_FAILURE
+    ;;
+
+  *)
+    nonopt="$arg"
+    break
+    ;;
+  esac
+done
+
+if test -n "$prevopt"; then
+  $echo "$modename: option \`$prevopt' requires an argument" 1>&2
+  $echo "$help" 1>&2
+  exit $EXIT_FAILURE
+fi
+
+case $disable_libs in
+no) 
+  ;;
+shared)
+  build_libtool_libs=no
+  build_old_libs=yes
+  ;;
+static)
+  build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+  ;;
+esac
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+if test -z "$show_help"; then
+
+  # Infer the operation mode.
+  if test -z "$mode"; then
+    $echo "*** Warning: inferring the mode of operation is deprecated." 1>&2
+    $echo "*** Future versions of Libtool will require --mode=MODE be specified." 1>&2
+    case $nonopt in
+    *cc | cc* | *++ | gcc* | *-gcc* | g++* | xlc*)
+      mode=link
+      for arg
+      do
+	case $arg in
+	-c)
+	   mode=compile
+	   break
+	   ;;
+	esac
+      done
+      ;;
+    *db | *dbx | *strace | *truss)
+      mode=execute
+      ;;
+    *install*|cp|mv)
+      mode=install
+      ;;
+    *rm)
+      mode=uninstall
+      ;;
+    *)
+      # If we have no mode, but dlfiles were specified, then do execute mode.
+      test -n "$execute_dlfiles" && mode=execute
+
+      # Just use the default operation mode.
+      if test -z "$mode"; then
+	if test -n "$nonopt"; then
+	  $echo "$modename: warning: cannot infer operation mode from \`$nonopt'" 1>&2
+	else
+	  $echo "$modename: warning: cannot infer operation mode without MODE-ARGS" 1>&2
+	fi
+      fi
+      ;;
+    esac
+  fi
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    $echo "$modename: unrecognized option \`-dlopen'" 1>&2
+    $echo "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$modename --help --mode=$mode' for more information."
+
+  # These modes are in order of execution frequency so that they run quickly.
+  case $mode in
+  # libtool compile mode
+  compile)
+    modename="$modename: compile"
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  if test -n "$libobj" ; then
+	    $echo "$modename: you cannot specify \`-o' more than once" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  args=`$echo "X$arg" | $Xsed -e "s/^-Wc,//"`
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+ 	  for arg in $args; do
+	    IFS="$save_ifs"
+
+	    # Double-quote args containing other shell metacharacters.
+	    # Many Bourne shells cannot handle close brackets correctly
+	    # in scan sets, so we specify it separately.
+	    case $arg in
+	      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	      arg="\"$arg\""
+	      ;;
+	    esac
+	    lastarg="$lastarg $arg"
+	  done
+	  IFS="$save_ifs"
+	  lastarg=`$echo "X$lastarg" | $Xsed -e "s/^ //"`
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	* )
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      lastarg=`$echo "X$lastarg" | $Xsed -e "$sed_quote_subst"`
+
+      case $lastarg in
+      # Double-quote args containing other shell metacharacters.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, and some SunOS ksh mistreat backslash-escaping
+      # in scan sets (worked around with variable expansion),
+      # and furthermore cannot handle '|' '&' '(' ')' in scan sets 
+      # at all, so we specify them separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	lastarg="\"$lastarg\""
+	;;
+      esac
+
+      base_compile="$base_compile $lastarg"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      $echo "$modename: you must specify an argument for -Xcompile"
+      exit $EXIT_FAILURE
+      ;;
+    target)
+      $echo "$modename: you must specify a target with \`-o'" 1>&2
+      exit $EXIT_FAILURE
+      ;;
+    *)
+      # Get the name of the library object.
+      [ -z "$libobj" ] && libobj=`$echo "X$srcfile" | $Xsed -e 's%^.*/%%'`
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    xform='[cCFSifmso]'
+    case $libobj in
+    *.ada) xform=ada ;;
+    *.adb) xform=adb ;;
+    *.ads) xform=ads ;;
+    *.asm) xform=asm ;;
+    *.c++) xform=c++ ;;
+    *.cc) xform=cc ;;
+    *.ii) xform=ii ;;
+    *.class) xform=class ;;
+    *.cpp) xform=cpp ;;
+    *.cxx) xform=cxx ;;
+    *.f90) xform=f90 ;;
+    *.for) xform=for ;;
+    *.java) xform=java ;;
+    esac
+
+    libobj=`$echo "X$libobj" | $Xsed -e "s/\.$xform$/.lo/"`
+
+    case $libobj in
+    *.lo) obj=`$echo "X$libobj" | $Xsed -e "$lo2o"` ;;
+    *)
+      $echo "$modename: cannot determine name of library object from \`$libobj'" 1>&2
+      exit $EXIT_FAILURE
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -static)
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    qlibobj=`$echo "X$libobj" | $Xsed -e "$sed_quote_subst"`
+    case $qlibobj in
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	qlibobj="\"$qlibobj\"" ;;
+    esac
+    test "X$libobj" != "X$qlibobj" \
+	&& $echo "X$libobj" | grep '[]~#^*{};<>?"'"'"' 	&()|`$[]' \
+	&& $echo "$modename: libobj name \`$libobj' may not contain shell special characters."
+    objname=`$echo "X$obj" | $Xsed -e 's%^.*/%%'`
+    xdir=`$echo "X$obj" | $Xsed -e 's%/[^/]*$%%'`
+    if test "X$xdir" = "X$obj"; then
+      xdir=
+    else
+      xdir=$xdir/
+    fi
+    lobj=${xdir}$objdir/$objname
+
+    if test -z "$base_compile"; then
+      $echo "$modename: you must specify a compilation command" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    $run $rm $removelist
+    trap "$run $rm $removelist; exit $EXIT_FAILURE" 1 2 15
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$echo "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+      removelist="$removelist $output_obj $lockfile"
+      trap "$run $rm $removelist; exit $EXIT_FAILURE" 1 2 15
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $run ln "$progpath" "$lockfile" 2>/dev/null; do
+	$show "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$echo "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$run $rm $removelist
+	exit $EXIT_FAILURE
+      fi
+      $echo "$srcfile" > "$lockfile"
+    fi
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    qsrcfile=`$echo "X$srcfile" | $Xsed -e "$sed_quote_subst"`
+    case $qsrcfile in
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+      qsrcfile="\"$qsrcfile\"" ;;
+    esac
+
+    $run $rm "$libobj" "${libobj}T"
+
+    # Create a libtool object file (analogous to a ".la" file),
+    # but don't create it if we're doing a dry run.
+    test -z "$run" && cat > ${libobj}T <<EOF
+# $libobj - a libtool object file
+# Generated by $PROGRAM - GNU $PACKAGE $VERSION$TIMESTAMP
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+EOF
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      if test ! -d "${xdir}$objdir"; then
+	$show "$mkdir ${xdir}$objdir"
+	$run $mkdir ${xdir}$objdir
+	exit_status=$?
+	if test "$exit_status" -ne 0 && test ! -d "${xdir}$objdir"; then
+	  exit $exit_status
+	fi
+      fi
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      $run $rm "$lobj" "$output_obj"
+
+      $show "$command"
+      if $run eval "$command"; then :
+      else
+	test -n "$output_obj" && $run $rm $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$echo "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$run $rm $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	$show "$mv $output_obj $lobj"
+	if $run $mv $output_obj $lobj; then :
+	else
+	  error=$?
+	  $run $rm $removelist
+	  exit $error
+	fi
+      fi
+
+      # Append the name of the PIC object to the libtool object file.
+      test -z "$run" && cat >> ${libobj}T <<EOF
+pic_object='$objdir/$objname'
+
+EOF
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+        suppress_output=' >/dev/null 2>&1'
+      fi
+    else
+      # No PIC object so indicate it doesn't exist in the libtool
+      # object file.
+      test -z "$run" && cat >> ${libobj}T <<EOF
+pic_object=none
+
+EOF
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      $run $rm "$obj" "$output_obj"
+      $show "$command"
+      if $run eval "$command"; then :
+      else
+	$run $rm $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$echo "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$run $rm $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	$show "$mv $output_obj $obj"
+	if $run $mv $output_obj $obj; then :
+	else
+	  error=$?
+	  $run $rm $removelist
+	  exit $error
+	fi
+      fi
+
+      # Append the name of the non-PIC object the libtool object file.
+      # Only append if the libtool object file exists.
+      test -z "$run" && cat >> ${libobj}T <<EOF
+# Name of the non-PIC object.
+non_pic_object='$objname'
+
+EOF
+    else
+      # Append the name of the non-PIC object the libtool object file.
+      # Only append if the libtool object file exists.
+      test -z "$run" && cat >> ${libobj}T <<EOF
+# Name of the non-PIC object.
+non_pic_object=none
+
+EOF
+    fi
+
+    $run $mv "${libobj}T" "${libobj}"
+
+    # Unlock the critical section if it was locked
+    if test "$need_locks" != no; then
+      $run $rm "$lockfile"
+    fi
+
+    exit $EXIT_SUCCESS
+    ;;
+
+  # libtool link mode
+  link | relink)
+    modename="$modename: link"
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args="$nonopt"
+    base_compile="$nonopt $@"
+    compile_command="$nonopt"
+    finalize_command="$nonopt"
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    notinst_path= # paths that contain not-installed libtool libraries
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -all-static | -static)
+	if test "X$arg" = "X-all-static"; then
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    $echo "$modename: warning: complete static linking is impossible in this configuration" 1>&2
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	else
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	fi
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      case $arg in
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	qarg=\"`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`\" ### testsuite: skip nested quoting test
+	;;
+      *) qarg=$arg ;;
+      esac
+      libtool_args="$libtool_args $qarg"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  compile_command="$compile_command @OUTPUT@"
+	  finalize_command="$finalize_command @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    compile_command="$compile_command @SYMFILE@"
+	    finalize_command="$finalize_command @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  if test ! -f "$arg"; then
+	    $echo "$modename: symbol file \`$arg' does not exist"
+	    exit $EXIT_FAILURE
+	  fi
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat $save_arg`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if (${SED} -e '2q' $arg | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		# If there is no directory component, then add one.
+		case $arg in
+		*/* | *\\*) . $arg ;;
+		*) . ./$arg ;;
+		esac
+
+		if test -z "$pic_object" || \
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none && \
+		   test "$non_pic_object" = none; then
+		  $echo "$modename: cannot find name of object for \`$arg'" 1>&2
+		  exit $EXIT_FAILURE
+		fi
+
+		# Extract subdirectory from the argument.
+		xdir=`$echo "X$arg" | $Xsed -e 's%/[^/]*$%%'`
+		if test "X$xdir" = "X$arg"; then
+		  xdir=
+		else
+		  xdir="$xdir/"
+		fi
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  libobjs="$libobjs $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  non_pic_objects="$non_pic_objects $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  non_pic_objects="$non_pic_objects $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if test -z "$run"; then
+		  $echo "$modename: \`$arg' is not a valid libtool object" 1>&2
+		  exit $EXIT_FAILURE
+		else
+		  # Dry-run case.
+
+		  # Extract subdirectory from the argument.
+		  xdir=`$echo "X$arg" | $Xsed -e 's%/[^/]*$%%'`
+		  if test "X$xdir" = "X$arg"; then
+		    xdir=
+		  else
+		    xdir="$xdir/"
+		  fi
+
+		  pic_object=`$echo "X${xdir}${objdir}/${arg}" | $Xsed -e "$lo2o"`
+		  non_pic_object=`$echo "X${xdir}${arg}" | $Xsed -e "$lo2o"`
+		  libobjs="$libobjs $pic_object"
+		  non_pic_objects="$non_pic_objects $non_pic_object"
+		fi
+	      fi
+	    done
+	  else
+	    $echo "$modename: link input file \`$save_arg' does not exist"
+	    exit $EXIT_FAILURE
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    $echo "$modename: only absolute run-paths are allowed" 1>&2
+	    exit $EXIT_FAILURE
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  compile_command="$compile_command $qarg"
+	  finalize_command="$finalize_command $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  compile_command="$compile_command $wl$qarg"
+	  finalize_command="$finalize_command $wl$qarg"
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  compile_command="$compile_command $qarg"
+	  finalize_command="$finalize_command $qarg"
+	  continue
+	  ;;
+	shrext)
+  	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	darwin_framework|darwin_framework_skip)
+	  test "$prev" = "darwin_framework" && compiler_flags="$compiler_flags $arg"
+	  compile_command="$compile_command $arg"
+	  finalize_command="$finalize_command $arg"
+	  prev=
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  compile_command="$compile_command $link_static_flag"
+	  finalize_command="$finalize_command $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	$echo "$modename: \`-allow-undefined' is deprecated because it is the default" 1>&2
+	continue
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  $echo "$modename: more than one -exported-symbols argument is not allowed"
+	  exit $EXIT_FAILURE
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework|-arch|-isysroot)
+	case " $CC " in
+	  *" ${arg} ${1} "* | *" ${arg}	${1} "*) 
+		prev=darwin_framework_skip ;;
+	  *) compiler_flags="$compiler_flags $arg"
+	     prev=darwin_framework ;;
+	esac
+	compile_command="$compile_command $arg"
+	finalize_command="$finalize_command $arg"
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  compile_command="$compile_command $arg"
+	  finalize_command="$finalize_command $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	dir=`$echo "X$arg" | $Xsed -e 's/^-L//'`
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  if test -z "$absdir"; then
+	    $echo "$modename: cannot determine absolute directory name of \`$dir'" 1>&2
+	    absdir="$dir"
+	    notinst_path="$notinst_path $dir"
+	  fi
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  testbindir=`$echo "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs -framework System"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      -model)
+	compile_command="$compile_command $arg"
+	compiler_flags="$compiler_flags $arg"
+	finalize_command="$finalize_command $arg"
+	prev=xcompiler
+	continue
+	;;
+
+     -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe)
+	compiler_flags="$compiler_flags $arg"
+	compile_command="$compile_command $arg"
+	finalize_command="$finalize_command $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m* pass through architecture-specific compiler args for GCC
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -pg pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*|-pg| \
+      -t[45]*|-txscale*|@*)
+
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	arg=`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`
+	case $arg in
+	*[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	  arg="\"$arg\""
+	  ;;
+	esac
+        compile_command="$compile_command $arg"
+        finalize_command="$finalize_command $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # in order for the loader to find any dlls it needs.
+	  $echo "$modename: warning: \`-no-install' is ignored for $host" 1>&2
+	  $echo "$modename: warning: assuming \`-no-fast-install' instead" 1>&2
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	dir=`$echo "X$arg" | $Xsed -e 's/^-R//'`
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  $echo "$modename: only absolute run-paths are allowed" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -static)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -Wc,*)
+	args=`$echo "X$arg" | $Xsed -e "$sed_quote_subst" -e 's/^-Wc,//'`
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+	  case $flag in
+	    *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	    flag="\"$flag\""
+	    ;;
+	  esac
+	  arg="$arg $wl$flag"
+	  compiler_flags="$compiler_flags $flag"
+	done
+	IFS="$save_ifs"
+	arg=`$echo "X$arg" | $Xsed -e "s/^ //"`
+	;;
+
+      -Wl,*)
+	args=`$echo "X$arg" | $Xsed -e "$sed_quote_subst" -e 's/^-Wl,//'`
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+	  case $flag in
+	    *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	    flag="\"$flag\""
+	    ;;
+	  esac
+	  arg="$arg $wl$flag"
+	  compiler_flags="$compiler_flags $wl$flag"
+	  linker_flags="$linker_flags $flag"
+	done
+	IFS="$save_ifs"
+	arg=`$echo "X$arg" | $Xsed -e "s/^ //"`
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # Some other compiler flag.
+      -* | +*)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	arg=`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`
+	case $arg in
+	*[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	  arg="\"$arg\""
+	  ;;
+	esac
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if (${SED} -e '2q' $arg | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  # If there is no directory component, then add one.
+	  case $arg in
+	  */* | *\\*) . $arg ;;
+	  *) . ./$arg ;;
+	  esac
+
+	  if test -z "$pic_object" || \
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none && \
+	     test "$non_pic_object" = none; then
+	    $echo "$modename: cannot find name of object for \`$arg'" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  xdir=`$echo "X$arg" | $Xsed -e 's%/[^/]*$%%'`
+	  if test "X$xdir" = "X$arg"; then
+	    xdir=
+ 	  else
+	    xdir="$xdir/"
+	  fi
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    libobjs="$libobjs $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    non_pic_objects="$non_pic_objects $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    non_pic_objects="$non_pic_objects $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if test -z "$run"; then
+	    $echo "$modename: \`$arg' is not a valid libtool object" 1>&2
+	    exit $EXIT_FAILURE
+	  else
+	    # Dry-run case.
+
+	    # Extract subdirectory from the argument.
+	    xdir=`$echo "X$arg" | $Xsed -e 's%/[^/]*$%%'`
+	    if test "X$xdir" = "X$arg"; then
+	      xdir=
+	    else
+	      xdir="$xdir/"
+	    fi
+
+	    pic_object=`$echo "X${xdir}${objdir}/${arg}" | $Xsed -e "$lo2o"`
+	    non_pic_object=`$echo "X${xdir}${arg}" | $Xsed -e "$lo2o"`
+	    libobjs="$libobjs $pic_object"
+	    non_pic_objects="$non_pic_objects $non_pic_object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	arg=`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`
+	case $arg in
+	*[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	  arg="\"$arg\""
+	  ;;
+	esac
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	compile_command="$compile_command $arg"
+	finalize_command="$finalize_command $arg"
+      fi
+    done # argument parsing loop
+
+    if test -n "$prev"; then
+      $echo "$modename: the \`$prevarg' option requires an argument" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      compile_command="$compile_command $arg"
+      finalize_command="$finalize_command $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    outputname=`$echo "X$output" | $Xsed -e 's%^.*/%%'`
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$echo \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    output_objdir=`$echo "X$output" | $Xsed -e 's%/[^/]*$%%'`
+    if test "X$output_objdir" = "X$output"; then
+      output_objdir="$objdir"
+    else
+      output_objdir="$output_objdir/$objdir"
+    fi
+    # Create the object directory.
+    if test ! -d "$output_objdir"; then
+      $show "$mkdir $output_objdir"
+      $run $mkdir $output_objdir
+      exit_status=$?
+      if test "$exit_status" -ne 0 && test ! -d "$output_objdir"; then
+	exit $exit_status
+      fi
+    fi
+
+    # Determine the type of output
+    case $output in
+    "")
+      $echo "$modename: you must specify an output file" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    case $host in
+    *cygwin* | *mingw* | *pw32*)
+      # don't eliminate duplications in $postdeps and $predeps
+      duplicate_compiler_generated_deps=yes
+      ;;
+    *)
+      duplicate_compiler_generated_deps=$duplicate_deps
+      ;;
+    esac
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if test "X$duplicate_deps" = "Xyes" ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if test "X$duplicate_compiler_generated_deps" = "Xyes" ; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    case $linkmode in
+    lib)
+	passes="conv link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    $echo "$modename: libraries can \`-dlopen' only libtool libraries: $file" 1>&2
+	    exit $EXIT_FAILURE
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+    for pass in $passes; do
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link) libs="$deplibs %DEPLIBS% $dependency_libs" ;;
+	esac
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    $echo "$modename: warning: \`-l' is ignored for archives/objects" 1>&2
+	    continue
+	  fi
+	  name=`$echo "X$deplib" | $Xsed -e 's/^-l//'`
+	  for searchdir in $newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if (${SED} -e '2q' $lib |
+                    grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+		  library_names=
+		  old_library=
+		  case $lib in
+		  */* | *\\*) . $lib ;;
+		  *) . ./$lib ;;
+		  esac
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    ladir=`$echo "X$lib" | $Xsed -e 's%/[^/]*$%%'`
+		    test "X$ladir" = "X$lib" && ladir="."
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+	        ;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    newlib_search_path="$newlib_search_path "`$echo "X$deplib" | $Xsed -e 's/^-L//'`
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    newlib_search_path="$newlib_search_path "`$echo "X$deplib" | $Xsed -e 's/^-L//'`
+	    ;;
+	  *)
+	    $echo "$modename: warning: \`-L' is ignored for archives/objects" 1>&2
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    dir=`$echo "X$deplib" | $Xsed -e 's/^-R//'`
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    valid_a_lib=no
+	    case $deplibs_check_method in
+	      match_pattern*)
+		set dummy $deplibs_check_method
+	        match_pattern_regex=`expr "$deplibs_check_method" : "$2 \(.*\)"`
+		if eval $echo \"$deplib\" 2>/dev/null \
+		    | $SED 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		  valid_a_lib=yes
+		fi
+		;;
+	      pass_all)
+		valid_a_lib=yes
+		;;
+            esac
+	    if test "$valid_a_lib" != yes; then
+	      $echo
+	      $echo "*** Warning: Trying to link with static lib archive $deplib."
+	      $echo "*** I have the capability to make that library automatically link in when"
+	      $echo "*** you link to this library.  But I can only do this if you have a"
+	      $echo "*** shared version of the library, which you do not appear to have"
+	      $echo "*** because the file extensions .$libext of this argument makes me believe"
+	      $echo "*** that it is just a static archive that I should not used here."
+	    else
+	      $echo
+	      $echo "*** Warning: Linking the shared library $output against the"
+	      $echo "*** static library $deplib is not portable!"
+	      deplibs="$deplib $deplibs"
+	    fi
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  $echo "$modename: cannot find the library \`$lib' or unhandled argument \`$deplib'" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	# Check to see that this really is a libtool archive.
+	if (${SED} -e '2q' $lib | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then :
+	else
+	  $echo "$modename: \`$lib' is not a valid libtool archive" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	ladir=`$echo "X$lib" | $Xsed -e 's%/[^/]*$%%'`
+	test "X$ladir" = "X$lib" && ladir="."
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	case $lib in
+	*/* | *\\*) . $lib ;;
+	*) . ./$lib ;;
+	esac
+
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      $echo "$modename: cannot find name of link library for \`$lib'" 1>&2
+	      exit $EXIT_FAILURE
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+              if test "X$duplicate_deps" = "Xyes" ; then
+	        case "$tmp_libs " in
+	        *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	        esac
+              fi
+	      tmp_libs="$tmp_libs $deplib"
+	    done
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    $echo "$modename: \`$lib' is not a convenience library" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  $echo "$modename: cannot find name of link library for \`$lib'" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    $echo "$modename: cannot -dlopen a convenience library: \`$lib'" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    $echo "$modename: warning: cannot determine absolute directory name of \`$ladir'" 1>&2
+	    $echo "$modename: passing it literally to the linker, although it might fail" 1>&2
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	laname=`$echo "X$lib" | $Xsed -e 's%^.*/%%'`
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    $echo "$modename: warning: library \`$lib' was moved." 1>&2
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	name=`$echo "X$laname" | $Xsed -e 's/\.la$//' -e 's/^lib//'`
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir"; then
+	    $echo "$modename: cannot -dlpreopen a convenience library: \`$lib'" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) newlib_search_path="$newlib_search_path "`$echo "X$deplib" | $Xsed -e 's/^-L//'`;; ### testsuite: skip nested quoting test
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if test "X$duplicate_deps" = "Xyes" ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { test "$prefer_static_libs" = no || test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath " in
+	      *" $dir "*) ;;
+	      *" $absdir "*) ;;
+	      *) temp_rpath="$temp_rpath $absdir" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes ; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  if test "$installed" = no; then
+	    notinst_deplibs="$notinst_deplibs $lib"
+	    need_relink=yes
+	  fi
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on
+	  # some systems (darwin)
+	  if test "$shouldnotlink" = yes && test "$pass" = link ; then
+	    $echo
+	    if test "$linkmode" = prog; then
+	      $echo "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $echo "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $echo "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    realname="$2"
+	    shift; shift
+	    libname=`eval \\$echo \"$libname_spec\"`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw*)
+		major=`expr $current - $age`
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    soname=`$echo $soroot | ${SED} -e 's/^.*\///'`
+	    newlib="libimp-`$echo $soname | ${SED} 's/^lib//;s/\.dll$//'`.a"
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      $show "extracting exported symbol list from \`$soname'"
+	      save_ifs="$IFS"; IFS='~'
+	      cmds=$extract_expsyms_cmds
+	      for cmd in $cmds; do
+		IFS="$save_ifs"
+		eval cmd=\"$cmd\"
+		$show "$cmd"
+		$run eval "$cmd" || exit $?
+	      done
+	      IFS="$save_ifs"
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      $show "generating import library for \`$soname'"
+	      save_ifs="$IFS"; IFS='~'
+	      cmds=$old_archive_from_expsyms_cmds
+	      for cmd in $cmds; do
+		IFS="$save_ifs"
+		eval cmd=\"$cmd\"
+		$show "$cmd"
+		$run eval "$cmd" || exit $?
+	      done
+	      IFS="$save_ifs"
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a module then we can not link against
+		    # it, someone is ignoring the new warnings I added
+		    if /usr/bin/file -L $add 2> /dev/null |
+                      $EGREP ": [^:]* bundle" >/dev/null ; then
+		      $echo "** Warning, lib $linklib is a module, not a shared library"
+		      if test -z "$old_library" ; then
+		        $echo
+		        $echo "** And there doesn't seem to be a static archive available"
+		        $echo "** The link will probably fail, sorry"
+		      else
+		        add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      $echo "$modename: configuration error: unsupported hardcode properties"
+	      exit $EXIT_FAILURE
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes && \
+		 test "$hardcode_minus_L" != yes && \
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+	        add="$inst_prefix_dir$libdir/$linklib"
+	      else
+	        add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $echo
+	    $echo "*** Warning: This system can not link to static lib archive $lib."
+	    $echo "*** I have the capability to make that library automatically link in when"
+	    $echo "*** you link to this library.  But I can only do this if you have a"
+	    $echo "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $echo "*** But as you try to build a module library, libtool will still create "
+	      $echo "*** a static module, that should work as long as the dlopening application"
+	      $echo "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$echo
+		$echo "*** However, this would only work if libtool was able to extract symbol"
+		$echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$echo "*** not find such a program.  So, this module is probably useless."
+		$echo "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) temp_xrpath=`$echo "X$libdir" | $Xsed -e 's/^-R//'`
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if test "X$duplicate_deps" = "Xyes" ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+		dir=`$echo "X$deplib" | $Xsed -e 's%/[^/]*$%%'`
+		test "X$dir" = "X$deplib" && dir="."
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    $echo "$modename: warning: cannot determine absolute directory name of \`$dir'" 1>&2
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if grep "^installed=no" $deplib > /dev/null; then
+		  path="$absdir/$objdir"
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  if test -z "$libdir"; then
+		    $echo "$modename: \`$deplib' is not a valid libtool archive" 1>&2
+		    exit $EXIT_FAILURE
+		  fi
+		  if test "$absdir" != "$libdir"; then
+		    $echo "$modename: warning: \`$deplib' seems to be moved" 1>&2
+		  fi
+		  path="$absdir"
+		fi
+		depdepl=
+		case $host in
+		*-*-darwin*)
+		  # we do not want to link against static libs,
+		  # but need to link against shared
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$path/$depdepl" ; then
+		      depdepl="$path/$depdepl"
+		    fi
+		    # do not add paths which are already there
+		    case " $newlib_search_path " in
+		    *" $path "*) ;;
+		    *) newlib_search_path="$newlib_search_path $path";;
+		    esac
+		  fi
+		  path=""
+		  ;;
+		*)
+		  path="-L$path"
+		  ;;
+		esac
+		;;
+	      -l*)
+		case $host in
+		*-*-darwin*)
+		  # Again, we only want to link against shared libraries
+		  eval tmp_libs=`$echo "X$deplib" | $Xsed -e "s,^\-l,,"`
+		  for tmp in $newlib_search_path ; do
+		    if test -f "$tmp/lib$tmp_libs.dylib" ; then
+		      eval depdepl="$tmp/lib$tmp_libs.dylib"
+		      break
+		    fi
+		  done
+		  path=""
+		  ;;
+		*) continue ;;
+		esac
+		;;
+	      *) continue ;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	      case " $deplibs " in
+	      *" $depdepl "*) ;;
+	      *) deplibs="$depdepl $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$deplibs"; then
+	$echo "$modename: warning: \`-l' and \`-L' are ignored for archives" 1>&2
+      fi
+
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	$echo "$modename: warning: \`-dlopen' is ignored for archives" 1>&2
+      fi
+
+      if test -n "$rpath"; then
+	$echo "$modename: warning: \`-rpath' is ignored for archives" 1>&2
+      fi
+
+      if test -n "$xrpath"; then
+	$echo "$modename: warning: \`-R' is ignored for archives" 1>&2
+      fi
+
+      if test -n "$vinfo"; then
+	$echo "$modename: warning: \`-version-info/-version-number' is ignored for archives" 1>&2
+      fi
+
+      if test -n "$release"; then
+	$echo "$modename: warning: \`-release' is ignored for archives" 1>&2
+      fi
+
+      if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	$echo "$modename: warning: \`-export-symbols' is ignored for archives" 1>&2
+      fi
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	name=`$echo "X$outputname" | $Xsed -e 's/\.la$//' -e 's/^lib//'`
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	if test "$module" = no; then
+	  $echo "$modename: libtool library \`$output' must begin with \`lib'" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  name=`$echo "X$outputname" | $Xsed -e 's/\.la$//'`
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  libname=`$echo "X$outputname" | $Xsed -e 's/\.la$//'`
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  $echo "$modename: cannot build libtool library \`$output' from non-libtool objects on this host:$objs" 2>&1
+	  exit $EXIT_FAILURE
+	else
+	  $echo
+	  $echo "*** Warning: Linking the shared library $output against the non-libtool"
+	  $echo "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      if test "$dlself" != no; then
+	$echo "$modename: warning: \`-dlopen self' is ignored for libtool libraries" 1>&2
+      fi
+
+      set dummy $rpath
+      if test "$#" -gt 2; then
+	$echo "$modename: warning: ignoring multiple \`-rpath's for a libtool library" 1>&2
+      fi
+      install_libdir="$2"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	if test -n "$vinfo"; then
+	  $echo "$modename: warning: \`-version-info/-version-number' is ignored for convenience libraries" 1>&2
+	fi
+
+	if test -n "$release"; then
+	  $echo "$modename: warning: \`-release' is ignored for convenience libraries" 1>&2
+	fi
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	IFS="$save_ifs"
+
+	if test -n "$8"; then
+	  $echo "$modename: too many parameters to \`-version-info'" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$2"
+	  number_minor="$3"
+	  number_revision="$4"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows)
+	    current=`expr $number_major + $number_minor`
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    current=`expr $number_major + $number_minor - 1`
+	    age="$number_minor"
+	    revision="$number_minor"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$2"
+	  revision="$3"
+	  age="$4"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  $echo "$modename: CURRENT \`$current' must be a nonnegative integer" 1>&2
+	  $echo "$modename: \`$vinfo' is not valid version information" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  $echo "$modename: REVISION \`$revision' must be a nonnegative integer" 1>&2
+	  $echo "$modename: \`$vinfo' is not valid version information" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  $echo "$modename: AGE \`$age' must be a nonnegative integer" 1>&2
+	  $echo "$modename: \`$vinfo' is not valid version information" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  $echo "$modename: AGE \`$age' is greater than the current interface number \`$current'" 1>&2
+	  $echo "$modename: \`$vinfo' is not valid version information" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  major=.`expr $current - $age`
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  minor_current=`expr $current + 1`
+	  verstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current";
+	  ;;
+
+	irix | nonstopux)
+	  major=`expr $current - $age + 1`
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    iface=`expr $revision - $loop`
+	    loop=`expr $loop - 1`
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  major=.`expr $current - $age`
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  major=.`expr $current - $age`
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    iface=`expr $current - $loop`
+	    loop=`expr $loop - 1`
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  major=`expr $current - $age`
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  $echo "$modename: unknown library version type \`$version_type'" 1>&2
+	  $echo "Fatal configuration error.  See the $PACKAGE docs for more information." 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    $echo "$modename: warning: undefined symbols not allowed in $host shared libraries" 1>&2
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+      fi
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$echo "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+	         if echo $p | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+	         then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	if test -n "$removelist"; then
+	  $show "${rm}r $removelist"
+	  $run ${rm}r $removelist
+	fi
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$echo "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      for path in $notinst_path; do
+	lib_search_path=`$echo "$lib_search_path " | ${SED} -e "s% $path % %g"`
+	deplibs=`$echo "$deplibs " | ${SED} -e "s% -L$path % %g"`
+	dependency_libs=`$echo "$dependency_libs " | ${SED} -e "s% -L$path % %g"`
+      done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs -framework System"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+ 	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $rm conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $rm conftest
+	  $LTCC $LTCFLAGS -o conftest conftest.c $deplibs
+	  if test "$?" -eq 0 ; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      name=`expr $i : '-l\(.*\)'`
+	      # If $name is empty we are operating on a -L argument.
+              if test "$name" != "" && test "$name" -ne "0"; then
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+	        fi
+		if test -n "$i" ; then
+		  libname=`eval \\$echo \"$libname_spec\"`
+		  deplib_matches=`eval \\$echo \"$library_names_spec\"`
+		  set dummy $deplib_matches
+		  deplib_match=$2
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $echo
+		    $echo "*** Warning: dynamic linker does not accept needed library $i."
+		    $echo "*** I have the capability to make that library automatically link in when"
+		    $echo "*** you link to this library.  But I can only do this if you have a"
+		    $echo "*** shared version of the library, which I believe you do not have"
+		    $echo "*** because a test_compile did reveal that the linker did not use it for"
+		    $echo "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+	      else
+		newdeplibs="$newdeplibs $i"
+	      fi
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      name=`expr $i : '-l\(.*\)'`
+	      # If $name is empty we are operating on a -L argument.
+              if test "$name" != "" && test "$name" != "0"; then
+		$rm conftest
+		$LTCC $LTCFLAGS -o conftest conftest.c $i
+		# Did it work?
+		if test "$?" -eq 0 ; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval \\$echo \"$libname_spec\"`
+		    deplib_matches=`eval \\$echo \"$library_names_spec\"`
+		    set dummy $deplib_matches
+		    deplib_match=$2
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $echo
+		      $echo "*** Warning: dynamic linker does not accept needed library $i."
+		      $echo "*** I have the capability to make that library automatically link in when"
+		      $echo "*** you link to this library.  But I can only do this if you have a"
+		      $echo "*** shared version of the library, which you do not appear to have"
+		      $echo "*** because a test_compile did reveal that the linker did not use this one"
+		      $echo "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $echo
+		  $echo "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $echo "***  make it link in!  You will probably need to install it or some"
+		  $echo "*** library that it depends on before this library will be fully"
+		  $echo "*** functional.  Installing it before continuing would be even better."
+		fi
+	      else
+		newdeplibs="$newdeplibs $i"
+	      fi
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method
+	  file_magic_regex=`expr "$deplibs_check_method" : "$2 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    name=`expr $a_deplib : '-l\(.*\)'`
+	    # If $name is empty we are operating on a -L argument.
+            if test "$name" != "" && test  "$name" != "0"; then
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval \\$echo \"$libname_spec\"`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null \
+			 | grep " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$echo "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null \
+			 | ${SED} 10q \
+			 | $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$echo
+		$echo "*** Warning: linker path does not have real file for library $a_deplib."
+		$echo "*** I have the capability to make that library automatically link in when"
+		$echo "*** you link to this library.  But I can only do this if you have a"
+		$echo "*** shared version of the library, which you do not appear to have"
+		$echo "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $echo "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $echo "*** with $libname and none of the candidates passed a file format test"
+		  $echo "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	    else
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	    fi
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$2 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    name=`expr $a_deplib : '-l\(.*\)'`
+	    # If $name is empty we are operating on a -L argument.
+	    if test -n "$name" && test "$name" != "0"; then
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval \\$echo \"$libname_spec\"`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval $echo \"$potent_lib\" 2>/dev/null \
+		        | ${SED} 10q \
+		        | $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$echo
+		$echo "*** Warning: linker path does not have real file for library $a_deplib."
+		$echo "*** I have the capability to make that library automatically link in when"
+		$echo "*** you link to this library.  But I can only do this if you have a"
+		$echo "*** shared version of the library, which you do not appear to have"
+		$echo "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $echo "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $echo "*** with $libname and none of the candidates passed a file format test"
+		  $echo "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	    else
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	    fi
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$echo "X $deplibs" | $Xsed -e 's/ -lc$//' \
+	    -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$echo "X $tmp_deplibs" | ${SED} -e "1s,^X,," -e "s,$i,,"`
+	    done
+	  fi
+	  if $echo "X $tmp_deplibs" | $Xsed -e 's/[ 	]//g' \
+	    | grep . >/dev/null; then
+	    $echo
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $echo "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $echo "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $echo "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library is the System framework
+	  newdeplibs=`$echo "X $newdeplibs" | $Xsed -e 's/ -lc / -framework System /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $echo
+	    $echo "*** Warning: libtool could not satisfy all declared inter-library"
+	    $echo "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $echo "*** a static module, that should work as long as the dlopening"
+	    $echo "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $echo
+	      $echo "*** However, this would only work if libtool was able to extract symbol"
+	      $echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $echo "*** not find such a program.  So, this module is probably useless."
+	      $echo "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $echo "*** The inter-library dependencies that have been dropped here will be"
+	    $echo "*** automatically added whenever a program is linked with this library"
+	    $echo "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $echo
+	      $echo "*** Since this library must not contain undefined symbols,"
+	      $echo "*** because either the platform does not support them or"
+	      $echo "*** it was explicitly requested with -no-undefined,"
+	      $echo "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	realname="$2"
+	shift; shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$echo "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    $show "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $run $rm $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      if len=`expr "X$cmd" : ".*"` &&
+	       test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	        $show "$cmd"
+	        $run eval "$cmd" || exit $?
+	        skipped_export=false
+	      else
+	        # The command line is too long to execute in one step.
+	        $show "using reloadable object file for export list..."
+	        skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex"; then
+	      $show "$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\""
+	      $run eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      $show "$mv \"${export_symbols}T\" \"$export_symbols\""
+	      $run eval '$mv "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $run eval '$echo "X$include_expsyms" | $SP2NL >> "$export_symbols"'
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+		case " $convenience " in
+		*" $test_deplib "*) ;;
+		*)
+			tmp_deplibs="$tmp_deplibs $test_deplib"
+			;;
+		esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	  fi
+	fi
+	
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $run eval '(cd $output_objdir && $rm ${realname}U && $mv $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	  eval test_cmds=\"$archive_expsym_cmds\"
+	  cmds=$archive_expsym_cmds
+	else
+	  eval test_cmds=\"$archive_cmds\"
+	  cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+	   test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise.
+	  $echo "creating reloadable object files..."
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$echo "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  delfiles=
+	  last_robj=
+	  k=1
+	  output=$output_objdir/$output_la-${k}.$objext
+	  # Loop over the list of objects to be linked.
+	  for obj in $save_libobjs
+	  do
+	    eval test_cmds=\"$reload_cmds $objlist $last_robj\"
+	    if test "X$objlist" = X ||
+	       { len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+		 test "$len" -le "$max_cmd_len"; }; then
+	      objlist="$objlist $obj"
+	    else
+	      # The command $test_cmds is almost too long, add a
+	      # command to the queue.
+	      if test "$k" -eq 1 ; then
+		# The first file doesn't have a previous command to add.
+		eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+	      else
+		# All subsequent reloadable object files will link in
+		# the last one created.
+		eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj\"
+	      fi
+	      last_robj=$output_objdir/$output_la-${k}.$objext
+	      k=`expr $k + 1`
+	      output=$output_objdir/$output_la-${k}.$objext
+	      objlist=$obj
+	      len=1
+	    fi
+	  done
+	  # Handle the remaining objects by creating one last
+	  # reloadable object file.  All subsequent reloadable object
+	  # files will link in the last one created.
+	  test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	  eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+
+	  if ${skipped_export-false}; then
+	    $show "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $run $rm $export_symbols
+	    libobjs=$output
+	    # Append the command to create the export file.
+	    eval concat_cmds=\"\$concat_cmds~$export_symbols_cmds\"
+          fi
+
+	  # Set up a command to remove the reloadable object files
+	  # after they are used.
+	  i=0
+	  while test "$i" -lt "$k"
+	  do
+	    i=`expr $i + 1`
+	    delfiles="$delfiles $output_objdir/$output_la-${i}.$objext"
+	  done
+
+	  $echo "creating a temporary reloadable object file: $output"
+
+	  # Loop through the commands generated above and execute them.
+	  save_ifs="$IFS"; IFS='~'
+	  for cmd in $concat_cmds; do
+	    IFS="$save_ifs"
+	    $show "$cmd"
+	    $run eval "$cmd" || exit $?
+	  done
+	  IFS="$save_ifs"
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    cmds=$archive_expsym_cmds
+	  else
+	    cmds=$archive_cmds
+	    fi
+	  fi
+
+	  # Append the command to remove the reloadable object files
+	  # to the just-reset $cmds.
+	  eval cmds=\"\$cmds~\$rm $delfiles\"
+	fi
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $show "$cmd"
+	  $run eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      $run eval '(cd $output_objdir && $rm ${realname}T && $mv ${realname}U $realname)'
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $run eval '(cd $output_objdir && $rm ${realname}T && $mv $realname ${realname}T && $mv "$realname"U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      $show "${rm}r $gentop"
+	      $run ${rm}r "$gentop"
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    $show "(cd $output_objdir && $rm $linkname && $LN_S $realname $linkname)"
+	    $run eval '(cd $output_objdir && $rm $linkname && $LN_S $realname $linkname)' || exit $?
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$deplibs"; then
+	$echo "$modename: warning: \`-l' and \`-L' are ignored for objects" 1>&2
+      fi
+
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	$echo "$modename: warning: \`-dlopen' is ignored for objects" 1>&2
+      fi
+
+      if test -n "$rpath"; then
+	$echo "$modename: warning: \`-rpath' is ignored for objects" 1>&2
+      fi
+
+      if test -n "$xrpath"; then
+	$echo "$modename: warning: \`-R' is ignored for objects" 1>&2
+      fi
+
+      if test -n "$vinfo"; then
+	$echo "$modename: warning: \`-version-info' is ignored for objects" 1>&2
+      fi
+
+      if test -n "$release"; then
+	$echo "$modename: warning: \`-release' is ignored for objects" 1>&2
+      fi
+
+      case $output in
+      *.lo)
+	if test -n "$objs$old_deplibs"; then
+	  $echo "$modename: cannot build library object \`$output' from non-libtool objects" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+	libobj="$output"
+	obj=`$echo "X$output" | $Xsed -e "$lo2o"`
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $run $rm $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval reload_conv_objs=\"\$reload_objs $whole_archive_flag_spec\"
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$echo "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      cmds=$reload_cmds
+      save_ifs="$IFS"; IFS='~'
+      for cmd in $cmds; do
+	IFS="$save_ifs"
+	eval cmd=\"$cmd\"
+	$show "$cmd"
+	$run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  $show "${rm}r $gentop"
+	  $run ${rm}r $gentop
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  $show "${rm}r $gentop"
+	  $run ${rm}r $gentop
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $run eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	cmds=$reload_cmds
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $show "$cmd"
+	  $run eval "$cmd" || exit $?
+	done
+	IFS="$save_ifs"
+      fi
+
+      if test -n "$gentop"; then
+	$show "${rm}r $gentop"
+	$run ${rm}r $gentop
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) output=`$echo $output | ${SED} -e 's,.exe$,,;s,$,.exe,'` ;;
+      esac
+      if test -n "$vinfo"; then
+	$echo "$modename: warning: \`-version-info' is ignored for programs" 1>&2
+      fi
+
+      if test -n "$release"; then
+	$echo "$modename: warning: \`-release' is ignored for programs" 1>&2
+      fi
+
+      if test "$preload" = yes; then
+	if test "$dlopen_support" = unknown && test "$dlopen_self" = unknown &&
+	   test "$dlopen_self_static" = unknown; then
+	  $echo "$modename: warning: \`AC_LIBTOOL_DLOPEN' not used. Assuming no dlopen support."
+	fi
+      fi
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$echo "X $compile_deplibs" | $Xsed -e 's/ -lc / -framework System /'`
+	finalize_deplibs=`$echo "X $finalize_deplibs" | $Xsed -e 's/ -lc / -framework System /'`
+	;;
+      esac
+
+      case $host in
+      *darwin*)
+        # Don't allow lazy linking, it breaks C++ global constructors
+        if test "$tagname" = CXX ; then
+        compile_command="$compile_command ${wl}-bind_at_load"
+        finalize_command="$finalize_command ${wl}-bind_at_load"
+        fi
+        ;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2*)
+	  testbindir=`$echo "X$libdir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$echo "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$echo "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      dlsyms=
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	  dlsyms="${outputname}S.c"
+	else
+	  $echo "$modename: not configured to extract global symbols from dlpreopened files" 1>&2
+	fi
+      fi
+
+      if test -n "$dlsyms"; then
+	case $dlsyms in
+	"") ;;
+	*.c)
+	  # Discover the nlist of each of the dlfiles.
+	  nlist="$output_objdir/${outputname}.nm"
+
+	  $show "$rm $nlist ${nlist}S ${nlist}T"
+	  $run $rm "$nlist" "${nlist}S" "${nlist}T"
+
+	  # Parse the name list into a source file.
+	  $show "creating $output_objdir/$dlsyms"
+
+	  test -z "$run" && $echo > "$output_objdir/$dlsyms" "\
+/* $dlsyms - symbol resolution table for \`$outputname' dlsym emulation. */
+/* Generated by $PROGRAM - GNU $PACKAGE $VERSION$TIMESTAMP */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* Prevent the only kind of declaration conflicts we can make. */
+#define lt_preloaded_symbols some_other_symbol
+
+/* External symbol declarations for the compiler. */\
+"
+
+	  if test "$dlself" = yes; then
+	    $show "generating symbol list for \`$output'"
+
+	    test -z "$run" && $echo ': @PROGRAM@ ' > "$nlist"
+
+	    # Add our own program objects to the symbol list.
+	    progfiles=`$echo "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	    for arg in $progfiles; do
+	      $show "extracting global C symbols from \`$arg'"
+	      $run eval "$NM $arg | $global_symbol_pipe >> '$nlist'"
+	    done
+
+	    if test -n "$exclude_expsyms"; then
+	      $run eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      $run eval '$mv "$nlist"T "$nlist"'
+	    fi
+
+	    if test -n "$export_symbols_regex"; then
+	      $run eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      $run eval '$mv "$nlist"T "$nlist"'
+	    fi
+
+	    # Prepare the list of exported symbols
+	    if test -z "$export_symbols"; then
+	      export_symbols="$output_objdir/$outputname.exp"
+	      $run $rm $export_symbols
+	      $run eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+              case $host in
+              *cygwin* | *mingw* )
+	        $run eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+		$run eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+                ;;
+              esac
+	    else
+	      $run eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      $run eval 'grep -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      $run eval 'mv "$nlist"T "$nlist"'
+              case $host in
+              *cygwin* | *mingw* )
+	        $run eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+		$run eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+                ;;
+              esac
+	    fi
+	  fi
+
+	  for arg in $dlprefiles; do
+	    $show "extracting global C symbols from \`$arg'"
+	    name=`$echo "$arg" | ${SED} -e 's%^.*/%%'`
+	    $run eval '$echo ": $name " >> "$nlist"'
+	    $run eval "$NM $arg | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -z "$run"; then
+	    # Make sure we have at least an empty file.
+	    test -f "$nlist" || : > "$nlist"
+
+	    if test -n "$exclude_expsyms"; then
+	      $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	      $mv "$nlist"T "$nlist"
+	    fi
+
+	    # Try sorting and uniquifying the output.
+	    if grep -v "^: " < "$nlist" |
+		if sort -k 3 </dev/null >/dev/null 2>&1; then
+		  sort -k 3
+		else
+		  sort +2
+		fi |
+		uniq > "$nlist"S; then
+	      :
+	    else
+	      grep -v "^: " < "$nlist" > "$nlist"S
+	    fi
+
+	    if test -f "$nlist"S; then
+	      eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$dlsyms"'
+	    else
+	      $echo '/* NONE */' >> "$output_objdir/$dlsyms"
+	    fi
+
+	    $echo >> "$output_objdir/$dlsyms" "\
+
+#undef lt_preloaded_symbols
+
+#if defined (__STDC__) && __STDC__
+# define lt_ptr void *
+#else
+# define lt_ptr char *
+# define const
+#endif
+
+/* The mapping between symbol names and symbols. */
+"
+
+	    case $host in
+	    *cygwin* | *mingw* )
+	  $echo >> "$output_objdir/$dlsyms" "\
+/* DATA imports from DLLs on WIN32 can't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs */
+struct {
+"
+	      ;;
+	    * )
+	  $echo >> "$output_objdir/$dlsyms" "\
+const struct {
+"
+	      ;;
+	    esac
+
+
+	  $echo >> "$output_objdir/$dlsyms" "\
+  const char *name;
+  lt_ptr address;
+}
+lt_preloaded_symbols[] =
+{\
+"
+
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$dlsyms"
+
+	    $echo >> "$output_objdir/$dlsyms" "\
+  {0, (lt_ptr) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	  fi
+
+	  pic_flag_for_symtable=
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    case "$compile_command " in
+	    *" -static "*) ;;
+	    *) pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND";;
+	    esac;;
+	  *-*-hpux*)
+	    case "$compile_command " in
+	    *" -static "*) ;;
+	    *) pic_flag_for_symtable=" $pic_flag";;
+	    esac
+	  esac
+
+	  # Now compile the dynamic symbol file.
+	  $show "(cd $output_objdir && $LTCC  $LTCFLAGS -c$no_builtin_flag$pic_flag_for_symtable \"$dlsyms\")"
+	  $run eval '(cd $output_objdir && $LTCC  $LTCFLAGS -c$no_builtin_flag$pic_flag_for_symtable "$dlsyms")' || exit $?
+
+	  # Clean up the generated files.
+	  $show "$rm $output_objdir/$dlsyms $nlist ${nlist}S ${nlist}T"
+	  $run $rm "$output_objdir/$dlsyms" "$nlist" "${nlist}S" "${nlist}T"
+
+	  # Transform the symbol file into the correct name.
+          case $host in
+          *cygwin* | *mingw* )
+            if test -f "$output_objdir/${outputname}.def" ; then
+              compile_command=`$echo "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}.def $output_objdir/${outputname}S.${objext}%"`
+              finalize_command=`$echo "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}.def $output_objdir/${outputname}S.${objext}%"`
+            else
+              compile_command=`$echo "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}S.${objext}%"`
+              finalize_command=`$echo "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}S.${objext}%"`
+             fi
+            ;;
+          * )
+            compile_command=`$echo "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}S.${objext}%"`
+            finalize_command=`$echo "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/${outputname}S.${objext}%"`
+            ;;
+          esac
+	  ;;
+	*)
+	  $echo "$modename: unknown suffix for \`$dlsyms'" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+      else
+	# We keep going just in case the user didn't refer to
+	# lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+	# really was required.
+
+	# Nullify the symbol file.
+	compile_command=`$echo "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+	finalize_command=`$echo "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+      fi
+
+      if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+	# Replace the output file specification.
+	compile_command=`$echo "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	$show "$link_command"
+	$run eval "$link_command"
+	exit_status=$?
+
+	# Delete the generated files.
+	if test -n "$dlsyms"; then
+	  $show "$rm $output_objdir/${outputname}S.${objext}"
+	  $run $rm "$output_objdir/${outputname}S.${objext}"
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$shlibpath_var"; then
+	# We should set the shlibpath_var
+	rpath=
+	for dir in $temp_rpath; do
+	  case $dir in
+	  [\\/]* | [A-Za-z]:[\\/]*)
+	    # Absolute path.
+	    rpath="$rpath$dir:"
+	    ;;
+	  *)
+	    # Relative path: add a thisdir entry.
+	    rpath="$rpath\$thisdir/$dir:"
+	    ;;
+	  esac
+	done
+	temp_rpath="$rpath"
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$echo "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$run $rm $output
+	# Link the executable and exit
+	$show "$link_command"
+	$run eval "$link_command" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	$echo "$modename: warning: this platform does not like uninstalled shared libraries" 1>&2
+	$echo "$modename: \`$output' will be relinked during installation" 1>&2
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$echo "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$echo "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $run $rm $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      $show "$link_command"
+      $run eval "$link_command" || exit $?
+
+      # Now create the wrapper script.
+      $show "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    var_value=`$echo "X$var_value" | $Xsed -e "$sed_quote_subst"`
+	    relink_command="$var=\"$var_value\"; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$echo "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $echo for shipping.
+      if test "X$echo" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$echo "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$echo "X$echo" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if our run command is non-null.
+      if test -z "$run"; then
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) output=`$echo $output|${SED} 's,.exe$,,'` ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    outputname=`$echo $outputname|${SED} 's,.exe$,,'` ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+            output_name=`basename $output`
+            output_path=`dirname $output`
+            cwrappersource="$output_path/$objdir/lt-$output_name.c"
+            cwrapper="$output_path/$output_name.exe"
+            $rm $cwrappersource $cwrapper
+            trap "$rm $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    cat > $cwrappersource <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM - GNU $PACKAGE $VERSION$TIMESTAMP
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "/bin/sh $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat >> $cwrappersource<<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+        (((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+/* -DDEBUG is fairly common in CFLAGS.  */
+#undef DEBUG
+#if defined DEBUGWRAPPER
+# define DEBUG(format, ...) fprintf(stderr, format, __VA_ARGS__)
+#else
+# define DEBUG(format, ...)
+#endif
+
+const char *program_name = NULL;
+
+void * xmalloc (size_t num);
+char * xstrdup (const char *string);
+const char * base_name (const char *name);
+char * find_executable(const char *wrapper);
+int    check_executable(const char *path);
+char * strendzap(char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  DEBUG("(main) argv[0]      : %s\n",argv[0]);
+  DEBUG("(main) program_name : %s\n",program_name);
+  newargz = XMALLOC(char *, argc+2);
+EOF
+
+            cat >> $cwrappersource <<EOF
+  newargz[0] = (char *) xstrdup("$SHELL");
+EOF
+
+            cat >> $cwrappersource <<"EOF"
+  newargz[1] = find_executable(argv[0]);
+  if (newargz[1] == NULL)
+    lt_fatal("Couldn't find %s", argv[0]);
+  DEBUG("(main) found exe at : %s\n",newargz[1]);
+  /* we know the script has the same name, without the .exe */
+  /* so make sure newargz[1] doesn't end in .exe */
+  strendzap(newargz[1],".exe");
+  for (i = 1; i < argc; i++)
+    newargz[i+1] = xstrdup(argv[i]);
+  newargz[argc+1] = NULL;
+
+  for (i=0; i<argc+1; i++)
+  {
+    DEBUG("(main) newargz[%d]   : %s\n",i,newargz[i]);
+    ;
+  }
+
+EOF
+
+            case $host_os in
+	      *cygwin* | *mingw* )
+                cat >> $cwrappersource <<EOF
+  execv("$SHELL",(char const **)newargz);
+EOF
+              ;;
+              *)
+                cat >> $cwrappersource <<EOF
+  execv("$SHELL",newargz);
+EOF
+              ;;
+            esac
+
+            cat >> $cwrappersource <<"EOF"
+  return 127;
+}
+
+void *
+xmalloc (size_t num)
+{
+  void * p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1), string) : NULL
+;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char)name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable(const char * path)
+{
+  struct stat st;
+
+  DEBUG("(check_executable)  : %s\n", path ? (*path ? path : "EMPTY!") : "NULL!");
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0) &&
+      (
+        /* MinGW & native WIN32 do not support S_IXOTH or S_IXGRP */
+#if defined (S_IXOTH)
+       ((st.st_mode & S_IXOTH) == S_IXOTH) ||
+#endif
+#if defined (S_IXGRP)
+       ((st.st_mode & S_IXGRP) == S_IXGRP) ||
+#endif
+       ((st.st_mode & S_IXUSR) == S_IXUSR))
+      )
+    return 1;
+  else
+    return 0;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise */
+char *
+find_executable (const char* wrapper)
+{
+  int has_slash = 0;
+  const char* p;
+  const char* p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char* concat_name;
+
+  DEBUG("(find_executable)  : %s\n", wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!");
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char)wrapper[0]) && wrapper[1] == ':')
+  {
+    concat_name = xstrdup (wrapper);
+    if (check_executable(concat_name))
+      return concat_name;
+    XFREE(concat_name);
+  }
+  else
+  {
+#endif
+    if (IS_DIR_SEPARATOR (wrapper[0]))
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable(concat_name))
+        return concat_name;
+      XFREE(concat_name);
+    }
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+    {
+      has_slash = 1;
+      break;
+    }
+  if (!has_slash)
+  {
+    /* no slashes; search PATH */
+    const char* path = getenv ("PATH");
+    if (path != NULL)
+    {
+      for (p = path; *p; p = p_next)
+      {
+        const char* q;
+        size_t p_len;
+        for (q = p; *q; q++)
+          if (IS_PATH_SEPARATOR(*q))
+            break;
+        p_len = q - p;
+        p_next = (*q == '\0' ? q : q + 1);
+        if (p_len == 0)
+        {
+          /* empty path: current directory */
+          if (getcwd (tmp, LT_PATHMAX) == NULL)
+            lt_fatal ("getcwd failed");
+          tmp_len = strlen(tmp);
+          concat_name = XMALLOC(char, tmp_len + 1 + strlen(wrapper) + 1);
+          memcpy (concat_name, tmp, tmp_len);
+          concat_name[tmp_len] = '/';
+          strcpy (concat_name + tmp_len + 1, wrapper);
+        }
+        else
+        {
+          concat_name = XMALLOC(char, p_len + 1 + strlen(wrapper) + 1);
+          memcpy (concat_name, p, p_len);
+          concat_name[p_len] = '/';
+          strcpy (concat_name + p_len + 1, wrapper);
+        }
+        if (check_executable(concat_name))
+          return concat_name;
+        XFREE(concat_name);
+      }
+    }
+    /* not found in PATH; assume curdir */
+  }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen(tmp);
+  concat_name = XMALLOC(char, tmp_len + 1 + strlen(wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable(concat_name))
+    return concat_name;
+  XFREE(concat_name);
+  return NULL;
+}
+
+char *
+strendzap(char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert(str != NULL);
+  assert(pat != NULL);
+
+  len = strlen(str);
+  patlen = strlen(pat);
+
+  if (patlen <= len)
+  {
+    str += len - patlen;
+    if (strcmp(str, pat) == 0)
+      *str = '\0';
+  }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char * mode,
+          const char * message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+EOF
+          # we should really use a build-platform specific compiler
+          # here, but OTOH, the wrappers (shell script and this C one)
+          # are only useful if you want to execute the "real" binary.
+          # Since the "real" binary is built for $host, then this
+          # wrapper might as well be built for $host, too.
+          $run $LTCC $LTCFLAGS -s -o $cwrapper $cwrappersource
+          ;;
+        esac
+        $rm $output
+        trap "$rm $output; exit $EXIT_FAILURE" 1 2 15
+
+	$echo > $output "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM - GNU $PACKAGE $VERSION$TIMESTAMP
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variable:
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$echo are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    echo=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`(\$echo '\t') 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$echo works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$echo will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$echo >> $output "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$echo \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$echo \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$echo \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $echo >> $output "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" || \\
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $mkdir \"\$progdir\"
+    else
+      $rm \"\$progdir/\$file\"
+    fi"
+
+	  $echo >> $output "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$echo \"\$relink_command_output\" >&2
+	$rm \"\$progdir/\$file\"
+	exit $EXIT_FAILURE
+      fi
+    fi
+
+    $mv \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $rm \"\$progdir/\$program\";
+      $mv \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $rm \"\$progdir/\$file\"
+  fi"
+	else
+	  $echo >> $output "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$echo >> $output "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $echo >> $output "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$echo \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $echo >> $output "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$echo >> $output "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2*)
+	  $echo >> $output "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $echo >> $output "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$echo >> $output "\
+      \$echo \"\$0: cannot exec \$program \${1+\"\$@\"}\"
+      exit $EXIT_FAILURE
+    fi
+  else
+    # The program doesn't exist.
+    \$echo \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$echo \"This script is just a wrapper for \$program.\" 1>&2
+    $echo \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit $EXIT_FAILURE
+  fi
+fi\
+"
+	chmod +x $output
+      fi
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+       cmds=$old_archive_from_new_cmds
+      else
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      $echo "X$obj" | $Xsed -e 's%^.*/%%'
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $echo "copying selected object files to avoid basename conflicts..."
+
+	  if test -z "$gentop"; then
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    $show "${rm}r $gentop"
+	    $run ${rm}r "$gentop"
+	    $show "$mkdir $gentop"
+	    $run $mkdir "$gentop"
+	    exit_status=$?
+	    if test "$exit_status" -ne 0 && test ! -d "$gentop"; then
+	      exit $exit_status
+	    fi
+	  fi
+
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    objbase=`$echo "X$obj" | $Xsed -e 's%^.*/%%'`
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		counter=`expr $counter + 1`
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      $show "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      $run ln "$obj" "$gentop/$newobj" ||
+	      $run cp "$obj" "$gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+
+	eval cmds=\"$old_archive_cmds\"
+
+	if len=`expr "X$cmds" : ".*"` &&
+	     test "$len" -le "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  $echo "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  for obj in $save_oldobjs
+	  do
+	    oldobjs="$objlist $obj"
+	    objlist="$objlist $obj"
+	    eval test_cmds=\"$old_archive_cmds\"
+	    if len=`expr "X$test_cmds" : ".*" 2>/dev/null` &&
+	       test "$len" -le "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+	        RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      save_ifs="$IFS"; IFS='~'
+      for cmd in $cmds; do
+        eval cmd=\"$cmd\"
+	IFS="$save_ifs"
+	$show "$cmd"
+	$run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+    done
+
+    if test -n "$generated"; then
+      $show "${rm}r$generated"
+      $run ${rm}r$generated
+    fi
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      $show "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  var_value=`$echo "X$var_value" | $Xsed -e "$sed_quote_subst"`
+	  relink_command="$var=\"$var_value\"; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$echo "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+
+      # Only create the output if not a dry run.
+      if test -z "$run"; then
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		name=`$echo "X$deplib" | $Xsed -e 's%^.*/%%'`
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		if test -z "$libdir"; then
+		  $echo "$modename: \`$deplib' is not a valid libtool archive" 1>&2
+		  exit $EXIT_FAILURE
+		fi
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      name=`$echo "X$lib" | $Xsed -e 's%^.*/%%'`
+	      eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+	      if test -z "$libdir"; then
+		$echo "$modename: \`$lib' is not a valid libtool archive" 1>&2
+		exit $EXIT_FAILURE
+	      fi
+	      newdlfiles="$newdlfiles $libdir/$name"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      name=`$echo "X$lib" | $Xsed -e 's%^.*/%%'`
+	      eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+	      if test -z "$libdir"; then
+		$echo "$modename: \`$lib' is not a valid libtool archive" 1>&2
+		exit $EXIT_FAILURE
+	      fi
+	      newdlprefiles="$newdlprefiles $libdir/$name"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $rm $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $echo > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM - GNU $PACKAGE $VERSION$TIMESTAMP
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $echo >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      fi
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      $show "(cd $output_objdir && $rm $outputname && $LN_S ../$outputname $outputname)"
+      $run eval '(cd $output_objdir && $rm $outputname && $LN_S ../$outputname $outputname)' || exit $?
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+    ;;
+
+  # libtool install mode
+  install)
+    modename="$modename: install"
+
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $echo "X$nonopt" | grep shtool > /dev/null; then
+      # Aesthetically quote it.
+      arg=`$echo "X$nonopt" | $Xsed -e "$sed_quote_subst"`
+      case $arg in
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	arg="\"$arg\""
+	;;
+      esac
+      install_prog="$arg "
+      arg="$1"
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    arg=`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`
+    case $arg in
+    *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+      arg="\"$arg\""
+      ;;
+    esac
+    install_prog="$install_prog$arg"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f) 
+      	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o) prev=$arg ;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      arg=`$echo "X$arg" | $Xsed -e "$sed_quote_subst"`
+      case $arg in
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+	arg="\"$arg\""
+	;;
+      esac
+      install_prog="$install_prog $arg"
+    done
+
+    if test -z "$install_prog"; then
+      $echo "$modename: you must specify an install program" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    if test -n "$prev"; then
+      $echo "$modename: the \`$prev' option requires an argument" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	$echo "$modename: no file or destination specified" 1>&2
+      else
+	$echo "$modename: you must specify a destination" 1>&2
+      fi
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    # Strip any trailing slash from the destination.
+    dest=`$echo "X$dest" | $Xsed -e 's%/$%%'`
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      destdir=`$echo "X$dest" | $Xsed -e 's%/[^/]*$%%'`
+      test "X$destdir" = "X$dest" && destdir=.
+      destname=`$echo "X$dest" | $Xsed -e 's%^.*/%%'`
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files
+      if test "$#" -gt 2; then
+	$echo "$modename: \`$dest' is not a directory" 1>&2
+	$echo "$help" 1>&2
+	exit $EXIT_FAILURE
+      fi
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  $echo "$modename: \`$destdir' must be an absolute directory name" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	if (${SED} -e '2q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then :
+	else
+	  $echo "$modename: \`$file' is not a valid libtool archive" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	library_names=
+	old_library=
+	relink_command=
+	# If there is no directory component, then add one.
+	case $file in
+	*/* | *\\*) . $file ;;
+	*) . ./$file ;;
+	esac
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	dir=`$echo "X$file" | $Xsed -e 's%/[^/]*$%%'`/
+	test "X$dir" = "X$file/" && dir=
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$echo "$destdir" | $SED "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  if test "$inst_prefix_dir" = "$destdir"; then
+	    $echo "$modename: error: cannot install \`$file' to a directory not ending in $libdir" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$echo "$relink_command" | $SED "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$echo "$relink_command" | $SED "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  $echo "$modename: warning: relinking \`$file'" 1>&2
+	  $show "$relink_command"
+	  if $run eval "$relink_command"; then :
+	  else
+	    $echo "$modename: error: relink \`$file' with the above command before installing it" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names
+	if test -n "$2"; then
+	  realname="$2"
+	  shift
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  $show "$install_prog $dir/$srcname $destdir/$realname"
+	  $run eval "$install_prog $dir/$srcname $destdir/$realname" || exit $?
+	  if test -n "$stripme" && test -n "$striplib"; then
+	    $show "$striplib $destdir/$realname"
+	    $run eval "$striplib $destdir/$realname" || exit $?
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      if test "$linkname" != "$realname"; then
+                $show "(cd $destdir && { $LN_S -f $realname $linkname || { $rm $linkname && $LN_S $realname $linkname; }; })"
+                $run eval "(cd $destdir && { $LN_S -f $realname $linkname || { $rm $linkname && $LN_S $realname $linkname; }; })"
+	      fi
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  cmds=$postinstall_cmds
+	  save_ifs="$IFS"; IFS='~'
+	  for cmd in $cmds; do
+	    IFS="$save_ifs"
+	    eval cmd=\"$cmd\"
+	    $show "$cmd"
+	    $run eval "$cmd" || {
+	      lt_exit=$?
+
+	      # Restore the uninstalled library and exit
+	      if test "$mode" = relink; then
+		$run eval '(cd $output_objdir && $rm ${realname}T && $mv ${realname}U $realname)'
+	      fi
+
+	      exit $lt_exit
+	    }
+	  done
+	  IFS="$save_ifs"
+	fi
+
+	# Install the pseudo-library for information purposes.
+	name=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
+	instname="$dir/$name"i
+	$show "$install_prog $instname $destdir/$name"
+	$run eval "$install_prog $instname $destdir/$name" || exit $?
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  destfile=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  staticdest=`$echo "X$destfile" | $Xsed -e "$lo2o"`
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  $echo "$modename: cannot copy a libtool object to \`$destfile'" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	if test -n "$destfile"; then
+	  $show "$install_prog $file $destfile"
+	  $run eval "$install_prog $file $destfile" || exit $?
+	fi
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  staticobj=`$echo "X$file" | $Xsed -e "$lo2o"`
+
+	  $show "$install_prog $staticobj $staticdest"
+	  $run eval "$install_prog \$staticobj \$staticdest" || exit $?
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  destfile=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      file=`$echo $file|${SED} 's,.exe$,,'`
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin*|*mingw*)
+	    wrapper=`$echo $file | ${SED} -e 's,.exe$,,'`
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if (${SED} -e '4q' $wrapper | grep "^# Generated by .*$PACKAGE")>/dev/null 2>&1; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  # Note that it is not necessary on cygwin/mingw to append a dot to
+	  # foo even if both foo and FILE.exe exist: automatic-append-.exe
+	  # behavior happens only for exec(3), not for open(2)!  Also, sourcing
+	  # `FILE.' does not work on cygwin managed mounts.
+	  #
+	  # If there is no directory component, then add one.
+	  case $wrapper in
+	  */* | *\\*) . ${wrapper} ;;
+	  *) . ./${wrapper} ;;
+	  esac
+
+	  # Check the variables that should have been set.
+	  if test -z "$notinst_deplibs"; then
+	    $echo "$modename: invalid libtool wrapper script \`$wrapper'" 1>&2
+	    exit $EXIT_FAILURE
+	  fi
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      # If there is no directory component, then add one.
+	      case $lib in
+	      */* | *\\*) . $lib ;;
+	      *) . ./$lib ;;
+	      esac
+	    fi
+	    libfile="$libdir/"`$echo "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      $echo "$modename: warning: \`$lib' has not been installed in \`$libdir'" 1>&2
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  # Note that it is not necessary on cygwin/mingw to append a dot to
+	  # foo even if both foo and FILE.exe exist: automatic-append-.exe
+	  # behavior happens only for exec(3), not for open(2)!  Also, sourcing
+	  # `FILE.' does not work on cygwin managed mounts.
+	  #
+	  # If there is no directory component, then add one.
+	  case $wrapper in
+	  */* | *\\*) . ${wrapper} ;;
+	  *) . ./${wrapper} ;;
+	  esac
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    if test "$finalize" = yes && test -z "$run"; then
+	      tmpdir=`func_mktempdir`
+	      file=`$echo "X$file$stripped_ext" | $Xsed -e 's%^.*/%%'`
+	      outputname="$tmpdir/$file"
+	      # Replace the output file specification.
+	      relink_command=`$echo "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	      $show "$relink_command"
+	      if $run eval "$relink_command"; then :
+	      else
+		$echo "$modename: error: relink \`$file' with the above command before installing it" 1>&2
+		${rm}r "$tmpdir"
+		continue
+	      fi
+	      file="$outputname"
+	    else
+	      $echo "$modename: warning: cannot relink \`$file'" 1>&2
+	    fi
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$echo "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway 
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    destfile=`$echo $destfile | ${SED} -e 's,.exe$,,'`
+	    ;;
+	  esac
+	  ;;
+	esac
+	$show "$install_prog$stripme $file $destfile"
+	$run eval "$install_prog\$stripme \$file \$destfile" || exit $?
+	test -n "$outputname" && ${rm}r "$tmpdir"
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      name=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      $show "$install_prog $file $oldlib"
+      $run eval "$install_prog \$file \$oldlib" || exit $?
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	$show "$old_striplib $oldlib"
+	$run eval "$old_striplib $oldlib" || exit $?
+      fi
+
+      # Do each command in the postinstall commands.
+      cmds=$old_postinstall_cmds
+      save_ifs="$IFS"; IFS='~'
+      for cmd in $cmds; do
+	IFS="$save_ifs"
+	eval cmd=\"$cmd\"
+	$show "$cmd"
+	$run eval "$cmd" || exit $?
+      done
+      IFS="$save_ifs"
+    done
+
+    if test -n "$future_libdirs"; then
+      $echo "$modename: warning: remember to run \`$progname --finish$future_libdirs'" 1>&2
+    fi
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      test -n "$run" && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+    ;;
+
+  # libtool finish mode
+  finish)
+    modename="$modename: finish"
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  cmds=$finish_cmds
+	  save_ifs="$IFS"; IFS='~'
+	  for cmd in $cmds; do
+	    IFS="$save_ifs"
+	    eval cmd=\"$cmd\"
+	    $show "$cmd"
+	    $run eval "$cmd" || admincmds="$admincmds
+       $cmd"
+	  done
+	  IFS="$save_ifs"
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $run eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    test "$show" = : && exit $EXIT_SUCCESS
+
+    $echo "X----------------------------------------------------------------------" | $Xsed
+    $echo "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $echo "   $libdir"
+    done
+    $echo
+    $echo "If you ever happen to want to link against installed libraries"
+    $echo "in a given directory, LIBDIR, you must either use libtool, and"
+    $echo "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $echo "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $echo "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $echo "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $echo "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $echo "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $echo "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $echo "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $echo "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $echo
+    $echo "See any operating system documentation about shared libraries for"
+    $echo "more information, such as the ld(1) and ld.so(8) manual pages."
+    $echo "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+    ;;
+
+  # libtool execute mode
+  execute)
+    modename="$modename: execute"
+
+    # The first argument is the command name.
+    cmd="$nonopt"
+    if test -z "$cmd"; then
+      $echo "$modename: you must specify a COMMAND" 1>&2
+      $echo "$help"
+      exit $EXIT_FAILURE
+    fi
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      if test ! -f "$file"; then
+	$echo "$modename: \`$file' is not a file" 1>&2
+	$echo "$help" 1>&2
+	exit $EXIT_FAILURE
+      fi
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	if (${SED} -e '2q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then :
+	else
+	  $echo "$modename: \`$lib' is not a valid libtool archive" 1>&2
+	  $echo "$help" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+
+	# If there is no directory component, then add one.
+	case $file in
+	*/* | *\\*) . $file ;;
+	*) . ./$file ;;
+	esac
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && $echo "$modename: warning: \`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	dir=`$echo "X$file" | $Xsed -e 's%/[^/]*$%%'`
+	test "X$dir" = "X$file" && dir=.
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  $echo "$modename: cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'" 1>&2
+	  exit $EXIT_FAILURE
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	dir=`$echo "X$file" | $Xsed -e 's%/[^/]*$%%'`
+	test "X$dir" = "X$file" && dir=.
+	;;
+
+      *)
+	$echo "$modename: warning \`-dlopen' is ignored for non-libtool libraries and objects" 1>&2
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if (${SED} -e '4q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	  # If there is no directory component, then add one.
+	  case $file in
+	  */* | *\\*) . $file ;;
+	  *) . ./$file ;;
+	  esac
+
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      file=`$echo "X$file" | $Xsed -e "$sed_quote_subst"`
+      args="$args \"$file\""
+    done
+
+    if test -z "$run"; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      if test "${save_LC_ALL+set}" = set; then
+	LC_ALL="$save_LC_ALL"; export LC_ALL
+      fi
+      if test "${save_LANG+set}" = set; then
+	LANG="$save_LANG"; export LANG
+      fi
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$echo \"\$shlibpath_var=\$$shlibpath_var\""
+	$echo "export $shlibpath_var"
+      fi
+      $echo "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+    ;;
+
+  # libtool clean and uninstall mode
+  clean | uninstall)
+    modename="$modename: $mode"
+    rm="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) rm="$rm $arg"; rmforce=yes ;;
+      -*) rm="$rm $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    if test -z "$rm"; then
+      $echo "$modename: you must specify an RM program" 1>&2
+      $echo "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      dir=`$echo "X$file" | $Xsed -e 's%/[^/]*$%%'`
+      if test "X$dir" = "X$file"; then
+	dir=.
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      name=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if (test -L "$file") >/dev/null 2>&1 \
+	|| (test -h "$file") >/dev/null 2>&1 \
+	|| test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if (${SED} -e '2q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	  . $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	     test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      cmds=$postuninstall_cmds
+	      save_ifs="$IFS"; IFS='~'
+	      for cmd in $cmds; do
+		IFS="$save_ifs"
+		eval cmd=\"$cmd\"
+		$show "$cmd"
+		$run eval "$cmd"
+		if test "$?" -ne 0 && test "$rmforce" != yes; then
+		  exit_status=1
+		fi
+	      done
+	      IFS="$save_ifs"
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      cmds=$old_postuninstall_cmds
+	      save_ifs="$IFS"; IFS='~'
+	      for cmd in $cmds; do
+		IFS="$save_ifs"
+		eval cmd=\"$cmd\"
+		$show "$cmd"
+		$run eval "$cmd"
+		if test "$?" -ne 0 && test "$rmforce" != yes; then
+		  exit_status=1
+		fi
+	      done
+	      IFS="$save_ifs"
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if (${SED} -e '2q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+
+	  # Read the .lo file
+	  . $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" \
+	     && test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" \
+	     && test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    file=`$echo $file|${SED} 's,.exe$,,'`
+	    noexename=`$echo $name|${SED} 's,.exe$,,'`
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if (${SED} -e '4q' $file | grep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	    relink_command=
+	    . $dir/$noexename
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      $show "$rm $rmfiles"
+      $run $rm $rmfiles || exit_status=1
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	$show "rmdir $dir"
+	$run rmdir $dir >/dev/null 2>&1
+      fi
+    done
+
+    exit $exit_status
+    ;;
+
+  "")
+    $echo "$modename: you must specify a MODE" 1>&2
+    $echo "$generic_help" 1>&2
+    exit $EXIT_FAILURE
+    ;;
+  esac
+
+  if test -z "$exec_cmd"; then
+    $echo "$modename: invalid operation mode \`$mode'" 1>&2
+    $echo "$generic_help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+fi # test -z "$show_help"
+
+if test -n "$exec_cmd"; then
+  eval exec $exec_cmd
+  exit $EXIT_FAILURE
+fi
+
+# We need to display help for each of the modes.
+case $mode in
+"") $echo \
+"Usage: $modename [OPTION]... [MODE-ARG]...
+
+Provide generalized library-building support services.
+
+    --config          show all configuration variables
+    --debug           enable verbose shell tracing
+-n, --dry-run         display commands without modifying any files
+    --features        display basic configuration information and exit
+    --finish          same as \`--mode=finish'
+    --help            display this help message and exit
+    --mode=MODE       use operation mode MODE [default=inferred from MODE-ARGS]
+    --quiet           same as \`--silent'
+    --silent          don't print informational messages
+    --tag=TAG         use configuration variables from tag TAG
+    --version         print version information
+
+MODE must be one of the following:
+
+      clean           remove files from the build directory
+      compile         compile a source file into a libtool object
+      execute         automatically set library path, then run a program
+      finish          complete the installation of libtool libraries
+      install         install libraries or executables
+      link            create a library or an executable
+      uninstall       remove libraries from an installed directory
+
+MODE-ARGS vary depending on the MODE.  Try \`$modename --help --mode=MODE' for
+a more detailed description of MODE.
+
+Report bugs to <bug-libtool@gnu.org>."
+  exit $EXIT_SUCCESS
+  ;;
+
+clean)
+  $echo \
+"Usage: $modename [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+  ;;
+
+compile)
+  $echo \
+"Usage: $modename [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -static           always build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+  ;;
+
+execute)
+  $echo \
+"Usage: $modename [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+  ;;
+
+finish)
+  $echo \
+"Usage: $modename [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+  ;;
+
+install)
+  $echo \
+"Usage: $modename [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+  ;;
+
+link)
+  $echo \
+"Usage: $modename [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+		    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+		    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -static           do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+		    specify library version info [each variable defaults to 0]
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+  ;;
+
+uninstall)
+  $echo \
+"Usage: $modename [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+  ;;
+
+*)
+  $echo "$modename: invalid operation mode \`$mode'" 1>&2
+  $echo "$help" 1>&2
+  exit $EXIT_FAILURE
+  ;;
+esac
+
+$echo
+$echo "Try \`$modename --help' for more information about other modes."
+
+exit $?
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+disable_libs=shared
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+disable_libs=static
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# ### BEGIN LIBTOOL TAG CONFIG: CXX
+
+# Libtool was configured on host LAPTOP-8NENSNNN:
+
+# Shell to use when invoking shell scripts.
+SHELL="/bin/sh"
+
+# Whether or not to build shared libraries.
+build_libtool_libs=yes
+
+# Whether or not to build static libraries.
+build_old_libs=yes
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=no
+
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=yes
+
+# Whether or not to optimize for fast installation.
+fast_install=needless
+
+# The host system.
+host_alias=
+host=i686-pc-mingw32
+host_os=mingw32
+
+# The build system.
+build_alias=
+build=i686-pc-mingw32
+build_os=mingw32
+
+# An echo program that does not interpret backslashes.
+echo="echo"
+
+# The archiver.
+AR="ar"
+AR_FLAGS="cru"
+
+# A C compiler.
+LTCC="gcc"
+
+# LTCC compiler flags.
+LTCFLAGS="-g -O2 -I./include -D_GNU_SOURCE=1"
+
+# A language-specific compiler.
+CC="g++"
+
+# Is the compiler the GNU C compiler?
+with_gcc=yes
+
+# An ERE matcher.
+EGREP="/bin/grep -E"
+
+# The linker used to build libraries.
+LD="c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/x86_64-w64-mingw32/bin/ld.exe"
+
+# Whether we need hard or soft links.
+LN_S="ln -s"
+
+# A BSD-compatible nm program.
+NM="/mingw/bin/nm"
+
+# A symbol stripping program
+STRIP="strip"
+
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=file
+
+# Used on cygwin: DLL creation program.
+DLLTOOL="dlltool"
+
+# Used on cygwin: object dumper.
+OBJDUMP="objdump"
+
+# Used on cygwin: assembler.
+AS="as"
+
+# The name of the directory that contains temporary libtool files.
+objdir=.libs
+
+# How to create reloadable object files.
+reload_flag=" -r"
+reload_cmds="\$LD\$reload_flag -o \$output\$reload_objs"
+
+# How to pass a linker flag through the compiler.
+wl="-Wl,"
+
+# Object file suffix (normally "o").
+objext="o"
+
+# Old archive suffix (normally "a").
+libext="a"
+
+# Shared library suffix (normally ".so").
+shrext_cmds='.dll'
+
+# Executable file suffix (normally "").
+exeext=""
+
+# Additional compiler flags for building library objects.
+pic_flag=" -DDLL_EXPORT -DPIC"
+pic_mode=default
+
+# What is the maximum length of a command?
+max_cmd_len=8192
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o="yes"
+
+# Must we lock files when doing compilation?
+need_locks="no"
+
+# Do we need the lib prefix for modules?
+need_lib_prefix=no
+
+# Do we need a version for libraries?
+need_version=no
+
+# Whether dlopen is supported.
+dlopen_support=unknown
+
+# Whether dlopen of programs is supported.
+dlopen_self=unknown
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=unknown
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag="-static"
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=" -fno-builtin"
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec="\${wl}--export-dynamic"
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec="\${wl}--whole-archive\$convenience \${wl}--no-whole-archive"
+
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=""
+
+# Library versioning type.
+version_type=windows
+
+# Format of library name prefix.
+libname_spec="lib\$name"
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec="\$libname.dll.a"
+
+# The coded name of the library, if different from the real name.
+soname_spec="\`echo \${libname} | sed -e s/^lib//\`\${shared_ext}"
+
+# Commands used to build and install an old-style archive.
+RANLIB="ranlib"
+old_archive_cmds="\$AR \$AR_FLAGS \$oldlib\$oldobjs\$old_deplibs~\$RANLIB \$oldlib"
+old_postinstall_cmds="chmod 644 \$oldlib~\$RANLIB \$oldlib"
+old_postuninstall_cmds=""
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=""
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=""
+
+# Commands used to build and install a shared archive.
+archive_cmds="\$CC -shared -nostdlib \$predep_objects \$libobjs \$deplibs \$postdep_objects \$compiler_flags -o \$output_objdir/\$soname \${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker \$lib"
+archive_expsym_cmds="if test \\\"x\\\`\$SED 1q \$export_symbols\\\`\\\" = xEXPORTS; then
+	cp \$export_symbols \$output_objdir/\$soname.def;
+      else
+	echo EXPORTS > \$output_objdir/\$soname.def;
+	cat \$export_symbols >> \$output_objdir/\$soname.def;
+      fi~
+      \$CC -shared -nostdlib \$output_objdir/\$soname.def \$predep_objects \$libobjs \$deplibs \$postdep_objects \$compiler_flags -o \$output_objdir/\$soname \${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker \$lib"
+postinstall_cmds="base_file=\\\`basename \\\${file}\\\`~
+      dlpath=\\\`\$SHELL 2>&1 -c '. \$dir/'\\\${base_file}'i;echo \\\$dlname'\\\`~
+      dldir=\$destdir/\\\`dirname \\\$dlpath\\\`~
+      test -d \\\$dldir || mkdir -p \\\$dldir~
+      \$install_prog \$dir/\$dlname \\\$dldir/\$dlname~
+      chmod a+x \\\$dldir/\$dlname"
+postuninstall_cmds="dldll=\\\`\$SHELL 2>&1 -c '. \$file; echo \\\$dlname'\\\`~
+      dlpath=\$dir/\\\$dldll~
+       \$rm \\\$dlpath"
+
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=""
+module_expsym_cmds=""
+
+# Commands to strip libraries.
+old_striplib="strip --strip-debug"
+striplib="strip --strip-unneeded"
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects="c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib/dllcrt2.o c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib/crtbegin.o"
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects="c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib/crtend.o"
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=""
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps="-lstdc++ -lmingw32 -lgcc -lmoldname -lmingwex -lmsvcrt -lpthread -ladvapi32 -lshell32 -luser32 -lkernel32 -lmingw32 -lgcc -lmoldname -lmingwex -lmsvcrt"
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path="-Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1 -Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc -Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib -Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../lib -Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib -Lc:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../.."
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method="pass_all"
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd="\$OBJDUMP -f"
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag="unsupported"
+
+# Flag that forces no undefined symbols.
+no_undefined_flag=""
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=""
+
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=""
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe="sed -n -e 's/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)
+\\{0,1\\}\$/\\1 \\2 \\2/p'"
+
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl="sed -n -e 's/^. .* \\(.*\\)\$/extern int \\1;/p'"
+
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address="sed -n -e 's/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p' -e 's/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'"
+
+# This is the shared library runtime path variable.
+runpath_var=LD_RUN_PATH
+
+# This is the shared library path variable.
+shlibpath_var=PATH
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=yes
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=immediate
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=no
+
+# Flag to hardcode $libdir into a binary during linking.
+# This must work even if $libdir does not exist.
+hardcode_libdir_flag_spec="-L\$libdir"
+
+# If ld is used when linking, flag to hardcode $libdir into
+# a binary during linking. This must work even if $libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=""
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=""
+
+# Set to yes if using DIR/libNAME during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=no
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=no
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=unsupported
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=no
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="PATH PATH LD_RUN_PATH GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=unknown
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=" =c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/../lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../x86_64-w64-mingw32/4.7.1/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../../x86_64-w64-mingw32/lib/ c:/DevelopmentEnvironment/gcc/msys_x2/1.0/mingw/bin/../lib/gcc/x86_64-w64-mingw32/4.7.1/../../../"
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+
+# Fix the shell variable $srcfile for the compiler.
+fix_srcfile_path=""
+
+# Set to yes if exported symbols are required.
+always_export_symbols=no
+
+# The commands to list exported symbols.
+export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED -e '/^[BCDGRS] /s/.* \\\\([^ ]*\\\\)/\\\\1 DATA/;/^.* __nm__/s/^.* __nm__\\\\([^ ]*\\\\) [^ ]*/\\\\1 DATA/;/^I /d;/^[AITW] /s/.* //' | sort | uniq > \$export_symbols"
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=""
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=""
+
+# Symbols that must always be exported.
+include_expsyms=""
+
+# ### END LIBTOOL TAG CONFIG: CXX
+
diff -ruN SDL-1.2.13/sdl-config SDL-1.2.13_OOx64/sdl-config
--- SDL-1.2.13/sdl-config	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/sdl-config	2013-10-03 18:42:34 +0000
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+prefix=/mingw/../devlibs
+exec_prefix=${prefix}
+exec_prefix_set=no
+libdir=${exec_prefix}/lib
+
+#usage="\
+#Usage: sdl-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--cflags] [--libs]"
+usage="\
+Usage: sdl-config [--prefix[=DIR]] [--exec-prefix[=DIR]] [--version] [--cflags] [--libs] [--static-libs]"
+
+if test $# -eq 0; then
+      echo "${usage}" 1>&2
+      exit 1
+fi
+
+while test $# -gt 0; do
+  case "$1" in
+  -*=*) optarg=`echo "$1" | LC_ALL="C" sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) optarg= ;;
+  esac
+
+  case $1 in
+    --prefix=*)
+      prefix=$optarg
+      if test $exec_prefix_set = no ; then
+        exec_prefix=$optarg
+      fi
+      ;;
+    --prefix)
+      echo $prefix
+      ;;
+    --exec-prefix=*)
+      exec_prefix=$optarg
+      exec_prefix_set=yes
+      ;;
+    --exec-prefix)
+      echo $exec_prefix
+      ;;
+    --version)
+      echo 1.2.13
+      ;;
+    --cflags)
+      echo -I${prefix}/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main
+      ;;
+    --libs)
+      echo -L${exec_prefix}/lib  -lmingw32 -lSDLmain -lSDL  -mwindows
+      ;;
+    --static-libs)
+#    --libs|--static-libs)
+      echo -L${exec_prefix}/lib  -lmingw32 -lSDLmain -lSDL  -mwindows
+      ;;
+    *)
+      echo "${usage}" 1>&2
+      exit 1
+      ;;
+  esac
+  shift
+done
diff -ruN SDL-1.2.13/sdl.pc SDL-1.2.13_OOx64/sdl.pc
--- SDL-1.2.13/sdl.pc	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/sdl.pc	2013-10-03 18:42:36 +0000
@@ -0,0 +1,14 @@
+# sdl pkg-config source file
+
+prefix=/mingw/../devlibs
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+includedir=${prefix}/include
+
+Name: sdl
+Description: Simple DirectMedia Layer is a cross-platform multimedia library designed to provide low level access to audio, keyboard, mouse, joystick, 3D hardware via OpenGL, and 2D video framebuffer.
+Version: 1.2.13
+Requires:
+Conflicts:
+Libs: -L${libdir}  -lmingw32 -lSDLmain -lSDL  -mwindows
+Cflags: -I${includedir}/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main
diff -ruN SDL-1.2.13/src/SDL.c SDL-1.2.13_OOx64/src/SDL.c
--- SDL-1.2.13/src/SDL.c	2007-12-31 04:48:16 +0000
+++ SDL-1.2.13_OOx64/src/SDL.c	2017-12-19 14:03:10 +0000
@@ -38,6 +38,10 @@
 extern int  SDL_JoystickInit(void);
 extern void SDL_JoystickQuit(void);
 #endif
+#if !SDL_HAPTIC_DISABLED
+extern int SDL_HapticInit(void);
+extern int SDL_HapticQuit(void);
+#endif
 #if !SDL_CDROM_DISABLED
 extern int  SDL_CDROMInit(void);
 extern void SDL_CDROMQuit(void);
@@ -47,6 +51,10 @@
 extern int  SDL_TimerInit(void);
 extern void SDL_TimerQuit(void);
 #endif
+#if defined(__WIN32__)
+extern int SDL_HelperWindowCreate(void);
+extern int SDL_HelperWindowDestroy(void);
+#endif
 
 /* The current SDL version */
 static SDL_version version = 
@@ -130,6 +138,22 @@
 	}
 #endif
 
+#if !SDL_HAPTIC_DISABLED
+    /* Initialize the haptic subsystem */
+    if ((flags & SDL_INIT_HAPTIC) && !(SDL_initialized & SDL_INIT_HAPTIC)) {
+        if (SDL_HapticInit() < 0) {
+            return (-1);
+        }
+        SDL_initialized |= SDL_INIT_HAPTIC;
+    }
+#else
+    if (flags & SDL_INIT_HAPTIC) {
+        SDL_SetError("SDL not built with haptic (force feedback) support");
+        return (-1);
+    }
+#endif
+
+
 #if !SDL_CDROM_DISABLED
 	/* Initialize the CD-ROM subsystem */
 	if ( (flags & SDL_INIT_CDROM) && !(SDL_initialized & SDL_INIT_CDROM) ) {
@@ -158,6 +182,12 @@
 	/* Clear the error message */
 	SDL_ClearError();
 
+#if defined(__WIN32__)
+	if (SDL_HelperWindowCreate() < 0) {
+		return -1;
+	}
+#endif
+
 	/* Initialize the desired subsystems */
 	if ( SDL_InitSubSystem(flags) < 0 ) {
 		return(-1);
@@ -185,6 +215,12 @@
 		SDL_initialized &= ~SDL_INIT_JOYSTICK;
 	}
 #endif
+#if !SDL_HAPTIC_DISABLED
+    if ((flags & SDL_initialized & SDL_INIT_HAPTIC)) {
+        SDL_HapticQuit();
+        SDL_initialized &= ~SDL_INIT_HAPTIC;
+    }
+#endif
 #if !SDL_TIMERS_DISABLED
 	if ( (flags & SDL_initialized & SDL_INIT_TIMER) ) {
 		SDL_TimerQuit();
@@ -219,6 +255,11 @@
 #ifdef DEBUG_BUILD
   printf("[SDL_Quit] : Enter! Calling QuitSubSystem()\n"); fflush(stdout);
 #endif
+
+#if defined(__WIN32__)
+	SDL_HelperWindowDestroy();
+#endif
+
 	SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
 
 #ifdef CHECK_LEAKS
diff -ruN SDL-1.2.13/src/SDL.c.bak SDL-1.2.13_OOx64/src/SDL.c.bak
--- SDL-1.2.13/src/SDL.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/SDL.c.bak	2007-12-30 18:48:16 +0000
@@ -0,0 +1,350 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Initialization code for SDL */
+
+#include "SDL.h"
+#include "SDL_fatal.h"
+#if !SDL_VIDEO_DISABLED
+#include "video/SDL_leaks.h"
+#endif
+
+#if SDL_THREAD_PTH
+#include <pth.h>
+#endif
+
+/* Initialization/Cleanup routines */
+#if !SDL_JOYSTICK_DISABLED
+extern int  SDL_JoystickInit(void);
+extern void SDL_JoystickQuit(void);
+#endif
+#if !SDL_CDROM_DISABLED
+extern int  SDL_CDROMInit(void);
+extern void SDL_CDROMQuit(void);
+#endif
+#if !SDL_TIMERS_DISABLED
+extern void SDL_StartTicks(void);
+extern int  SDL_TimerInit(void);
+extern void SDL_TimerQuit(void);
+#endif
+
+/* The current SDL version */
+static SDL_version version = 
+	{ SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL };
+
+/* The initialized subsystems */
+static Uint32 SDL_initialized = 0;
+#if !SDL_TIMERS_DISABLED
+static Uint32 ticks_started = 0;
+#endif
+
+#ifdef CHECK_LEAKS
+int surfaces_allocated = 0;
+#endif
+
+int SDL_InitSubSystem(Uint32 flags)
+{
+#if !SDL_VIDEO_DISABLED
+	/* Initialize the video/event subsystem */
+	if ( (flags & SDL_INIT_VIDEO) && !(SDL_initialized & SDL_INIT_VIDEO) ) {
+		if ( SDL_VideoInit(SDL_getenv("SDL_VIDEODRIVER"),
+		                   (flags&SDL_INIT_EVENTTHREAD)) < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_VIDEO;
+	}
+#else
+	if ( flags & SDL_INIT_VIDEO ) {
+		SDL_SetError("SDL not built with video support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_AUDIO_DISABLED
+	/* Initialize the audio subsystem */
+	if ( (flags & SDL_INIT_AUDIO) && !(SDL_initialized & SDL_INIT_AUDIO) ) {
+		if ( SDL_AudioInit(SDL_getenv("SDL_AUDIODRIVER")) < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_AUDIO;
+	}
+#else
+	if ( flags & SDL_INIT_AUDIO ) {
+		SDL_SetError("SDL not built with audio support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_TIMERS_DISABLED
+	/* Initialize the timer subsystem */
+	if ( ! ticks_started ) {
+		SDL_StartTicks();
+		ticks_started = 1;
+	}
+	if ( (flags & SDL_INIT_TIMER) && !(SDL_initialized & SDL_INIT_TIMER) ) {
+		if ( SDL_TimerInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_TIMER;
+	}
+#else
+	if ( flags & SDL_INIT_TIMER ) {
+		SDL_SetError("SDL not built with timer support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_JOYSTICK_DISABLED
+	/* Initialize the joystick subsystem */
+	if ( (flags & SDL_INIT_JOYSTICK) &&
+	     !(SDL_initialized & SDL_INIT_JOYSTICK) ) {
+		if ( SDL_JoystickInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_JOYSTICK;
+	}
+#else
+	if ( flags & SDL_INIT_JOYSTICK ) {
+		SDL_SetError("SDL not built with joystick support");
+		return(-1);
+	}
+#endif
+
+#if !SDL_CDROM_DISABLED
+	/* Initialize the CD-ROM subsystem */
+	if ( (flags & SDL_INIT_CDROM) && !(SDL_initialized & SDL_INIT_CDROM) ) {
+		if ( SDL_CDROMInit() < 0 ) {
+			return(-1);
+		}
+		SDL_initialized |= SDL_INIT_CDROM;
+	}
+#else
+	if ( flags & SDL_INIT_CDROM ) {
+		SDL_SetError("SDL not built with cdrom support");
+		return(-1);
+	}
+#endif
+	return(0);
+}
+
+int SDL_Init(Uint32 flags)
+{
+#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
+	if (!pth_init()) {
+		return -1;
+	}
+#endif
+
+	/* Clear the error message */
+	SDL_ClearError();
+
+	/* Initialize the desired subsystems */
+	if ( SDL_InitSubSystem(flags) < 0 ) {
+		return(-1);
+	}
+
+	/* Everything is initialized */
+	if ( !(flags & SDL_INIT_NOPARACHUTE) ) {
+		SDL_InstallParachute();
+	}
+	return(0);
+}
+
+void SDL_QuitSubSystem(Uint32 flags)
+{
+	/* Shut down requested initialized subsystems */
+#if !SDL_CDROM_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_CDROM) ) {
+		SDL_CDROMQuit();
+		SDL_initialized &= ~SDL_INIT_CDROM;
+	}
+#endif
+#if !SDL_JOYSTICK_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_JOYSTICK) ) {
+		SDL_JoystickQuit();
+		SDL_initialized &= ~SDL_INIT_JOYSTICK;
+	}
+#endif
+#if !SDL_TIMERS_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_TIMER) ) {
+		SDL_TimerQuit();
+		SDL_initialized &= ~SDL_INIT_TIMER;
+	}
+#endif
+#if !SDL_AUDIO_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_AUDIO) ) {
+		SDL_AudioQuit();
+		SDL_initialized &= ~SDL_INIT_AUDIO;
+	}
+#endif
+#if !SDL_VIDEO_DISABLED
+	if ( (flags & SDL_initialized & SDL_INIT_VIDEO) ) {
+		SDL_VideoQuit();
+		SDL_initialized &= ~SDL_INIT_VIDEO;
+	}
+#endif
+}
+
+Uint32 SDL_WasInit(Uint32 flags)
+{
+	if ( ! flags ) {
+		flags = SDL_INIT_EVERYTHING;
+	}
+	return (SDL_initialized&flags);
+}
+
+void SDL_Quit(void)
+{
+	/* Quit all subsystems */
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : Enter! Calling QuitSubSystem()\n"); fflush(stdout);
+#endif
+	SDL_QuitSubSystem(SDL_INIT_EVERYTHING);
+
+#ifdef CHECK_LEAKS
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : CHECK_LEAKS\n"); fflush(stdout);
+#endif
+
+	/* Print the number of surfaces not freed */
+	if ( surfaces_allocated != 0 ) {
+		fprintf(stderr, "SDL Warning: %d SDL surfaces extant\n", 
+							surfaces_allocated);
+	}
+#endif
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : SDL_UninstallParachute()\n"); fflush(stdout);
+#endif
+
+	/* Uninstall any parachute signal handlers */
+	SDL_UninstallParachute();
+
+#if !SDL_THREADS_DISABLED && SDL_THREAD_PTH
+	pth_kill();
+#endif
+#ifdef DEBUG_BUILD
+  printf("[SDL_Quit] : Returning!\n"); fflush(stdout);
+#endif
+
+}
+
+/* Return the library version number */
+const SDL_version * SDL_Linked_Version(void)
+{
+	return(&version);
+}
+
+#if defined(__OS2__)
+/* Building for OS/2 */
+#ifdef __WATCOMC__
+
+#define INCL_DOSERRORS
+#define INCL_DOSEXCEPTIONS
+#include <os2.h>
+
+/* Exception handler to prevent the Audio thread hanging, making a zombie process! */
+ULONG _System SDL_Main_ExceptionHandler(PEXCEPTIONREPORTRECORD pERepRec,
+                                        PEXCEPTIONREGISTRATIONRECORD pERegRec,
+                                        PCONTEXTRECORD pCtxRec,
+                                        PVOID p)
+{
+  if (pERepRec->fHandlerFlags & EH_EXIT_UNWIND)
+    return XCPT_CONTINUE_SEARCH;
+  if (pERepRec->fHandlerFlags & EH_UNWINDING)
+    return XCPT_CONTINUE_SEARCH;
+  if (pERepRec->fHandlerFlags & EH_NESTED_CALL)
+    return XCPT_CONTINUE_SEARCH;
+
+  /* Do cleanup at every fatal exception! */
+  if (((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) == XCPT_FATAL_EXCEPTION) &&
+      (pERepRec->ExceptionNum != XCPT_BREAKPOINT) &&
+      (pERepRec->ExceptionNum != XCPT_SINGLE_STEP)
+     )
+  {
+    if (SDL_initialized & SDL_INIT_AUDIO)
+    {
+      /* This removes the zombie audio thread in case of emergency. */
+#ifdef DEBUG_BUILD
+      printf("[SDL_Main_ExceptionHandler] : Calling SDL_CloseAudio()!\n");
+#endif
+      SDL_CloseAudio();
+    }
+  }
+  return (XCPT_CONTINUE_SEARCH);
+}
+
+
+EXCEPTIONREGISTRATIONRECORD SDL_Main_xcpthand = {0, SDL_Main_ExceptionHandler};
+
+/* The main DLL entry for DLL Initialization and Uninitialization: */
+unsigned _System LibMain(unsigned hmod, unsigned termination)
+{
+  if (termination)
+  {
+#ifdef DEBUG_BUILD
+/*    printf("[SDL DLL Unintialization] : Removing exception handler\n"); */
+#endif
+    DosUnsetExceptionHandler(&SDL_Main_xcpthand);
+    return 1;
+  } else
+  {
+#ifdef DEBUG_BUILD
+    /* Make stdout and stderr unbuffered! */
+    setbuf(stdout, NULL);
+    setbuf(stderr, NULL);
+#endif
+    /* Fire up exception handler */
+#ifdef DEBUG_BUILD
+/*    printf("[SDL DLL Initialization] : Setting exception handler\n"); */
+#endif
+    /* Set exception handler */
+    DosSetExceptionHandler(&SDL_Main_xcpthand);
+
+    return 1;
+  }
+}
+#endif /* __WATCOMC__ */
+
+#elif defined(__WIN32__)  && !defined(__SYMBIAN32__)
+
+#if !defined(HAVE_LIBC) || (defined(__WATCOMC__) && defined(BUILD_DLL))
+/* Need to include DllMain() on Watcom C for some reason.. */
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+BOOL APIENTRY _DllMainCRTStartup( HANDLE hModule, 
+                       DWORD  ul_reason_for_call, 
+                       LPVOID lpReserved )
+{
+	switch (ul_reason_for_call) {
+		case DLL_PROCESS_ATTACH:
+		case DLL_THREAD_ATTACH:
+		case DLL_THREAD_DETACH:
+		case DLL_PROCESS_DETACH:
+			break;
+	}
+	return TRUE;
+}
+#endif /* building DLL with Watcom C */
+
+#endif /* OS/2 elif __WIN32__ */
diff -ruN SDL-1.2.13/src/SDL_HelperWindow.c SDL-1.2.13_OOx64/src/SDL_HelperWindow.c
--- SDL-1.2.13/src/SDL_HelperWindow.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/SDL_HelperWindow.c	2017-12-20 12:22:43 +0000
@@ -0,0 +1,154 @@
+#define UNICODE 1
+#include "SDL_config.h"
+#include <windows.h>
+
+/* Some compilers use a special export keyword */
+#ifndef DECLSPEC
+# if defined(__BEOS__)
+#  if defined(__GNUC__)
+#   define DECLSPEC	__declspec(dllexport)
+#  else
+#   define DECLSPEC	__declspec(export)
+#  endif
+# elif defined(__WIN32__)
+#  ifdef __BORLANDC__
+#   ifdef BUILD_SDL
+#    define DECLSPEC 
+#   else
+#    define DECLSPEC	__declspec(dllimport)
+#   endif
+#  else
+#   define DECLSPEC	__declspec(dllexport)
+#  endif
+# elif defined(__OS2__)
+#  ifdef __WATCOMC__
+#   ifdef BUILD_SDL
+#    define DECLSPEC	__declspec(dllexport)
+#   else
+#    define DECLSPEC
+#   endif
+#  else
+#   define DECLSPEC
+#  endif
+# else
+#  if defined(__GNUC__) && __GNUC__ >= 4
+#   define DECLSPEC	__attribute__ ((visibility("default")))
+#  else
+#   define DECLSPEC
+#  endif
+# endif
+#endif
+
+extern DECLSPEC char * SDL_iconv_string(const char *tocode, const char *fromcode, const char *inbuf, size_t inbytesleft);
+
+#define SDL_arraysize(array)	(sizeof(array)/sizeof(array[0]))
+#define SDL_free	free
+
+/* Routines to convert from UTF8 to native Windows text */
+#if UNICODE
+#define WIN_StringToUTF8(S) SDL_iconv_string("UTF-8", "UTF-16LE", (char *)(S), (wcslen(S)+1)*sizeof(WCHAR))
+#define WIN_UTF8ToString(S) (WCHAR *)SDL_iconv_string("UTF-16LE", "UTF-8", (char *)(S), strlen(S)+1)
+#else
+/* !!! FIXME: UTF8ToString() can just be a SDL_strdup() here. */
+#define WIN_StringToUTF8(S) SDL_iconv_string("UTF-8", "ASCII", (char *)(S), (strlen(S)+1))
+#define WIN_UTF8ToString(S) SDL_iconv_string("ASCII", "UTF-8", (char *)(S), strlen(S)+1)
+#endif
+
+/* Fake window to help with DirectInput events. */
+HWND SDL_HelperWindow = NULL;
+static WCHAR *SDL_HelperWindowClassName = TEXT("SDLHelperWindowInputCatcher");
+static WCHAR *SDL_HelperWindowName = TEXT("SDLHelperWindowInputMsgWindow");
+static ATOM SDL_HelperWindowClass = 0;
+
+/*
+ * Creates a HelperWindow used for DirectInput events.
+ */
+int
+SDL_HelperWindowCreate(void)
+{
+    HINSTANCE hInstance = GetModuleHandle(NULL);
+    WNDCLASS wce;
+
+    /* Make sure window isn't created twice. */
+    if (SDL_HelperWindow != NULL) {
+        return 0;
+    }
+
+    /* Create the class. */
+    memset(&wce, 0, sizeof(wce));
+    wce.lpfnWndProc = DefWindowProc;
+    wce.lpszClassName = (LPCWSTR) SDL_HelperWindowClassName;
+    wce.hInstance = hInstance;
+
+    /* Register the class. */
+    SDL_HelperWindowClass = RegisterClass(&wce);
+    if (SDL_HelperWindowClass == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS) {
+        return WIN_SetError("Unable to create Helper Window Class");
+    }
+
+    /* Create the window. */
+    SDL_HelperWindow = CreateWindowEx(0, SDL_HelperWindowClassName,
+                                      SDL_HelperWindowName,
+                                      WS_OVERLAPPED, CW_USEDEFAULT,
+                                      CW_USEDEFAULT, CW_USEDEFAULT,
+                                      CW_USEDEFAULT, HWND_MESSAGE, NULL,
+                                      hInstance, NULL);
+    if (SDL_HelperWindow == NULL) {
+        UnregisterClass(SDL_HelperWindowClassName, hInstance);
+        return WIN_SetError("Unable to create Helper Window");
+    }
+
+    return 0;
+}
+
+
+/*
+ * Destroys the HelperWindow previously created with SDL_HelperWindowCreate.
+ */
+void
+SDL_HelperWindowDestroy(void)
+{
+    HINSTANCE hInstance = GetModuleHandle(NULL);
+
+    /* Destroy the window. */
+    if (SDL_HelperWindow != NULL) {
+        if (DestroyWindow(SDL_HelperWindow) == 0) {
+            WIN_SetError("Unable to destroy Helper Window");
+            return;
+        }
+        SDL_HelperWindow = NULL;
+    }
+
+    /* Unregister the class. */
+    if (SDL_HelperWindowClass != 0) {
+        if ((UnregisterClass(SDL_HelperWindowClassName, hInstance)) == 0) {
+            WIN_SetError("Unable to destroy Helper Window Class");
+            return;
+        }
+        SDL_HelperWindowClass = 0;
+    }
+}
+
+
+/* Sets an error message based on GetLastError() */
+int
+WIN_SetErrorFromHRESULT(const char *prefix, HRESULT hr)
+{
+    TCHAR buffer[1024];
+    char *message;
+    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0,
+                  buffer, SDL_arraysize(buffer), NULL);
+    message = SDL_iconv_string("UTF-8", "UTF-16LE", (char *)buffer, (wcslen(buffer)+1)*sizeof(WCHAR));
+	//WIN_StringToUTF8(buffer);
+    SDL_SetError("%s%s%s", prefix ? prefix : "", prefix ? ": " : "", message);
+    SDL_free(message);
+    return -1;
+}
+
+
+/* Sets an error message based on GetLastError() */
+int
+WIN_SetError(const char *prefix)
+{
+    return WIN_SetErrorFromHRESULT(prefix, GetLastError());
+}
diff -ruN SDL-1.2.13/src/darwin/SDL_syshaptic.c SDL-1.2.13_OOx64/src/darwin/SDL_syshaptic.c
--- SDL-1.2.13/src/darwin/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/darwin/SDL_syshaptic.c	2017-12-18 15:08:54 +0000
@@ -0,0 +1,1284 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_IOKIT
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/darwin/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <IOKit/IOKitLib.h>
+#include <IOKit/hid/IOHIDKeys.h>
+#include <ForceFeedback/ForceFeedback.h>
+#include <ForceFeedback/ForceFeedbackConstants.h>
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char name[256]; /* Name of the device. */
+
+   io_service_t dev; /* Node we use to create the device. */
+   SDL_Haptic *haptic; /* Haptic currently assosciated with it. */
+   
+   /* Usage pages for determining if it's a mouse or not. */
+   long usage;
+   long usagePage;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   FFDeviceObjectReference device; /* Hardware device. */
+   UInt8 axes[3];
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   FFEffectObjectReference ref; /* Reference. */
+   struct FFEFFECT effect; /* Hardware effect. */
+};
+
+/*
+ * Prototypes.
+ */
+static void SDL_SYS_HapticFreeFFEFFECT(FFEFFECT * effect, int type);
+static int HIDGetDeviceProduct(io_service_t dev, char * name);
+
+
+/* 
+ * Like strerror but for force feedback errors.
+ */
+static const char *
+FFStrError(HRESULT err)
+{
+   switch (err) {
+      case FFERR_DEVICEFULL:
+         return "device full";
+      /* This should be valid, but for some reason isn't defined... */
+      /*case FFERR_DEVICENOTREG:
+         return "device not registered";*/
+      case FFERR_DEVICEPAUSED:
+         return "device paused";
+      case FFERR_DEVICERELEASED:
+         return "device released";
+      case FFERR_EFFECTPLAYING:
+         return "effect playing";
+      case FFERR_EFFECTTYPEMISMATCH:
+         return "effect type mismatch";
+      case FFERR_EFFECTTYPENOTSUPPORTED:
+         return "effect type not supported";
+      case FFERR_GENERIC:
+         return "undetermined error";
+      case FFERR_HASEFFECTS:
+         return "device has effects";
+      case FFERR_INCOMPLETEEFFECT:
+         return "incomplete effect";
+      case FFERR_INTERNAL:
+         return "internal fault";
+      case FFERR_INVALIDDOWNLOADID:
+         return "invalid download id";
+      case FFERR_INVALIDPARAM:
+         return "invalid parameter";
+      case FFERR_MOREDATA:
+         return "more data";
+      case FFERR_NOINTERFACE:
+         return "interface not supported";
+      case FFERR_NOTDOWNLOADED:
+         return "effect is not downloaded";
+      case FFERR_NOTINITIALIZED:
+         return "object has not been initialized";
+      case FFERR_OUTOFMEMORY:
+         return "out of memory";
+      case FFERR_UNPLUGGED:
+         return "device is unplugged";
+      case FFERR_UNSUPPORTED:
+         return "function call unsupported";
+      case FFERR_UNSUPPORTEDAXIS:
+         return "axis unsupported";
+
+      default:
+         return "unknown error";
+   }
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   int numhaptics;
+   IOReturn result;
+   io_iterator_t iter;
+   CFDictionaryRef match;
+   io_service_t device;
+   CFMutableDictionaryRef hidProperties;
+   CFTypeRef refCF;
+
+   /* Clear all the memory. */
+   SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+   /* Get HID devices. */
+   match = IOServiceMatching(kIOHIDDeviceKey);
+   if (match == NULL) {
+      SDL_SetError("Haptic: Failed to get IOServiceMatching.");
+      return -1;
+   }
+
+   /* Now search I/O Registry for matching devices. */
+   result = IOServiceGetMatchingServices(kIOMasterPortDefault, match, &iter);
+   if (result != kIOReturnSuccess) {
+      SDL_SetError("Haptic: Couldn't create a HID object iterator.");
+      return -1;
+   }
+   /* IOServiceGetMatchingServices consumes dictionary. */
+
+   if (!IOIteratorIsValid(iter)) { /* No iterator. */
+      numhaptics = 0;
+      return 0;
+   }
+
+   numhaptics = 0;
+   while ((device = IOIteratorNext(iter)) != IO_OBJECT_NULL) {
+
+      /* Check for force feedback. */
+      if (FFIsForceFeedback(device) == FF_OK) {
+
+         /* Set basic device data. */
+         HIDGetDeviceProduct(device, SDL_hapticlist[numhaptics].name);
+         SDL_hapticlist[numhaptics].dev = device;
+         SDL_hapticlist[numhaptics].haptic = NULL;
+
+         /* Set usage pages. */
+         hidProperties = 0;
+         refCF = 0;
+         result = IORegistryEntryCreateCFProperties(device,
+               &hidProperties, kCFAllocatorDefault, kNilOptions);
+         if ((result == KERN_SUCCESS) && hidProperties) {
+            refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
+            if (refCF) {
+               if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                     &SDL_hapticlist[numhaptics].usagePage))
+                  SDL_SetError("Haptic: Recieving device's usage page.");
+               refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
+               if (refCF) {
+                  if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                        &SDL_hapticlist[numhaptics].usage))
+                     SDL_SetError("Haptic: Recieving device's usage.");
+               }
+            }
+            CFRelease(hidProperties);
+         }
+
+         /* Device has been added. */
+         numhaptics++;
+      }
+      else { /* Free the unused device. */
+         IOObjectRelease(device);
+      }
+
+      /* Reached haptic limit. */
+      if (numhaptics >= MAX_HAPTICS)
+         break;
+   }
+   IOObjectRelease(iter);
+
+   return numhaptics;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   return SDL_hapticlist[index].name;
+}
+
+/*
+ * Gets the device's product name.
+ */
+static int
+HIDGetDeviceProduct(io_service_t dev, char *name)
+{
+   CFMutableDictionaryRef hidProperties, usbProperties;
+   io_registry_entry_t parent1, parent2;
+   kern_return_t ret;
+
+   hidProperties = usbProperties = 0;
+
+   ret = IORegistryEntryCreateCFProperties(dev, &hidProperties,
+                                           kCFAllocatorDefault,
+                                           kNilOptions);
+   if ((ret != KERN_SUCCESS) || !hidProperties) {
+      SDL_SetError("Haptic: Unable to create CFProperties.");
+      return -1;
+   }
+
+   /* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
+    * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
+    */
+   if ((KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(dev, kIOServicePlane, &parent1))
+         && (KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(parent1, kIOServicePlane, &parent2))
+         && (KERN_SUCCESS ==
+            IORegistryEntryCreateCFProperties(parent2, &usbProperties,
+                                              kCFAllocatorDefault,
+                                              kNilOptions))) {
+      if (usbProperties) {
+         CFTypeRef refCF = 0;
+         /* get device info
+          * try hid dictionary first, if fail then go to usb dictionary
+          */
+
+
+         /* Get product name */
+         refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDProductKey));
+         if (!refCF)
+            refCF =
+               CFDictionaryGetValue(usbProperties, CFSTR("USB Product Name"));
+         if (refCF) {
+            if (!CFStringGetCString(refCF, name, 256,
+                                    CFStringGetSystemEncoding())) {
+               SDL_SetError("Haptic: CFStringGetCString error retrieving pDevice->product.");
+               return -1;
+            }
+         }
+
+         CFRelease(usbProperties);
+      }
+      else {
+         SDL_SetError("Haptic: IORegistryEntryCreateCFProperties failed to create usbProperties.");
+         return -1;
+      }
+
+      /* Release stuff. */
+      if (kIOReturnSuccess != IOObjectRelease(parent2)) {
+         SDL_SetError("Haptic: IOObjectRelease error with parent2.");
+      }
+      if (kIOReturnSuccess != IOObjectRelease(parent1))  {
+         SDL_SetError("Haptic: IOObjectRelease error with parent1.");
+      }
+   }
+   else {
+      SDL_SetError("Haptic: Error getting registry entries.");
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#define FF_TEST(ff, s) \
+if (features.supportedEffects & (ff)) supported |= (s)
+/*
+ * Gets supported features.
+ */
+static unsigned int
+GetSupportedFeatures(SDL_Haptic* haptic)
+{
+   HRESULT ret;
+   FFDeviceObjectReference device;
+   FFCAPABILITIES features;
+   unsigned int supported;
+   Uint32 val;
+
+   device = haptic->hwdata->device;
+
+   ret = FFDeviceGetForceFeedbackCapabilities(device, &features);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get device's supported features.");
+      return -1;
+   }
+
+   supported = 0;
+
+   /* Get maximum effects. */
+   haptic->neffects = features.storageCapacity;
+   haptic->nplaying = features.playbackCapacity;
+
+   /* Test for effects. */
+   FF_TEST(FFCAP_ET_CONSTANTFORCE, SDL_HAPTIC_CONSTANT);
+   FF_TEST(FFCAP_ET_RAMPFORCE,     SDL_HAPTIC_RAMP);
+   FF_TEST(FFCAP_ET_SQUARE,        SDL_HAPTIC_SQUARE);
+   FF_TEST(FFCAP_ET_SINE,          SDL_HAPTIC_SINE);
+   FF_TEST(FFCAP_ET_TRIANGLE,      SDL_HAPTIC_TRIANGLE);
+   FF_TEST(FFCAP_ET_SAWTOOTHUP,    SDL_HAPTIC_SAWTOOTHUP);
+   FF_TEST(FFCAP_ET_SAWTOOTHDOWN,  SDL_HAPTIC_SAWTOOTHDOWN);
+   FF_TEST(FFCAP_ET_SPRING,        SDL_HAPTIC_SPRING);
+   FF_TEST(FFCAP_ET_DAMPER,        SDL_HAPTIC_DAMPER);
+   FF_TEST(FFCAP_ET_INERTIA,       SDL_HAPTIC_INERTIA);
+   FF_TEST(FFCAP_ET_FRICTION,      SDL_HAPTIC_FRICTION);
+   FF_TEST(FFCAP_ET_CUSTOMFORCE,   SDL_HAPTIC_CUSTOM);
+
+   /* Check if supports gain. */
+   ret = FFDeviceGetForceFeedbackProperty( device, FFPROP_FFGAIN,
+                                           &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_GAIN;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports gain: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Checks if supports autocenter. */
+   ret = FFDeviceGetForceFeedbackProperty(device, FFPROP_AUTOCENTER,
+                                          &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_AUTOCENTER;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports autocenter: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Check for axes, we have an artificial limit on axes */
+   haptic->naxes = ((features.numFfAxes) > 3) ?
+         3 : features.numFfAxes;
+   /* Actually store the axes we want to use */
+   SDL_memcpy( haptic->hwdata->axes, features.ffAxes, haptic->naxes * sizeof(Uint8));
+
+   /* Always supported features. */
+   supported |= SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+   haptic->supported = supported;
+   return 0;;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromService(SDL_Haptic * haptic, io_service_t service)
+{
+   HRESULT ret;
+   int ret2;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto creat_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+  
+   /* Open the device */
+   ret = FFCreateDevice( service, &haptic->hwdata->device);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create device from service: %s.",
+                   FFStrError(ret));
+      goto creat_err;
+   }
+
+   /* Get supported features. */
+   ret2 = GetSupportedFeatures( haptic );
+   if (haptic->supported < 0) {
+      goto open_err;
+   }
+
+
+   /* Reset and then enable actuators. */
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_RESET );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to reset device: %s.", FFStrError(ret));
+      goto open_err;
+   }
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_SETACTUATORSON  );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to enable actuators: %s.", FFStrError(ret));
+      goto open_err;
+   }
+
+
+   /* Allocate effects memory. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+   
+   return 0;
+   
+   /* Error handling */
+open_err:
+   FFReleaseDevice(haptic->hwdata->device);
+creat_err:
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;                                              
+   }
+   return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                SDL_hapticlist[haptic->index].dev);
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+      if ((SDL_hapticlist[i].usagePage == kHIDPage_GenericDesktop) &&
+            (SDL_hapticlist[i].usage == kHIDUsage_GD_Mouse))
+         return i;
+   }
+
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   if (joystick->hwdata->ffservice != 0)
+      return SDL_TRUE;
+   return SDL_FALSE;
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   if (IOObjectIsEqualTo((io_object_t) haptic->hwdata->device,
+                                       joystick->hwdata->ffservice))
+      return 1;
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                joystick->hwdata->ffservice);
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free Effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      FFReleaseDevice(haptic->hwdata->device);
+
+      /* Free */
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; i < SDL_numhaptics; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      /* Free the io_service_t */
+      IOObjectRelease(SDL_hapticlist[i].dev);
+   }
+}
+
+
+/*
+ * Converts an SDL trigger button to an FFEFFECT trigger button.
+ */
+static DWORD
+FFGetTriggerButton( Uint16 button )
+{
+   DWORD dwTriggerButton;
+
+   dwTriggerButton = FFEB_NOTRIGGER;
+
+   if (button != 0) {
+      dwTriggerButton = FFJOFS_BUTTON(button - 1);
+   }
+
+   return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection( FFEFFECT * effect, SDL_HapticDirection *dir, int naxes )
+{
+   LONG *rglDir;
+
+   /* Handle no axes a part. */
+   if (naxes == 0) {
+      effect->dwFlags |= FFEFF_SPHERICAL; /* Set as default. */
+      effect->rglDirection = NULL;
+      return 0;
+   }
+
+   /* Has axes. */
+   rglDir = SDL_malloc( sizeof(LONG) * naxes );
+   if (rglDir == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset( rglDir, 0, sizeof(LONG) * naxes );
+   effect->rglDirection = rglDir;
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         effect->dwFlags |= FFEFF_POLAR;
+         rglDir[0] = dir->dir[0];
+         return 0;
+      case SDL_HAPTIC_CARTESIAN:
+         effect->dwFlags |= FFEFF_CARTESIAN;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+      case SDL_HAPTIC_SPHERICAL:
+         effect->dwFlags |= FFEFF_SPHERICAL;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+
+      default:
+         SDL_SetError("Haptic: Unknown direction type.");
+         return -1;
+   }
+}
+
+
+/* Clamps and converts. */
+#define CCONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/* Just converts. */
+#define CONVERT(x)    (((x)*10000) / 0x7FFF)
+/*
+ * Creates the FFEFFECT from a SDL_HapticEffect.
+ */
+static int
+SDL_SYS_ToFFEFFECT( SDL_Haptic * haptic, FFEFFECT * dest, SDL_HapticEffect * src )
+{
+   int i;
+   FFCONSTANTFORCE *constant;
+   FFPERIODIC *periodic;
+   FFCONDITION *condition; /* Actually an array of conditions - one per axis. */
+   FFRAMPFORCE *ramp;
+   FFCUSTOMFORCE *custom;
+   FFENVELOPE *envelope;
+   SDL_HapticConstant *hap_constant;
+   SDL_HapticPeriodic *hap_periodic;
+   SDL_HapticCondition *hap_condition;
+   SDL_HapticRamp *hap_ramp;
+   SDL_HapticCustom *hap_custom;
+   DWORD *axes;
+
+   /* Set global stuff. */
+   SDL_memset(dest, 0, sizeof(FFEFFECT));
+   dest->dwSize = sizeof(FFEFFECT); /* Set the structure size. */
+   dest->dwSamplePeriod = 0; /* Not used by us. */
+   dest->dwGain = 10000; /* Gain is set globally, not locally. */
+   dest->dwFlags = FFEFF_OBJECTOFFSETS; /* Seems obligatory. */
+
+   /* Envelope. */
+   envelope = SDL_malloc( sizeof(FFENVELOPE) );
+   if (envelope == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(envelope, 0, sizeof(FFENVELOPE));
+   dest->lpEnvelope = envelope;
+   envelope->dwSize = sizeof(FFENVELOPE); /* Always should be this. */
+
+   /* Axes. */
+   dest->cAxes = haptic->naxes;
+   if (dest->cAxes > 0) {
+      axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+      if (axes == NULL) {
+         SDL_OutOfMemory();
+         return -1;
+      }
+      axes[0] = haptic->hwdata->axes[0]; /* Always at least one axis. */
+      if (dest->cAxes > 1) {
+         axes[1] = haptic->hwdata->axes[1];
+      }
+      if (dest->cAxes > 2) {
+         axes[2] = haptic->hwdata->axes[2];
+      }
+      dest->rgdwAxes = axes;
+   }
+
+
+   /* The big type handling switch, even bigger then linux's version. */
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         hap_constant = &src->constant;
+         constant = SDL_malloc( sizeof(FFCONSTANTFORCE) );
+         if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(constant, 0, sizeof(FFCONSTANTFORCE));
+
+         /* Specifics */
+         constant->lMagnitude = CONVERT(hap_constant->level);
+         dest->cbTypeSpecificParams = sizeof(FFCONSTANTFORCE); 
+         dest->lpvTypeSpecificParams = constant;
+
+         /* Generics */
+         dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_constant->button);
+         dest->dwTriggerRepeatInterval = hap_constant->interval;
+         dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_constant->attack_length==0) && (hap_constant->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         hap_periodic = &src->periodic;
+         periodic = SDL_malloc(sizeof(FFPERIODIC));
+         if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(periodic, 0, sizeof(FFPERIODIC));
+
+         /* Specifics */
+         periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+         periodic->lOffset = CONVERT(hap_periodic->offset);
+         periodic->dwPhase = hap_periodic->phase;
+         periodic->dwPeriod = hap_periodic->period * 1000;
+         dest->cbTypeSpecificParams = sizeof(FFPERIODIC);
+         dest->lpvTypeSpecificParams = periodic;
+
+         /* Generics */
+         dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_periodic->button);
+         dest->dwTriggerRepeatInterval = hap_periodic->interval;
+         dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+         
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_periodic->attack_length==0) && (hap_periodic->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         hap_condition = &src->condition;
+         condition = SDL_malloc(sizeof(FFCONDITION) * dest->cAxes);
+         if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(condition, 0, sizeof(FFCONDITION));
+
+         /* Specifics */
+         for (i=0; i<dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient = CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient = CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation = CCONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation = CCONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CCONVERT(hap_condition->deadband[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCONDITION) * dest->cAxes;
+         dest->lpvTypeSpecificParams = condition;
+
+         /* Generics */
+         dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_condition->button);
+         dest->dwTriggerRepeatInterval = hap_condition->interval;
+         dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
+            return -1;                
+         }                            
+                                      
+         /* Envelope - Not actually supported by most CONDITION implementations. */
+         SDL_free(dest->lpEnvelope);
+         dest->lpEnvelope = NULL;
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         hap_ramp = &src->ramp;
+         ramp = SDL_malloc(sizeof(FFRAMPFORCE));
+         if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(ramp, 0, sizeof(FFRAMPFORCE));
+
+         /* Specifics */
+         ramp->lStart = CONVERT(hap_ramp->start);
+         ramp->lEnd = CONVERT(hap_ramp->end);
+         dest->cbTypeSpecificParams = sizeof(FFRAMPFORCE);
+         dest->lpvTypeSpecificParams = ramp;
+
+         /* Generics */
+         dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_ramp->button);
+         dest->dwTriggerRepeatInterval = hap_ramp->interval;
+         dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+
+         /* Envelope */
+         if ((hap_ramp->attack_length==0) && (hap_ramp->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_CUSTOM:
+         hap_custom = &src->custom;
+         custom = SDL_malloc(sizeof(FFCUSTOMFORCE));
+         if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(custom, 0, sizeof(FFCUSTOMFORCE));
+
+         /* Specifics */
+         custom->cChannels = hap_custom->channels;
+         custom->dwSamplePeriod = hap_custom->period * 1000;
+         custom->cSamples = hap_custom->samples;
+         custom->rglForceData = SDL_malloc(sizeof(LONG)*custom->cSamples*custom->cChannels);
+         for (i=0; i<hap_custom->samples*hap_custom->channels; i++) { /* Copy data. */
+            custom->rglForceData[i] = CCONVERT(hap_custom->data[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCUSTOMFORCE);
+         dest->lpvTypeSpecificParams = custom;
+
+         /* Generics */
+         dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_custom->button);
+         dest->dwTriggerRepeatInterval = hap_custom->interval;
+         dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_custom->attack_length==0) && (hap_custom->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+         }
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees an FFEFFECT allocated by SDL_SYS_ToFFEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeFFEFFECT( FFEFFECT * effect, int type )
+{
+   FFCUSTOMFORCE *custom;
+
+   if (effect->lpEnvelope != NULL) {
+      SDL_free(effect->lpEnvelope);
+      effect->lpEnvelope = NULL;
+   }
+   if (effect->rgdwAxes != NULL) {
+      SDL_free(effect->rgdwAxes);
+      effect->rgdwAxes = NULL;
+   }
+   if (effect->lpvTypeSpecificParams != NULL) {
+      if (type == SDL_HAPTIC_CUSTOM) { /* Must free the custom data. */
+         custom = (FFCUSTOMFORCE*) effect->lpvTypeSpecificParams;
+         SDL_free(custom->rglForceData);
+         custom->rglForceData = NULL;
+      }
+      SDL_free(effect->lpvTypeSpecificParams);
+      effect->lpvTypeSpecificParams = NULL;
+   }
+   if (effect->rglDirection != NULL) {
+      SDL_free(effect->rglDirection);
+      effect->rglDirection = NULL;
+   }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+CFUUIDRef
+SDL_SYS_HapticEffectType( Uint16 type )
+{
+   switch (type) {
+      case SDL_HAPTIC_CONSTANT:
+         return kFFEffectType_ConstantForce_ID;
+
+      case SDL_HAPTIC_RAMP:
+         return kFFEffectType_RampForce_ID;
+
+      case SDL_HAPTIC_SQUARE:
+         return kFFEffectType_Square_ID;
+
+      case SDL_HAPTIC_SINE:
+         return kFFEffectType_Sine_ID;
+
+      case SDL_HAPTIC_TRIANGLE:
+         return kFFEffectType_Triangle_ID;
+
+      case SDL_HAPTIC_SAWTOOTHUP:
+         return kFFEffectType_SawtoothUp_ID;
+
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         return kFFEffectType_SawtoothDown_ID;
+
+      case SDL_HAPTIC_SPRING:
+         return kFFEffectType_Spring_ID;
+
+      case SDL_HAPTIC_DAMPER:
+         return kFFEffectType_Damper_ID;
+
+      case SDL_HAPTIC_INERTIA:
+         return kFFEffectType_Inertia_ID;
+
+      case SDL_HAPTIC_FRICTION:
+         return kFFEffectType_Friction_ID;
+
+      case SDL_HAPTIC_CUSTOM:
+         return kFFEffectType_CustomForce_ID;
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return NULL;
+   }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   HRESULT ret;
+   CFUUIDRef type;
+
+   /* Alloc the effect. */
+   effect->hweffect = (struct haptic_hweffect *)
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      goto err_hweffect;
+   }
+
+   /* Get the type. */
+   type = SDL_SYS_HapticEffectType(base->type);
+   if (type == NULL) {
+      goto err_hweffect;
+   }
+
+   /* Get the effect. */
+   if (SDL_SYS_ToFFEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+      goto err_effectdone;
+   }
+
+   /* Create the actual effect. */
+   ret = FFDeviceCreateEffect(haptic->hwdata->device, type,
+         &effect->hweffect->effect, &effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create effect: %s.", FFStrError(ret));
+      goto err_effectdone;
+   }
+
+   return 0;
+
+err_effectdone:
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, base->type);
+err_hweffect:
+   if (effect->hweffect != NULL) {
+      SDL_free(effect->hweffect);
+      effect->hweffect = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   HRESULT ret;
+   FFEffectParameterFlag flags;
+   FFEFFECT temp;
+
+   /* Get the effect. */
+   SDL_memset(&temp, 0, sizeof(FFEFFECT));
+   if (SDL_SYS_ToFFEFFECT(haptic, &temp, data) < 0) {
+      goto err_update;
+   }
+
+   /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+    *  only change those parameters. */
+   flags = FFEP_DIRECTION |
+           FFEP_DURATION |
+           FFEP_ENVELOPE |
+           FFEP_STARTDELAY |
+           FFEP_TRIGGERBUTTON |
+           FFEP_TRIGGERREPEATINTERVAL |
+           FFEP_TYPESPECIFICPARAMS;
+
+   /* Create the actual effect. */
+   ret = FFEffectSetParameters(effect->hweffect->ref, &temp, flags);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to update effect: %s.", FFStrError(ret));
+      goto err_update;
+   }
+
+   /* Copy it over. */
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, data->type);
+   SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(FFEFFECT));
+
+   return 0;
+
+err_update:
+   SDL_SYS_HapticFreeFFEFFECT(&temp, data->type);
+   return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   HRESULT ret;
+   Uint32 iter;
+
+   /* Check if it's infinite. */
+   if (iterations == SDL_HAPTIC_INFINITY) {
+      iter = FF_INFINITE;
+   }
+   else
+      iter = iterations;
+
+   /* Run the effect. */
+   ret = FFEffectStart(effect->hweffect->ref, iter, 0);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to run the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFEffectStop(effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFDeviceReleaseEffect(haptic->hwdata->device, effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s.",
+                   FFStrError(ret));
+   }
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, effect->effect.type);
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+   FFEffectStatusFlag status;
+
+   ret = FFEffectGetEffectStatus(effect->hweffect->ref, &status);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get effect status: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   if (status == 0) return SDL_FALSE;
+   return SDL_TRUE; /* Assume it's playing or emulated. */
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   val = gain * 100; /* Mac OS X uses 0 to 10,000 */
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device, FFPROP_FFGAIN, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting gain: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   /* Mac OS X only has 0 (off) and 1 (on) */
+   if (autocenter == 0) val = 0;
+   else val = 1;
+
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device,
+               FFPROP_AUTOCENTER, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting autocenter: %s.", FFStrError(ret));
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_PAUSE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Unpauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_CONTINUE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops all currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_STOPALL); 
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error stopping device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_IOKIT */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/darwin/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/darwin/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/darwin/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/darwin/SDL_syshaptic.c.bak	2017-12-18 13:27:38 +0000
@@ -0,0 +1,1284 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_IOKIT
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/darwin/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <IOKit/IOKitLib.h>
+#include <IOKit/hid/IOHIDKeys.h>
+#include <ForceFeedback/ForceFeedback.h>
+#include <ForceFeedback/ForceFeedbackConstants.h>
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char name[256]; /* Name of the device. */
+
+   io_service_t dev; /* Node we use to create the device. */
+   SDL_Haptic *haptic; /* Haptic currently assosciated with it. */
+   
+   /* Usage pages for determining if it's a mouse or not. */
+   long usage;
+   long usagePage;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   FFDeviceObjectReference device; /* Hardware device. */
+   UInt8 axes[3];
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   FFEffectObjectReference ref; /* Reference. */
+   struct FFEFFECT effect; /* Hardware effect. */
+};
+
+/*
+ * Prototypes.
+ */
+static void SDL_SYS_HapticFreeFFEFFECT(FFEFFECT * effect, int type);
+static int HIDGetDeviceProduct(io_service_t dev, char * name);
+
+
+/* 
+ * Like strerror but for force feedback errors.
+ */
+static const char *
+FFStrError(HRESULT err)
+{
+   switch (err) {
+      case FFERR_DEVICEFULL:
+         return "device full";
+      /* This should be valid, but for some reason isn't defined... */
+      /*case FFERR_DEVICENOTREG:
+         return "device not registered";*/
+      case FFERR_DEVICEPAUSED:
+         return "device paused";
+      case FFERR_DEVICERELEASED:
+         return "device released";
+      case FFERR_EFFECTPLAYING:
+         return "effect playing";
+      case FFERR_EFFECTTYPEMISMATCH:
+         return "effect type mismatch";
+      case FFERR_EFFECTTYPENOTSUPPORTED:
+         return "effect type not supported";
+      case FFERR_GENERIC:
+         return "undetermined error";
+      case FFERR_HASEFFECTS:
+         return "device has effects";
+      case FFERR_INCOMPLETEEFFECT:
+         return "incomplete effect";
+      case FFERR_INTERNAL:
+         return "internal fault";
+      case FFERR_INVALIDDOWNLOADID:
+         return "invalid download id";
+      case FFERR_INVALIDPARAM:
+         return "invalid parameter";
+      case FFERR_MOREDATA:
+         return "more data";
+      case FFERR_NOINTERFACE:
+         return "interface not supported";
+      case FFERR_NOTDOWNLOADED:
+         return "effect is not downloaded";
+      case FFERR_NOTINITIALIZED:
+         return "object has not been initialized";
+      case FFERR_OUTOFMEMORY:
+         return "out of memory";
+      case FFERR_UNPLUGGED:
+         return "device is unplugged";
+      case FFERR_UNSUPPORTED:
+         return "function call unsupported";
+      case FFERR_UNSUPPORTEDAXIS:
+         return "axis unsupported";
+
+      default:
+         return "unknown error";
+   }
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   int numhaptics;
+   IOReturn result;
+   io_iterator_t iter;
+   CFDictionaryRef match;
+   io_service_t device;
+   CFMutableDictionaryRef hidProperties;
+   CFTypeRef refCF;
+
+   /* Clear all the memory. */
+   SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+   /* Get HID devices. */
+   match = IOServiceMatching(kIOHIDDeviceKey);
+   if (match == NULL) {
+      SDL_SetError("Haptic: Failed to get IOServiceMatching.");
+      return -1;
+   }
+
+   /* Now search I/O Registry for matching devices. */
+   result = IOServiceGetMatchingServices(kIOMasterPortDefault, match, &iter);
+   if (result != kIOReturnSuccess) {
+      SDL_SetError("Haptic: Couldn't create a HID object iterator.");
+      return -1;
+   }
+   /* IOServiceGetMatchingServices consumes dictionary. */
+
+   if (!IOIteratorIsValid(iter)) { /* No iterator. */
+      numhaptics = 0;
+      return 0;
+   }
+
+   numhaptics = 0;
+   while ((device = IOIteratorNext(iter)) != IO_OBJECT_NULL) {
+
+      /* Check for force feedback. */
+      if (FFIsForceFeedback(device) == FF_OK) {
+
+         /* Set basic device data. */
+         HIDGetDeviceProduct(device, SDL_hapticlist[numhaptics].name);
+         SDL_hapticlist[numhaptics].dev = device;
+         SDL_hapticlist[numhaptics].haptic = NULL;
+
+         /* Set usage pages. */
+         hidProperties = 0;
+         refCF = 0;
+         result = IORegistryEntryCreateCFProperties(device,
+               &hidProperties, kCFAllocatorDefault, kNilOptions);
+         if ((result == KERN_SUCCESS) && hidProperties) {
+            refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
+            if (refCF) {
+               if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                     &SDL_hapticlist[numhaptics].usagePage))
+                  SDL_SetError("Haptic: Recieving device's usage page.");
+               refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
+               if (refCF) {
+                  if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                        &SDL_hapticlist[numhaptics].usage))
+                     SDL_SetError("Haptic: Recieving device's usage.");
+               }
+            }
+            CFRelease(hidProperties);
+         }
+
+         /* Device has been added. */
+         numhaptics++;
+      }
+      else { /* Free the unused device. */
+         IOObjectRelease(device);
+      }
+
+      /* Reached haptic limit. */
+      if (numhaptics >= MAX_HAPTICS)
+         break;
+   }
+   IOObjectRelease(iter);
+
+   return numhaptics;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   return SDL_hapticlist[index].name;
+}
+
+/*
+ * Gets the device's product name.
+ */
+static int
+HIDGetDeviceProduct(io_service_t dev, char *name)
+{
+   CFMutableDictionaryRef hidProperties, usbProperties;
+   io_registry_entry_t parent1, parent2;
+   kern_return_t ret;
+
+   hidProperties = usbProperties = 0;
+
+   ret = IORegistryEntryCreateCFProperties(dev, &hidProperties,
+                                           kCFAllocatorDefault,
+                                           kNilOptions);
+   if ((ret != KERN_SUCCESS) || !hidProperties) {
+      SDL_SetError("Haptic: Unable to create CFProperties.");
+      return -1;
+   }
+
+   /* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
+    * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
+    */
+   if ((KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(dev, kIOServicePlane, &parent1))
+         && (KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(parent1, kIOServicePlane, &parent2))
+         && (KERN_SUCCESS ==
+            IORegistryEntryCreateCFProperties(parent2, &usbProperties,
+                                              kCFAllocatorDefault,
+                                              kNilOptions))) {
+      if (usbProperties) {
+         CFTypeRef refCF = 0;
+         /* get device info
+          * try hid dictionary first, if fail then go to usb dictionary
+          */
+
+
+         /* Get product name */
+         refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDProductKey));
+         if (!refCF)
+            refCF =
+               CFDictionaryGetValue(usbProperties, CFSTR("USB Product Name"));
+         if (refCF) {
+            if (!CFStringGetCString(refCF, name, 256,
+                                    CFStringGetSystemEncoding())) {
+               SDL_SetError("Haptic: CFStringGetCString error retrieving pDevice->product.");
+               return -1;
+            }
+         }
+
+         CFRelease(usbProperties);
+      }
+      else {
+         SDL_SetError("Haptic: IORegistryEntryCreateCFProperties failed to create usbProperties.");
+         return -1;
+      }
+
+      /* Release stuff. */
+      if (kIOReturnSuccess != IOObjectRelease(parent2)) {
+         SDL_SetError("Haptic: IOObjectRelease error with parent2.");
+      }
+      if (kIOReturnSuccess != IOObjectRelease(parent1))  {
+         SDL_SetError("Haptic: IOObjectRelease error with parent1.");
+      }
+   }
+   else {
+      SDL_SetError("Haptic: Error getting registry entries.");
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#define FF_TEST(ff, s) \
+if (features.supportedEffects & (ff)) supported |= (s)
+/*
+ * Gets supported features.
+ */
+static unsigned int
+GetSupportedFeatures(SDL_Haptic* haptic)
+{
+   HRESULT ret;
+   FFDeviceObjectReference device;
+   FFCAPABILITIES features;
+   unsigned int supported;
+   Uint32 val;
+
+   device = haptic->hwdata->device;
+
+   ret = FFDeviceGetForceFeedbackCapabilities(device, &features);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get device's supported features.");
+      return -1;
+   }
+
+   supported = 0;
+
+   /* Get maximum effects. */
+   haptic->neffects = features.storageCapacity;
+   haptic->nplaying = features.playbackCapacity;
+
+   /* Test for effects. */
+   FF_TEST(FFCAP_ET_CONSTANTFORCE, SDL_HAPTIC_CONSTANT);
+   FF_TEST(FFCAP_ET_RAMPFORCE,     SDL_HAPTIC_RAMP);
+   FF_TEST(FFCAP_ET_SQUARE,        SDL_HAPTIC_SQUARE);
+   FF_TEST(FFCAP_ET_SINE,          SDL_HAPTIC_SINE);
+   FF_TEST(FFCAP_ET_TRIANGLE,      SDL_HAPTIC_TRIANGLE);
+   FF_TEST(FFCAP_ET_SAWTOOTHUP,    SDL_HAPTIC_SAWTOOTHUP);
+   FF_TEST(FFCAP_ET_SAWTOOTHDOWN,  SDL_HAPTIC_SAWTOOTHDOWN);
+   FF_TEST(FFCAP_ET_SPRING,        SDL_HAPTIC_SPRING);
+   FF_TEST(FFCAP_ET_DAMPER,        SDL_HAPTIC_DAMPER);
+   FF_TEST(FFCAP_ET_INERTIA,       SDL_HAPTIC_INERTIA);
+   FF_TEST(FFCAP_ET_FRICTION,      SDL_HAPTIC_FRICTION);
+   FF_TEST(FFCAP_ET_CUSTOMFORCE,   SDL_HAPTIC_CUSTOM);
+
+   /* Check if supports gain. */
+   ret = FFDeviceGetForceFeedbackProperty( device, FFPROP_FFGAIN,
+                                           &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_GAIN;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports gain: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Checks if supports autocenter. */
+   ret = FFDeviceGetForceFeedbackProperty(device, FFPROP_AUTOCENTER,
+                                          &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_AUTOCENTER;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports autocenter: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Check for axes, we have an artificial limit on axes */
+   haptic->naxes = ((features.numFfAxes) > 3) ?
+         3 : features.numFfAxes;
+   /* Actually store the axes we want to use */
+   SDL_memcpy( haptic->hwdata->axes, features.ffAxes, haptic->naxes * sizeof(Uint8));
+
+   /* Always supported features. */
+   supported |= SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+   haptic->supported = supported;
+   return 0;;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromService(SDL_Haptic * haptic, io_service_t service)
+{
+   HRESULT ret;
+   int ret2;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto creat_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+  
+   /* Open the device */
+   ret = FFCreateDevice( service, &haptic->hwdata->device);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create device from service: %s.",
+                   FFStrError(ret));
+      goto creat_err;
+   }
+
+   /* Get supported features. */
+   ret2 = GetSupportedFeatures( haptic );
+   if (haptic->supported < 0) {
+      goto open_err;
+   }
+
+
+   /* Reset and then enable actuators. */
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_RESET );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to reset device: %s.", FFStrError(ret));
+      goto open_err;
+   }
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_SETACTUATORSON  );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to enable actuators: %s.", FFStrError(ret));
+      goto open_err;
+   }
+
+
+   /* Allocate effects memory. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+   
+   return 0;
+   
+   /* Error handling */
+open_err:
+   FFReleaseDevice(haptic->hwdata->device);
+creat_err:
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;                                              
+   }
+   return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                SDL_hapticlist[haptic->index].dev);
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+      if ((SDL_hapticlist[i].usagePage == kHIDPage_GenericDesktop) &&
+            (SDL_hapticlist[i].usage == kHIDUsage_GD_Mouse))
+         return i;
+   }
+
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   if (joystick->hwdata->ffservice != 0)
+      return SDL_TRUE;
+   return SDL_FALSE;
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   if (IOObjectIsEqualTo((io_object_t) haptic->hwdata->device,
+                                       joystick->hwdata->ffservice))
+      return 1;
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                joystick->hwdata->ffservice);
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free Effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      FFReleaseDevice(haptic->hwdata->device);
+
+      /* Free */
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; i < SDL_numhaptics; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      /* Free the io_service_t */
+      IOObjectRelease(SDL_hapticlist[i].dev);
+   }
+}
+
+
+/*
+ * Converts an SDL trigger button to an FFEFFECT trigger button.
+ */
+static DWORD
+FFGetTriggerButton( Uint16 button )
+{
+   DWORD dwTriggerButton;
+
+   dwTriggerButton = FFEB_NOTRIGGER;
+
+   if (button != 0) {
+      dwTriggerButton = FFJOFS_BUTTON(button - 1);
+   }
+
+   return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection( FFEFFECT * effect, SDL_HapticDirection *dir, int naxes )
+{
+   LONG *rglDir;
+
+   /* Handle no axes a part. */
+   if (naxes == 0) {
+      effect->dwFlags |= FFEFF_SPHERICAL; /* Set as default. */
+      effect->rglDirection = NULL;
+      return 0;
+   }
+
+   /* Has axes. */
+   rglDir = SDL_malloc( sizeof(LONG) * naxes );
+   if (rglDir == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset( rglDir, 0, sizeof(LONG) * naxes );
+   effect->rglDirection = rglDir;
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         effect->dwFlags |= FFEFF_POLAR;
+         rglDir[0] = dir->dir[0];
+         return 0;
+      case SDL_HAPTIC_CARTESIAN:
+         effect->dwFlags |= FFEFF_CARTESIAN;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+      case SDL_HAPTIC_SPHERICAL:
+         effect->dwFlags |= FFEFF_SPHERICAL;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+
+      default:
+         SDL_SetError("Haptic: Unknown direction type.");
+         return -1;
+   }
+}
+
+
+/* Clamps and converts. */
+#define CCONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/* Just converts. */
+#define CONVERT(x)    (((x)*10000) / 0x7FFF)
+/*
+ * Creates the FFEFFECT from a SDL_HapticEffect.
+ */
+static int
+SDL_SYS_ToFFEFFECT( SDL_Haptic * haptic, FFEFFECT * dest, SDL_HapticEffect * src )
+{
+   int i;
+   FFCONSTANTFORCE *constant;
+   FFPERIODIC *periodic;
+   FFCONDITION *condition; /* Actually an array of conditions - one per axis. */
+   FFRAMPFORCE *ramp;
+   FFCUSTOMFORCE *custom;
+   FFENVELOPE *envelope;
+   SDL_HapticConstant *hap_constant;
+   SDL_HapticPeriodic *hap_periodic;
+   SDL_HapticCondition *hap_condition;
+   SDL_HapticRamp *hap_ramp;
+   SDL_HapticCustom *hap_custom;
+   DWORD *axes;
+
+   /* Set global stuff. */
+   SDL_memset(dest, 0, sizeof(FFEFFECT));
+   dest->dwSize = sizeof(FFEFFECT); /* Set the structure size. */
+   dest->dwSamplePeriod = 0; /* Not used by us. */
+   dest->dwGain = 10000; /* Gain is set globally, not locally. */
+   dest->dwFlags = FFEFF_OBJECTOFFSETS; /* Seems obligatory. */
+
+   /* Envelope. */
+   envelope = SDL_malloc( sizeof(FFENVELOPE) );
+   if (envelope == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(envelope, 0, sizeof(FFENVELOPE));
+   dest->lpEnvelope = envelope;
+   envelope->dwSize = sizeof(FFENVELOPE); /* Always should be this. */
+
+   /* Axes. */
+   dest->cAxes = haptic->naxes;
+   if (dest->cAxes > 0) {
+      axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+      if (axes == NULL) {
+         SDL_OutOfMemory();
+         return -1;
+      }
+      axes[0] = haptic->hwdata->axes[0]; /* Always at least one axis. */
+      if (dest->cAxes > 1) {
+         axes[1] = haptic->hwdata->axes[1];
+      }
+      if (dest->cAxes > 2) {
+         axes[2] = haptic->hwdata->axes[2];
+      }
+      dest->rgdwAxes = axes;
+   }
+
+
+   /* The big type handling switch, even bigger then linux's version. */
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         hap_constant = &src->constant;
+         constant = SDL_malloc( sizeof(FFCONSTANTFORCE) );
+         if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(constant, 0, sizeof(FFCONSTANTFORCE));
+
+         /* Specifics */
+         constant->lMagnitude = CONVERT(hap_constant->level);
+         dest->cbTypeSpecificParams = sizeof(FFCONSTANTFORCE); 
+         dest->lpvTypeSpecificParams = constant;
+
+         /* Generics */
+         dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_constant->button);
+         dest->dwTriggerRepeatInterval = hap_constant->interval;
+         dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_constant->attack_length==0) && (hap_constant->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         hap_periodic = &src->periodic;
+         periodic = SDL_malloc(sizeof(FFPERIODIC));
+         if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(periodic, 0, sizeof(FFPERIODIC));
+
+         /* Specifics */
+         periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+         periodic->lOffset = CONVERT(hap_periodic->offset);
+         periodic->dwPhase = hap_periodic->phase;
+         periodic->dwPeriod = hap_periodic->period * 1000;
+         dest->cbTypeSpecificParams = sizeof(FFPERIODIC);
+         dest->lpvTypeSpecificParams = periodic;
+
+         /* Generics */
+         dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_periodic->button);
+         dest->dwTriggerRepeatInterval = hap_periodic->interval;
+         dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+         
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_periodic->attack_length==0) && (hap_periodic->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         hap_condition = &src->condition;
+         condition = SDL_malloc(sizeof(FFCONDITION) * dest->cAxes);
+         if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(condition, 0, sizeof(FFCONDITION));
+
+         /* Specifics */
+         for (i=0; i<dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient = CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient = CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation = CCONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation = CCONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CCONVERT(hap_condition->deadband[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCONDITION) * dest->cAxes;
+         dest->lpvTypeSpecificParams = condition;
+
+         /* Generics */
+         dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_condition->button);
+         dest->dwTriggerRepeatInterval = hap_condition->interval;
+         dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
+            return -1;                
+         }                            
+                                      
+         /* Envelope - Not actually supported by most CONDITION implementations. */
+         SDL_free(dest->lpEnvelope);
+         dest->lpEnvelope = NULL;
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         hap_ramp = &src->ramp;
+         ramp = SDL_malloc(sizeof(FFRAMPFORCE));
+         if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(ramp, 0, sizeof(FFRAMPFORCE));
+
+         /* Specifics */
+         ramp->lStart = CONVERT(hap_ramp->start);
+         ramp->lEnd = CONVERT(hap_ramp->end);
+         dest->cbTypeSpecificParams = sizeof(FFRAMPFORCE);
+         dest->lpvTypeSpecificParams = ramp;
+
+         /* Generics */
+         dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_ramp->button);
+         dest->dwTriggerRepeatInterval = hap_ramp->interval;
+         dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+
+         /* Envelope */
+         if ((hap_ramp->attack_length==0) && (hap_ramp->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_CUSTOM:
+         hap_custom = &src->custom;
+         custom = SDL_malloc(sizeof(FFCUSTOMFORCE));
+         if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(custom, 0, sizeof(FFCUSTOMFORCE));
+
+         /* Specifics */
+         custom->cChannels = hap_custom->channels;
+         custom->dwSamplePeriod = hap_custom->period * 1000;
+         custom->cSamples = hap_custom->samples;
+         custom->rglForceData = SDL_malloc(sizeof(LONG)*custom->cSamples*custom->cChannels);
+         for (i=0; i<hap_custom->samples*hap_custom->channels; i++) { /* Copy data. */
+            custom->rglForceData[i] = CCONVERT(hap_custom->data[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCUSTOMFORCE);
+         dest->lpvTypeSpecificParams = custom;
+
+         /* Generics */
+         dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_custom->button);
+         dest->dwTriggerRepeatInterval = hap_custom->interval;
+         dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_custom->attack_length==0) && (hap_custom->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+         }
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees an FFEFFECT allocated by SDL_SYS_ToFFEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeFFEFFECT( FFEFFECT * effect, int type )
+{
+   FFCUSTOMFORCE *custom;
+
+   if (effect->lpEnvelope != NULL) {
+      SDL_free(effect->lpEnvelope);
+      effect->lpEnvelope = NULL;
+   }
+   if (effect->rgdwAxes != NULL) {
+      SDL_free(effect->rgdwAxes);
+      effect->rgdwAxes = NULL;
+   }
+   if (effect->lpvTypeSpecificParams != NULL) {
+      if (type == SDL_HAPTIC_CUSTOM) { /* Must free the custom data. */
+         custom = (FFCUSTOMFORCE*) effect->lpvTypeSpecificParams;
+         SDL_free(custom->rglForceData);
+         custom->rglForceData = NULL;
+      }
+      SDL_free(effect->lpvTypeSpecificParams);
+      effect->lpvTypeSpecificParams = NULL;
+   }
+   if (effect->rglDirection != NULL) {
+      SDL_free(effect->rglDirection);
+      effect->rglDirection = NULL;
+   }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+CFUUIDRef
+SDL_SYS_HapticEffectType( Uint16 type )
+{
+   switch (type) {
+      case SDL_HAPTIC_CONSTANT:
+         return kFFEffectType_ConstantForce_ID;
+
+      case SDL_HAPTIC_RAMP:
+         return kFFEffectType_RampForce_ID;
+
+      case SDL_HAPTIC_SQUARE:
+         return kFFEffectType_Square_ID;
+
+      case SDL_HAPTIC_SINE:
+         return kFFEffectType_Sine_ID;
+
+      case SDL_HAPTIC_TRIANGLE:
+         return kFFEffectType_Triangle_ID;
+
+      case SDL_HAPTIC_SAWTOOTHUP:
+         return kFFEffectType_SawtoothUp_ID;
+
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         return kFFEffectType_SawtoothDown_ID;
+
+      case SDL_HAPTIC_SPRING:
+         return kFFEffectType_Spring_ID;
+
+      case SDL_HAPTIC_DAMPER:
+         return kFFEffectType_Damper_ID;
+
+      case SDL_HAPTIC_INERTIA:
+         return kFFEffectType_Inertia_ID;
+
+      case SDL_HAPTIC_FRICTION:
+         return kFFEffectType_Friction_ID;
+
+      case SDL_HAPTIC_CUSTOM:
+         return kFFEffectType_CustomForce_ID;
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return NULL;
+   }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   HRESULT ret;
+   CFUUIDRef type;
+
+   /* Alloc the effect. */
+   effect->hweffect = (struct haptic_hweffect *)
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      goto err_hweffect;
+   }
+
+   /* Get the type. */
+   type = SDL_SYS_HapticEffectType(base->type);
+   if (type == NULL) {
+      goto err_hweffect;
+   }
+
+   /* Get the effect. */
+   if (SDL_SYS_ToFFEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+      goto err_effectdone;
+   }
+
+   /* Create the actual effect. */
+   ret = FFDeviceCreateEffect(haptic->hwdata->device, type,
+         &effect->hweffect->effect, &effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create effect: %s.", FFStrError(ret));
+      goto err_effectdone;
+   }
+
+   return 0;
+
+err_effectdone:
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, base->type);
+err_hweffect:
+   if (effect->hweffect != NULL) {
+      SDL_free(effect->hweffect);
+      effect->hweffect = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   HRESULT ret;
+   FFEffectParameterFlag flags;
+   FFEFFECT temp;
+
+   /* Get the effect. */
+   SDL_memset(&temp, 0, sizeof(FFEFFECT));
+   if (SDL_SYS_ToFFEFFECT(haptic, &temp, data) < 0) {
+      goto err_update;
+   }
+
+   /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+    *  only change those parameters. */
+   flags = FFEP_DIRECTION |
+           FFEP_DURATION |
+           FFEP_ENVELOPE |
+           FFEP_STARTDELAY |
+           FFEP_TRIGGERBUTTON |
+           FFEP_TRIGGERREPEATINTERVAL |
+           FFEP_TYPESPECIFICPARAMS;
+
+   /* Create the actual effect. */
+   ret = FFEffectSetParameters(effect->hweffect->ref, &temp, flags);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to update effect: %s.", FFStrError(ret));
+      goto err_update;
+   }
+
+   /* Copy it over. */
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, data->type);
+   SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(FFEFFECT));
+
+   return 0;
+
+err_update:
+   SDL_SYS_HapticFreeFFEFFECT(&temp, data->type);
+   return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   HRESULT ret;
+   Uint32 iter;
+
+   /* Check if it's infinite. */
+   if (iterations == SDL_HAPTIC_INFINITY) {
+      iter = FF_INFINITE;
+   }
+   else
+      iter = iterations;
+
+   /* Run the effect. */
+   ret = FFEffectStart(effect->hweffect->ref, iter, 0);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to run the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFEffectStop(effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFDeviceReleaseEffect(haptic->hwdata->device, effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s.",
+                   FFStrError(ret));
+   }
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, effect->effect.type);
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+   FFEffectStatusFlag status;
+
+   ret = FFEffectGetEffectStatus(effect->hweffect->ref, &status);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get effect status: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   if (status == 0) return SDL_FALSE;
+   return SDL_TRUE; /* Assume it's playing or emulated. */
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   val = gain * 100; /* Mac OS X uses 0 to 10,000 */
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device, FFPROP_FFGAIN, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting gain: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   /* Mac OS X only has 0 (off) and 1 (on) */
+   if (autocenter == 0) val = 0;
+   else val = 1;
+
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device,
+               FFPROP_AUTOCENTER, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting autocenter: %s.", FFStrError(ret));
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_PAUSE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Unpauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_CONTINUE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops all currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_STOPALL); 
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error stopping device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_IOKIT */
diff -ruN SDL-1.2.13/src/dummy/SDL_syshaptic.c SDL-1.2.13_OOx64/src/dummy/SDL_syshaptic.c
--- SDL-1.2.13/src/dummy/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/dummy/SDL_syshaptic.c	2017-12-18 15:09:06 +0000
@@ -0,0 +1,193 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#if defined(SDL_HAPTIC_DUMMY) || defined(SDL_HAPTIC_DISABLED)
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+
+
+static int
+SDL_SYS_LogicError(void)
+{
+   SDL_SetError("Logic error: No haptic devices available.");
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticInit(void)
+{
+   return 0;
+}
+
+
+const char *
+SDL_SYS_HapticName(int index)
+{
+   SDL_SYS_LogicError();
+   return NULL;
+}
+
+
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticMouse(void)
+{
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   return;
+}
+
+
+void
+SDL_SYS_HapticQuit(void)
+{
+   return;
+}
+
+
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                        struct haptic_effect * effect,
+                        SDL_HapticEffect * base)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect * effect,
+                           SDL_HapticEffect * data)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect, Uint32 iterations)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return;
+}
+
+
+int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+
+#endif /* SDL_HAPTIC_DUMMY || SDL_HAPTIC_DISABLED */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/dummy/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/dummy/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/dummy/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/dummy/SDL_syshaptic.c.bak	2017-12-18 13:29:10 +0000
@@ -0,0 +1,193 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#if defined(SDL_HAPTIC_DUMMY) || defined(SDL_HAPTIC_DISABLED)
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+
+
+static int
+SDL_SYS_LogicError(void)
+{
+   SDL_SetError("Logic error: No haptic devices available.");
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticInit(void)
+{
+   return 0;
+}
+
+
+const char *
+SDL_SYS_HapticName(int index)
+{
+   SDL_SYS_LogicError();
+   return NULL;
+}
+
+
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticMouse(void)
+{
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   return;
+}
+
+
+void
+SDL_SYS_HapticQuit(void)
+{
+   return;
+}
+
+
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                        struct haptic_effect * effect,
+                        SDL_HapticEffect * base)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect * effect,
+                           SDL_HapticEffect * data)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect, Uint32 iterations)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return;
+}
+
+
+int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+
+#endif /* SDL_HAPTIC_DUMMY || SDL_HAPTIC_DISABLED */
diff -ruN SDL-1.2.13/src/events/SDL_events_c.h SDL-1.2.13_OOx64/src/events/SDL_events_c.h
--- SDL-1.2.13/src/events/SDL_events_c.h	2007-12-31 04:47:59 +0000
+++ SDL-1.2.13_OOx64/src/events/SDL_events_c.h	2018-04-23 16:23:32 +0000
@@ -57,7 +57,7 @@
 extern int SDL_PrivateAppActive(Uint8 gain, Uint8 state);
 extern int SDL_PrivateMouseMotion(Uint8 buttonstate, int relative,
 						Sint16 x, Sint16 y);
-extern int SDL_PrivateMouseButton(Uint8 state, Uint8 button,Sint16 x,Sint16 y);
+extern int SDL_PrivateMouseButton(Uint8 state, Uint8 button,Sint16 x,Sint16 y, short wDelta);
 extern int SDL_PrivateKeyboard(Uint8 state, SDL_keysym *key);
 extern int SDL_PrivateResize(int w, int h);
 extern int SDL_PrivateExpose(void);
diff -ruN SDL-1.2.13/src/events/SDL_mouse.c SDL-1.2.13_OOx64/src/events/SDL_mouse.c
--- SDL-1.2.13/src/events/SDL_mouse.c	2007-12-31 04:47:59 +0000
+++ SDL-1.2.13_OOx64/src/events/SDL_mouse.c	2018-04-23 16:26:15 +0000
@@ -60,7 +60,7 @@
 	Uint8 i;
 	for ( i = 0; i < sizeof(SDL_ButtonState)*8; ++i ) {
 		if ( SDL_ButtonState & SDL_BUTTON(i) ) {
-			SDL_PrivateMouseButton(SDL_RELEASED, i, 0, 0);
+			SDL_PrivateMouseButton(SDL_RELEASED, i, 0, 0, 0);
 		}
 	}
 }
@@ -189,7 +189,7 @@
 	return(posted);
 }
 
-int SDL_PrivateMouseButton(Uint8 state, Uint8 button, Sint16 x, Sint16 y)
+int SDL_PrivateMouseButton(Uint8 state, Uint8 button, Sint16 x, Sint16 y, short wDelta)
 {
 	SDL_Event event;
 	int posted;
@@ -253,6 +253,7 @@
 		event.button.button = button;
 		event.button.x = x;
 		event.button.y = y;
+		event.button.wheelDelta = button == SDL_BUTTON_WHEELUP || SDL_BUTTON_WHEELDOWN ? wDelta : 0;
 		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
 			posted = 1;
 			SDL_PushEvent(&event);
diff -ruN SDL-1.2.13/src/events/SDL_resize.c SDL-1.2.13_OOx64/src/events/SDL_resize.c
--- SDL-1.2.13/src/events/SDL_resize.c	2007-12-31 04:47:59 +0000
+++ SDL-1.2.13_OOx64/src/events/SDL_resize.c	2009-03-07 19:56:02 +0000
@@ -54,6 +54,11 @@
 	     ((w == SDL_VideoSurface->w) && (h == SDL_VideoSurface->h)) ) {
 		return(0);
 	}
+	
+#ifdef __WIN32__
+	SDL_VideoSurface->w = w;
+	SDL_VideoSurface->h = h;
+#endif
 
 	/* Pull out all old resize events */
 	SDL_PeepEvents(events, sizeof(events)/sizeof(events[0]),
diff -ruN SDL-1.2.13/src/events/SDL_resize.c.original SDL-1.2.13_OOx64/src/events/SDL_resize.c.original
--- SDL-1.2.13/src/events/SDL_resize.c.original	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/events/SDL_resize.c.original	2007-12-30 18:48:00 +0000
@@ -0,0 +1,75 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Resize event handling code for SDL */
+
+#include "SDL_events.h"
+#include "SDL_events_c.h"
+#include "../video/SDL_sysvideo.h"
+
+
+/* Keep the last resize event so we don't post duplicates */
+static struct {
+	int w;
+	int h;
+} last_resize;
+
+/* This is global for SDL_eventloop.c */
+int SDL_PrivateResize(int w, int h)
+{
+	int posted;
+	SDL_Event events[32];
+
+	/* See if this event would change the video surface */
+	if ( !w || !h
+#ifndef __OS2__
+            || ((last_resize.w == w) && (last_resize.h == h))
+#endif
+    ) {
+		return(0);
+	}
+        last_resize.w = w;
+        last_resize.h = h;
+	if ( ! SDL_VideoSurface ||
+	     ((w == SDL_VideoSurface->w) && (h == SDL_VideoSurface->h)) ) {
+		return(0);
+	}
+
+	/* Pull out all old resize events */
+	SDL_PeepEvents(events, sizeof(events)/sizeof(events[0]),
+	                    SDL_GETEVENT, SDL_VIDEORESIZEMASK);
+
+	/* Post the event, if desired */
+	posted = 0;
+	if ( SDL_ProcessEvents[SDL_VIDEORESIZE] == SDL_ENABLE ) {
+		SDL_Event event;
+		event.type = SDL_VIDEORESIZE;
+		event.resize.w = w;
+		event.resize.h = h;
+		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
+			posted = 1;
+			SDL_PushEvent(&event);
+		}
+	}
+	return(posted);
+}
diff -ruN SDL-1.2.13/src/haptic/SDL_haptic.c SDL-1.2.13_OOx64/src/haptic/SDL_haptic.c
--- SDL-1.2.13/src/haptic/SDL_haptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/SDL_haptic.c	2017-12-18 15:11:50 +0000
@@ -0,0 +1,689 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_syshaptic.h"
+#include "../joystick/SDL_joystick_c.h" /* For SDL_PrivateJoystickValid */
+
+
+Uint8 SDL_numhaptics = 0;
+SDL_Haptic **SDL_haptics = NULL;
+
+
+/*
+ * Initializes the Haptic devices.
+ */
+int
+SDL_HapticInit(void)
+{  
+   int arraylen;
+   int status;
+
+   SDL_numhaptics = 0;
+   status = SDL_SYS_HapticInit();
+   if (status >= 0) {
+      arraylen = (status + 1) * sizeof(*SDL_haptics);
+      SDL_haptics = (SDL_Haptic **) SDL_malloc(arraylen);
+      if (SDL_haptics == NULL) { /* Out of memory. */
+         SDL_numhaptics = 0;
+      }
+      else {
+         SDL_memset(SDL_haptics, 0, arraylen);
+         SDL_numhaptics = status;
+      }
+      status = 0;
+   }
+
+   return status;
+}
+
+
+/*
+ * Checks to see if the haptic device is valid
+ */
+static int
+ValidHaptic(SDL_Haptic * haptic)
+{
+   int i;
+   int valid;
+
+   valid = 0;
+   for (i=0; i<SDL_numhaptics; i++) {
+      if (SDL_haptics[i] == haptic) {
+         valid = 1;
+         break;
+      }
+   }
+   
+   return valid;
+}
+
+
+/*
+ * Returns the number of available devices.
+ */
+int
+SDL_NumHaptics(void)
+{
+   return SDL_numhaptics;
+}
+
+
+/*
+ * Gets the name of a Haptic device by index.
+ */
+const char *
+SDL_HapticName(int device_index)
+{
+   if ((device_index < 0) || (device_index >= SDL_numhaptics)) {
+      SDL_SetError("Haptic: There are %d haptic devices available", SDL_numhaptics);
+      return NULL;
+   }
+   return SDL_SYS_HapticName(device_index);
+}
+
+
+/*
+ * Opens a Haptic device.
+ */
+SDL_Haptic *
+SDL_HapticOpen(int device_index)
+{
+   int i;
+   SDL_Haptic *haptic;
+
+   if ((device_index < 0) || (device_index >= SDL_numhaptics)) {
+      SDL_SetError("Haptic: There are %d haptic devices available", SDL_numhaptics);
+      return NULL;
+   }
+
+   /* If the haptic is already open, return it */
+   for (i=0; SDL_haptics[i]; i++) {             
+      if (device_index == SDL_haptics[i]->index) {
+         haptic = SDL_haptics[i];
+         ++haptic->ref_count;
+         return haptic;
+      }
+   }
+
+   /* Create the haptic device */
+   haptic = (SDL_Haptic *) SDL_malloc((sizeof *haptic));
+   if (haptic == NULL) {
+      SDL_OutOfMemory();
+      return NULL;
+   }
+
+   /* Initialize the haptic device */
+   SDL_memset(haptic, 0, (sizeof *haptic));
+   haptic->index = device_index;
+   if (SDL_SYS_HapticOpen(haptic) < 0) {
+      SDL_free(haptic);
+      return NULL;
+   }
+
+   /* Disable autocenter and set gain to max. */
+   if (haptic->supported & SDL_HAPTIC_GAIN)
+      SDL_HapticSetGain(haptic,100);
+   if (haptic->supported & SDL_HAPTIC_AUTOCENTER)
+      SDL_HapticSetAutocenter(haptic,0);
+
+   /* Add haptic to list */
+   ++haptic->ref_count;
+   for (i=0; SDL_haptics[i]; i++)
+      /* Skip to next haptic */ ;
+   SDL_haptics[i] = haptic;
+
+   return haptic;
+}
+
+
+/*
+ * Returns 1 if the device has been opened.
+ */
+int
+SDL_HapticOpened(int device_index)
+{
+   int i, opened;
+
+   opened = 0;
+   for (i=0; SDL_haptics[i]; i++) {
+      if (SDL_haptics[i]->index == (Uint8) device_index) {
+         opened = 1;
+         break;
+      }
+   }
+   return opened;
+}
+
+
+/*
+ * Returns the index to a haptic device.
+ */
+int
+SDL_HapticIndex(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return haptic->index;
+}
+
+
+/*
+ * Returns SDL_TRUE if mouse is haptic, SDL_FALSE if it isn't.
+ */
+int
+SDL_MouseIsHaptic(void)
+{
+   if (SDL_SYS_HapticMouse() < 0)
+      return SDL_FALSE;
+   return SDL_TRUE;
+}
+
+
+/*
+ * Returns the haptic device if mouse is haptic or NULL elsewise.
+ */
+SDL_Haptic *
+SDL_HapticOpenFromMouse(void)
+{
+   int device_index;
+
+   device_index = SDL_SYS_HapticMouse();
+
+   if (device_index < 0) {
+      SDL_SetError("Haptic: Mouse isn't a haptic device.");
+      return NULL;
+   }
+
+   return SDL_HapticOpen(device_index);
+}
+
+
+/*
+ * Returns SDL_TRUE if joystick has haptic features.
+ */
+int
+SDL_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   int ret;
+
+   /* Must be a valid joystick */
+   if (!SDL_PrivateJoystickValid(&joystick)) {
+      return -1;
+   }
+
+   ret = SDL_SYS_JoystickIsHaptic(joystick);
+
+   if (ret > 0) return SDL_TRUE;
+   else if (ret == 0) return SDL_FALSE;
+   else return -1;
+}
+
+
+/*
+ * Opens a haptic device from a joystick.
+ */
+SDL_Haptic *
+SDL_HapticOpenFromJoystick(SDL_Joystick * joystick)
+{
+   int i;
+   SDL_Haptic *haptic;
+
+   /* Must be a valid joystick */
+   if (!SDL_PrivateJoystickValid(&joystick)) {
+      SDL_SetError("Haptic: Joystick isn't valid.");
+      return NULL;
+   }
+
+   /* Joystick must be haptic */
+   if (SDL_SYS_JoystickIsHaptic(joystick) <= 0) {
+      SDL_SetError("Haptic: Joystick isn't a haptic device.");
+      return NULL;
+   }
+
+   /* Check to see if joystick's haptic is already open */
+   for (i=0; SDL_haptics[i]; i++) {
+      if (SDL_SYS_JoystickSameHaptic(SDL_haptics[i],joystick)) {
+         haptic = SDL_haptics[i];
+         ++haptic->ref_count;
+         return haptic;
+      }
+   }
+
+   /* Create the haptic device */
+   haptic = (SDL_Haptic *) SDL_malloc((sizeof *haptic));
+   if (haptic == NULL) {
+      SDL_OutOfMemory();
+      return NULL;
+   }
+
+   /* Initialize the haptic device */
+   SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+   if (SDL_SYS_HapticOpenFromJoystick(haptic,joystick) < 0) {
+      SDL_free(haptic);
+      return NULL;
+   }
+
+   /* Add haptic to list */
+   ++haptic->ref_count;
+   for (i=0; SDL_haptics[i]; i++)
+      /* Skip to next haptic */ ;
+   SDL_haptics[i] = haptic;
+
+   return haptic;
+}
+
+
+/*
+ * Closes a SDL_Haptic device.
+ */
+void
+SDL_HapticClose(SDL_Haptic * haptic)
+{
+   int i;
+
+   /* Must be valid */
+   if (!ValidHaptic(haptic)) {
+      return;
+   }
+
+   /* Check if it's still in use */
+   if (--haptic->ref_count < 0) {
+      return;
+   }
+
+   /* Close it, properly removing effects if needed */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect != NULL) {
+         SDL_HapticDestroyEffect(haptic,i);
+      }
+   }
+   SDL_SYS_HapticClose(haptic);
+
+   /* Remove from the list */
+   for (i = 0; SDL_haptics[i]; ++i) {
+      if (haptic == SDL_haptics[i]) {
+         SDL_haptics[i] = NULL;
+         SDL_memcpy(&SDL_haptics[i], &SDL_haptics[i + 1],
+               (SDL_numhaptics - i) * sizeof(haptic));
+         break;
+      }
+   }
+
+   /* Free */
+   SDL_free(haptic);
+}
+
+/*
+ * Cleans up after the subsystem.
+ */
+void
+SDL_HapticQuit(void)
+{
+   SDL_SYS_HapticQuit();
+   if (SDL_haptics != NULL) {
+      SDL_free(SDL_haptics);
+      SDL_haptics = NULL;
+   }
+   SDL_numhaptics = 0;
+}
+
+/*
+ * Returns the number of effects a haptic device has.
+ */
+int
+SDL_HapticNumEffects(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return haptic->neffects;
+}
+
+
+/*
+ * Returns the number of effects a haptic device can play.
+ */
+int
+SDL_HapticNumEffectsPlaying(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return haptic->nplaying;
+}
+
+
+/*
+ * Returns supported effects by the device.
+ */
+unsigned int
+SDL_HapticQuery(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return haptic->supported;
+}
+
+
+/*
+ * Returns the number of axis on the device.
+ */
+int
+SDL_HapticNumAxes(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return haptic->naxes;
+}
+
+/*
+ * Checks to see if the device can support the effect.
+ */
+int
+SDL_HapticEffectSupported(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   if ((haptic->supported & effect->type) != 0)
+      return SDL_TRUE;
+   return SDL_FALSE;
+}
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_HapticNewEffect(SDL_Haptic * haptic, SDL_HapticEffect * effect)
+{
+   int i;
+
+   /* Check for device validity. */
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   /* Check to see if effect is supported */
+   if (SDL_HapticEffectSupported(haptic,effect)==SDL_FALSE) {
+      SDL_SetError("Haptic: Effect not supported by haptic device.");
+      return -1;
+   }
+
+   /* See if there's a free slot */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect == NULL) {
+
+         /* Now let the backend create the real effect */
+         if (SDL_SYS_HapticNewEffect(haptic,&haptic->effects[i],effect) != 0) {
+            return -1; /* Backend failed to create effect */
+         }
+
+         SDL_memcpy(&haptic->effects[i].effect, effect, sizeof(SDL_HapticEffect));
+         return i;
+      }
+   }
+
+   SDL_SetError("Haptic: Device has no free space left.");
+   return -1;
+}
+
+/*
+ * Checks to see if an effect is valid.
+ */
+static int
+ValidEffect(SDL_Haptic * haptic, int effect)
+{
+   if ((effect < 0) || (effect >= haptic->neffects)) {
+      SDL_SetError("Haptic: Invalid effect identifier.");
+      return 0;
+   }
+   return 1;
+}
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_HapticUpdateEffect(SDL_Haptic * haptic, int effect, SDL_HapticEffect * data)
+{
+   if (!ValidHaptic(haptic) || !ValidEffect(haptic,effect)) {
+      return -1;
+   }
+
+   /* Can't change type dynamically. */
+   if (data->type != haptic->effects[effect].effect.type) {
+      SDL_SetError("Haptic: Updating effect type is illegal.");
+      return -1;
+   }
+
+   /* Updates the effect */
+   if (SDL_SYS_HapticUpdateEffect(haptic,&haptic->effects[effect],data) < 0) {
+      return -1;
+   }
+
+   SDL_memcpy(&haptic->effects[effect].effect, data, sizeof(SDL_HapticEffect));
+   return 0;
+}
+
+
+/*
+ * Runs the haptic effect on the device.
+ */
+int
+SDL_HapticRunEffect(SDL_Haptic * haptic, int effect, Uint32 iterations)
+{
+   if (!ValidHaptic(haptic) || !ValidEffect(haptic,effect)) {
+      return -1;
+   }
+
+   /* Run the effect */
+   if (SDL_SYS_HapticRunEffect(haptic,&haptic->effects[effect], iterations) < 0) {
+      return -1;
+   }
+
+   return 0;
+}
+
+/*
+ * Stops the haptic effect on the device.
+ */
+int
+SDL_HapticStopEffect(SDL_Haptic * haptic, int effect)
+{
+   if (!ValidHaptic(haptic) || !ValidEffect(haptic,effect)) {
+      return -1;
+   }
+
+   /* Stop the effect */
+   if (SDL_SYS_HapticStopEffect(haptic,&haptic->effects[effect]) < 0) {
+      return -1;
+   }
+
+   return 0;
+}
+
+/*
+ * Gets rid of a haptic effect.
+ */
+void
+SDL_HapticDestroyEffect(SDL_Haptic * haptic, int effect)
+{
+   if (!ValidHaptic(haptic) || !ValidEffect(haptic,effect)) {
+      return;
+   }
+
+   /* Not allocated */
+   if (haptic->effects[effect].hweffect == NULL) {
+      return;
+   }
+
+   SDL_SYS_HapticDestroyEffect(haptic, &haptic->effects[effect]);
+}
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_HapticGetEffectStatus(SDL_Haptic *haptic, int effect)
+{
+   if (!ValidHaptic(haptic) || !ValidEffect(haptic,effect)) {
+      return -1;
+   }
+
+   if ((haptic->supported & SDL_HAPTIC_STATUS) == 0) {
+      SDL_SetError("Haptic: Device does not support status queries.");
+      return -1;
+   }
+
+   return SDL_SYS_HapticGetEffectStatus(haptic, &haptic->effects[effect]);
+}
+
+/*
+ * Sets the global gain of the device.
+ */
+int
+SDL_HapticSetGain(SDL_Haptic * haptic, int gain )
+{
+   const char *env;
+   int real_gain, max_gain;
+
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   if ((haptic->supported & SDL_HAPTIC_GAIN) == 0) {
+      SDL_SetError("Haptic: Device does not support setting gain.");
+      return -1;
+   }
+
+   if ((gain < 0) || (gain > 100)) {
+      SDL_SetError("Haptic: Gain must be between 0 and 100.");
+      return -1;
+   }
+
+   /* We use the envvar to get the maximum gain. */
+   env = SDL_getenv("SDL_HAPTIC_GAIN_MAX");
+   if (env != NULL) {
+      max_gain = SDL_atoi(env);
+
+      /* Check for sanity. */
+      if (max_gain < 0) max_gain = 0;
+      else if (max_gain > 100) max_gain = 100;
+
+      /* We'll scale it linearly with SDL_HAPTIC_GAIN_MAX */
+      real_gain = (gain * max_gain) / 100;
+   }
+   else {
+      real_gain = gain;
+   }
+
+   if (SDL_SYS_HapticSetGain(haptic,real_gain) < 0) {
+      return -1;
+   }
+
+   return 0;
+}
+
+/*
+ * Makes the device autocenter, 0 disables.
+ */
+int
+SDL_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter )
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   if ((haptic->supported & SDL_HAPTIC_AUTOCENTER) == 0) {
+      SDL_SetError("Haptic: Device does not support setting autocenter.");
+      return -1;
+   }
+
+   if ((autocenter < 0) || (autocenter > 100)) {
+      SDL_SetError("Haptic: Autocenter must be between 0 and 100.");
+      return -1;
+   }                                           
+
+   if (SDL_SYS_HapticSetAutocenter(haptic,autocenter) < 0) {
+      return -1;
+   }
+
+   return 0;
+}
+
+/*
+ * Pauses the haptic device.
+ */
+int
+SDL_HapticPause(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   if ((haptic->supported & SDL_HAPTIC_PAUSE) == 0) {
+      SDL_SetError("Haptic: Device does not support setting pausing.");
+      return -1;
+   }
+
+   return SDL_SYS_HapticPause(haptic);
+}
+
+/*
+ * Unpauses the haptic device.
+ */
+int
+SDL_HapticUnpause(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   if ((haptic->supported & SDL_HAPTIC_PAUSE) == 0) {
+      return 0; /* Not going to be paused, so we pretend it's unpaused. */
+   }
+
+   return SDL_SYS_HapticUnpause(haptic);
+}
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_HapticStopAll(SDL_Haptic * haptic)
+{
+   if (!ValidHaptic(haptic)) {
+      return -1;
+   }
+
+   return SDL_SYS_HapticStopAll(haptic);
+}
diff -ruN SDL-1.2.13/src/haptic/SDL_syshaptic.h SDL-1.2.13_OOx64/src/haptic/SDL_syshaptic.h
--- SDL-1.2.13/src/haptic/SDL_syshaptic.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/SDL_syshaptic.h	2017-12-18 15:12:00 +0000
@@ -0,0 +1,202 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#include "SDL_config.h"
+
+#include "SDL_haptic.h"
+
+
+/*
+ * Number of haptic devices on the system.
+ */
+extern Uint8 SDL_numhaptics;
+
+
+struct haptic_effect
+{
+   SDL_HapticEffect effect; /* The current event */
+   struct haptic_hweffect *hweffect; /* The hardware behind the event */
+};
+
+/*
+ * The real SDL_Haptic struct.
+ */
+struct _SDL_Haptic
+{  
+   Uint8 index; /* Stores index it is attached to */
+
+   struct haptic_effect *effects; /* Allocated effects */
+   int neffects; /* Maximum amount of effects */
+   int nplaying; /* Maximum amount of effects to play at the same time */
+   unsigned int supported; /* Supported effects */
+   int naxes; /* Number of axes on the device. */
+
+   struct haptic_hwdata *hwdata; /* Driver dependent */
+   int ref_count; /* Count for multiple opens */
+};
+
+/* 
+ * Scans the system for haptic devices.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticInit(void);
+
+/*
+ * Gets the device dependent name of the haptic device
+ */
+extern const char * SDL_SYS_HapticName(int index);
+
+/*
+ * Opens the haptic device for usage.  The haptic device should have
+ * the index value set previously.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticOpen(SDL_Haptic * haptic);
+
+/*
+ * Returns the index of the haptic core pointer or -1 if none is found.
+ */
+int SDL_SYS_HapticMouse(void);
+
+/*
+ * Checks to see if the joystick has haptic capabilities.
+ *
+ * Returns >0 if haptic capabilities are detected, 0 if haptic
+ * capabilities aren't detected and -1 on error.
+ */
+extern int SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick);
+
+/*
+ * Opens the haptic device for usage using the same device as
+ * the joystick.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic,
+                                          SDL_Joystick * joystick);
+/*
+ * Checks to see if haptic device and joystick device are the same.
+ *
+ * Returns 1 if they are the same, 0 if they aren't.
+ */
+extern int SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic,
+                                      SDL_Joystick * joystick);
+
+/*
+ * Closes a haptic device after usage.
+ */
+extern void SDL_SYS_HapticClose(SDL_Haptic * haptic);
+
+/*
+ * Performs a cleanup on the haptic subsystem.
+ */
+extern void SDL_SYS_HapticQuit(void);
+
+/*
+ * Creates a new haptic effect on the haptic device using base
+ * as a template for the effect.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                                 struct haptic_effect * effect,
+                                 SDL_HapticEffect * base);
+
+/*
+ * Updates the haptic effect on the haptic device using data
+ * as a template.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                                      struct haptic_effect * effect,
+                                      SDL_HapticEffect * data);
+
+/*
+ * Runs the effect on the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticRunEffect(SDL_Haptic * haptic,
+                                   struct haptic_effect * effect,
+                                   Uint32 iterations);
+
+/*
+ * Stops the effect on the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticStopEffect(SDL_Haptic * haptic,
+                                    struct haptic_effect * effect);
+
+/*
+ * Cleanups up the effect on the haptic device.
+ */
+extern void SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic,
+                                        struct haptic_effect * effect);
+
+/*
+ * Queries the device for the status of effect.
+ *
+ * Returns 0 if device is stopped, >0 if device is playing and
+ * -1 on error.
+ */
+extern int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic,
+                                         struct haptic_effect * effect);
+
+/*
+ * Sets the global gain of the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain);
+
+/*
+ * Sets the autocenter feature of the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic,
+                                       int autocenter);
+
+/*
+ * Pauses the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticPause(SDL_Haptic * haptic);
+
+/*
+ * Unpauses the haptic device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticUnpause(SDL_Haptic * haptic);
+
+/*
+ * Stops all the currently playing haptic effects on the device.
+ *
+ * Returns 0 on success, -1 on error.
+ */
+extern int SDL_SYS_HapticStopAll(SDL_Haptic * haptic);
diff -ruN SDL-1.2.13/src/haptic/darwin/SDL_syshaptic.c SDL-1.2.13_OOx64/src/haptic/darwin/SDL_syshaptic.c
--- SDL-1.2.13/src/haptic/darwin/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/darwin/SDL_syshaptic.c	2017-12-18 15:08:54 +0000
@@ -0,0 +1,1284 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_IOKIT
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/darwin/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <IOKit/IOKitLib.h>
+#include <IOKit/hid/IOHIDKeys.h>
+#include <ForceFeedback/ForceFeedback.h>
+#include <ForceFeedback/ForceFeedbackConstants.h>
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char name[256]; /* Name of the device. */
+
+   io_service_t dev; /* Node we use to create the device. */
+   SDL_Haptic *haptic; /* Haptic currently assosciated with it. */
+   
+   /* Usage pages for determining if it's a mouse or not. */
+   long usage;
+   long usagePage;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   FFDeviceObjectReference device; /* Hardware device. */
+   UInt8 axes[3];
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   FFEffectObjectReference ref; /* Reference. */
+   struct FFEFFECT effect; /* Hardware effect. */
+};
+
+/*
+ * Prototypes.
+ */
+static void SDL_SYS_HapticFreeFFEFFECT(FFEFFECT * effect, int type);
+static int HIDGetDeviceProduct(io_service_t dev, char * name);
+
+
+/* 
+ * Like strerror but for force feedback errors.
+ */
+static const char *
+FFStrError(HRESULT err)
+{
+   switch (err) {
+      case FFERR_DEVICEFULL:
+         return "device full";
+      /* This should be valid, but for some reason isn't defined... */
+      /*case FFERR_DEVICENOTREG:
+         return "device not registered";*/
+      case FFERR_DEVICEPAUSED:
+         return "device paused";
+      case FFERR_DEVICERELEASED:
+         return "device released";
+      case FFERR_EFFECTPLAYING:
+         return "effect playing";
+      case FFERR_EFFECTTYPEMISMATCH:
+         return "effect type mismatch";
+      case FFERR_EFFECTTYPENOTSUPPORTED:
+         return "effect type not supported";
+      case FFERR_GENERIC:
+         return "undetermined error";
+      case FFERR_HASEFFECTS:
+         return "device has effects";
+      case FFERR_INCOMPLETEEFFECT:
+         return "incomplete effect";
+      case FFERR_INTERNAL:
+         return "internal fault";
+      case FFERR_INVALIDDOWNLOADID:
+         return "invalid download id";
+      case FFERR_INVALIDPARAM:
+         return "invalid parameter";
+      case FFERR_MOREDATA:
+         return "more data";
+      case FFERR_NOINTERFACE:
+         return "interface not supported";
+      case FFERR_NOTDOWNLOADED:
+         return "effect is not downloaded";
+      case FFERR_NOTINITIALIZED:
+         return "object has not been initialized";
+      case FFERR_OUTOFMEMORY:
+         return "out of memory";
+      case FFERR_UNPLUGGED:
+         return "device is unplugged";
+      case FFERR_UNSUPPORTED:
+         return "function call unsupported";
+      case FFERR_UNSUPPORTEDAXIS:
+         return "axis unsupported";
+
+      default:
+         return "unknown error";
+   }
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   int numhaptics;
+   IOReturn result;
+   io_iterator_t iter;
+   CFDictionaryRef match;
+   io_service_t device;
+   CFMutableDictionaryRef hidProperties;
+   CFTypeRef refCF;
+
+   /* Clear all the memory. */
+   SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+   /* Get HID devices. */
+   match = IOServiceMatching(kIOHIDDeviceKey);
+   if (match == NULL) {
+      SDL_SetError("Haptic: Failed to get IOServiceMatching.");
+      return -1;
+   }
+
+   /* Now search I/O Registry for matching devices. */
+   result = IOServiceGetMatchingServices(kIOMasterPortDefault, match, &iter);
+   if (result != kIOReturnSuccess) {
+      SDL_SetError("Haptic: Couldn't create a HID object iterator.");
+      return -1;
+   }
+   /* IOServiceGetMatchingServices consumes dictionary. */
+
+   if (!IOIteratorIsValid(iter)) { /* No iterator. */
+      numhaptics = 0;
+      return 0;
+   }
+
+   numhaptics = 0;
+   while ((device = IOIteratorNext(iter)) != IO_OBJECT_NULL) {
+
+      /* Check for force feedback. */
+      if (FFIsForceFeedback(device) == FF_OK) {
+
+         /* Set basic device data. */
+         HIDGetDeviceProduct(device, SDL_hapticlist[numhaptics].name);
+         SDL_hapticlist[numhaptics].dev = device;
+         SDL_hapticlist[numhaptics].haptic = NULL;
+
+         /* Set usage pages. */
+         hidProperties = 0;
+         refCF = 0;
+         result = IORegistryEntryCreateCFProperties(device,
+               &hidProperties, kCFAllocatorDefault, kNilOptions);
+         if ((result == KERN_SUCCESS) && hidProperties) {
+            refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
+            if (refCF) {
+               if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                     &SDL_hapticlist[numhaptics].usagePage))
+                  SDL_SetError("Haptic: Recieving device's usage page.");
+               refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
+               if (refCF) {
+                  if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                        &SDL_hapticlist[numhaptics].usage))
+                     SDL_SetError("Haptic: Recieving device's usage.");
+               }
+            }
+            CFRelease(hidProperties);
+         }
+
+         /* Device has been added. */
+         numhaptics++;
+      }
+      else { /* Free the unused device. */
+         IOObjectRelease(device);
+      }
+
+      /* Reached haptic limit. */
+      if (numhaptics >= MAX_HAPTICS)
+         break;
+   }
+   IOObjectRelease(iter);
+
+   return numhaptics;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   return SDL_hapticlist[index].name;
+}
+
+/*
+ * Gets the device's product name.
+ */
+static int
+HIDGetDeviceProduct(io_service_t dev, char *name)
+{
+   CFMutableDictionaryRef hidProperties, usbProperties;
+   io_registry_entry_t parent1, parent2;
+   kern_return_t ret;
+
+   hidProperties = usbProperties = 0;
+
+   ret = IORegistryEntryCreateCFProperties(dev, &hidProperties,
+                                           kCFAllocatorDefault,
+                                           kNilOptions);
+   if ((ret != KERN_SUCCESS) || !hidProperties) {
+      SDL_SetError("Haptic: Unable to create CFProperties.");
+      return -1;
+   }
+
+   /* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
+    * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
+    */
+   if ((KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(dev, kIOServicePlane, &parent1))
+         && (KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(parent1, kIOServicePlane, &parent2))
+         && (KERN_SUCCESS ==
+            IORegistryEntryCreateCFProperties(parent2, &usbProperties,
+                                              kCFAllocatorDefault,
+                                              kNilOptions))) {
+      if (usbProperties) {
+         CFTypeRef refCF = 0;
+         /* get device info
+          * try hid dictionary first, if fail then go to usb dictionary
+          */
+
+
+         /* Get product name */
+         refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDProductKey));
+         if (!refCF)
+            refCF =
+               CFDictionaryGetValue(usbProperties, CFSTR("USB Product Name"));
+         if (refCF) {
+            if (!CFStringGetCString(refCF, name, 256,
+                                    CFStringGetSystemEncoding())) {
+               SDL_SetError("Haptic: CFStringGetCString error retrieving pDevice->product.");
+               return -1;
+            }
+         }
+
+         CFRelease(usbProperties);
+      }
+      else {
+         SDL_SetError("Haptic: IORegistryEntryCreateCFProperties failed to create usbProperties.");
+         return -1;
+      }
+
+      /* Release stuff. */
+      if (kIOReturnSuccess != IOObjectRelease(parent2)) {
+         SDL_SetError("Haptic: IOObjectRelease error with parent2.");
+      }
+      if (kIOReturnSuccess != IOObjectRelease(parent1))  {
+         SDL_SetError("Haptic: IOObjectRelease error with parent1.");
+      }
+   }
+   else {
+      SDL_SetError("Haptic: Error getting registry entries.");
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#define FF_TEST(ff, s) \
+if (features.supportedEffects & (ff)) supported |= (s)
+/*
+ * Gets supported features.
+ */
+static unsigned int
+GetSupportedFeatures(SDL_Haptic* haptic)
+{
+   HRESULT ret;
+   FFDeviceObjectReference device;
+   FFCAPABILITIES features;
+   unsigned int supported;
+   Uint32 val;
+
+   device = haptic->hwdata->device;
+
+   ret = FFDeviceGetForceFeedbackCapabilities(device, &features);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get device's supported features.");
+      return -1;
+   }
+
+   supported = 0;
+
+   /* Get maximum effects. */
+   haptic->neffects = features.storageCapacity;
+   haptic->nplaying = features.playbackCapacity;
+
+   /* Test for effects. */
+   FF_TEST(FFCAP_ET_CONSTANTFORCE, SDL_HAPTIC_CONSTANT);
+   FF_TEST(FFCAP_ET_RAMPFORCE,     SDL_HAPTIC_RAMP);
+   FF_TEST(FFCAP_ET_SQUARE,        SDL_HAPTIC_SQUARE);
+   FF_TEST(FFCAP_ET_SINE,          SDL_HAPTIC_SINE);
+   FF_TEST(FFCAP_ET_TRIANGLE,      SDL_HAPTIC_TRIANGLE);
+   FF_TEST(FFCAP_ET_SAWTOOTHUP,    SDL_HAPTIC_SAWTOOTHUP);
+   FF_TEST(FFCAP_ET_SAWTOOTHDOWN,  SDL_HAPTIC_SAWTOOTHDOWN);
+   FF_TEST(FFCAP_ET_SPRING,        SDL_HAPTIC_SPRING);
+   FF_TEST(FFCAP_ET_DAMPER,        SDL_HAPTIC_DAMPER);
+   FF_TEST(FFCAP_ET_INERTIA,       SDL_HAPTIC_INERTIA);
+   FF_TEST(FFCAP_ET_FRICTION,      SDL_HAPTIC_FRICTION);
+   FF_TEST(FFCAP_ET_CUSTOMFORCE,   SDL_HAPTIC_CUSTOM);
+
+   /* Check if supports gain. */
+   ret = FFDeviceGetForceFeedbackProperty( device, FFPROP_FFGAIN,
+                                           &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_GAIN;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports gain: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Checks if supports autocenter. */
+   ret = FFDeviceGetForceFeedbackProperty(device, FFPROP_AUTOCENTER,
+                                          &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_AUTOCENTER;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports autocenter: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Check for axes, we have an artificial limit on axes */
+   haptic->naxes = ((features.numFfAxes) > 3) ?
+         3 : features.numFfAxes;
+   /* Actually store the axes we want to use */
+   SDL_memcpy( haptic->hwdata->axes, features.ffAxes, haptic->naxes * sizeof(Uint8));
+
+   /* Always supported features. */
+   supported |= SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+   haptic->supported = supported;
+   return 0;;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromService(SDL_Haptic * haptic, io_service_t service)
+{
+   HRESULT ret;
+   int ret2;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto creat_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+  
+   /* Open the device */
+   ret = FFCreateDevice( service, &haptic->hwdata->device);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create device from service: %s.",
+                   FFStrError(ret));
+      goto creat_err;
+   }
+
+   /* Get supported features. */
+   ret2 = GetSupportedFeatures( haptic );
+   if (haptic->supported < 0) {
+      goto open_err;
+   }
+
+
+   /* Reset and then enable actuators. */
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_RESET );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to reset device: %s.", FFStrError(ret));
+      goto open_err;
+   }
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_SETACTUATORSON  );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to enable actuators: %s.", FFStrError(ret));
+      goto open_err;
+   }
+
+
+   /* Allocate effects memory. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+   
+   return 0;
+   
+   /* Error handling */
+open_err:
+   FFReleaseDevice(haptic->hwdata->device);
+creat_err:
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;                                              
+   }
+   return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                SDL_hapticlist[haptic->index].dev);
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+      if ((SDL_hapticlist[i].usagePage == kHIDPage_GenericDesktop) &&
+            (SDL_hapticlist[i].usage == kHIDUsage_GD_Mouse))
+         return i;
+   }
+
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   if (joystick->hwdata->ffservice != 0)
+      return SDL_TRUE;
+   return SDL_FALSE;
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   if (IOObjectIsEqualTo((io_object_t) haptic->hwdata->device,
+                                       joystick->hwdata->ffservice))
+      return 1;
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                joystick->hwdata->ffservice);
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free Effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      FFReleaseDevice(haptic->hwdata->device);
+
+      /* Free */
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; i < SDL_numhaptics; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      /* Free the io_service_t */
+      IOObjectRelease(SDL_hapticlist[i].dev);
+   }
+}
+
+
+/*
+ * Converts an SDL trigger button to an FFEFFECT trigger button.
+ */
+static DWORD
+FFGetTriggerButton( Uint16 button )
+{
+   DWORD dwTriggerButton;
+
+   dwTriggerButton = FFEB_NOTRIGGER;
+
+   if (button != 0) {
+      dwTriggerButton = FFJOFS_BUTTON(button - 1);
+   }
+
+   return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection( FFEFFECT * effect, SDL_HapticDirection *dir, int naxes )
+{
+   LONG *rglDir;
+
+   /* Handle no axes a part. */
+   if (naxes == 0) {
+      effect->dwFlags |= FFEFF_SPHERICAL; /* Set as default. */
+      effect->rglDirection = NULL;
+      return 0;
+   }
+
+   /* Has axes. */
+   rglDir = SDL_malloc( sizeof(LONG) * naxes );
+   if (rglDir == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset( rglDir, 0, sizeof(LONG) * naxes );
+   effect->rglDirection = rglDir;
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         effect->dwFlags |= FFEFF_POLAR;
+         rglDir[0] = dir->dir[0];
+         return 0;
+      case SDL_HAPTIC_CARTESIAN:
+         effect->dwFlags |= FFEFF_CARTESIAN;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+      case SDL_HAPTIC_SPHERICAL:
+         effect->dwFlags |= FFEFF_SPHERICAL;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+
+      default:
+         SDL_SetError("Haptic: Unknown direction type.");
+         return -1;
+   }
+}
+
+
+/* Clamps and converts. */
+#define CCONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/* Just converts. */
+#define CONVERT(x)    (((x)*10000) / 0x7FFF)
+/*
+ * Creates the FFEFFECT from a SDL_HapticEffect.
+ */
+static int
+SDL_SYS_ToFFEFFECT( SDL_Haptic * haptic, FFEFFECT * dest, SDL_HapticEffect * src )
+{
+   int i;
+   FFCONSTANTFORCE *constant;
+   FFPERIODIC *periodic;
+   FFCONDITION *condition; /* Actually an array of conditions - one per axis. */
+   FFRAMPFORCE *ramp;
+   FFCUSTOMFORCE *custom;
+   FFENVELOPE *envelope;
+   SDL_HapticConstant *hap_constant;
+   SDL_HapticPeriodic *hap_periodic;
+   SDL_HapticCondition *hap_condition;
+   SDL_HapticRamp *hap_ramp;
+   SDL_HapticCustom *hap_custom;
+   DWORD *axes;
+
+   /* Set global stuff. */
+   SDL_memset(dest, 0, sizeof(FFEFFECT));
+   dest->dwSize = sizeof(FFEFFECT); /* Set the structure size. */
+   dest->dwSamplePeriod = 0; /* Not used by us. */
+   dest->dwGain = 10000; /* Gain is set globally, not locally. */
+   dest->dwFlags = FFEFF_OBJECTOFFSETS; /* Seems obligatory. */
+
+   /* Envelope. */
+   envelope = SDL_malloc( sizeof(FFENVELOPE) );
+   if (envelope == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(envelope, 0, sizeof(FFENVELOPE));
+   dest->lpEnvelope = envelope;
+   envelope->dwSize = sizeof(FFENVELOPE); /* Always should be this. */
+
+   /* Axes. */
+   dest->cAxes = haptic->naxes;
+   if (dest->cAxes > 0) {
+      axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+      if (axes == NULL) {
+         SDL_OutOfMemory();
+         return -1;
+      }
+      axes[0] = haptic->hwdata->axes[0]; /* Always at least one axis. */
+      if (dest->cAxes > 1) {
+         axes[1] = haptic->hwdata->axes[1];
+      }
+      if (dest->cAxes > 2) {
+         axes[2] = haptic->hwdata->axes[2];
+      }
+      dest->rgdwAxes = axes;
+   }
+
+
+   /* The big type handling switch, even bigger then linux's version. */
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         hap_constant = &src->constant;
+         constant = SDL_malloc( sizeof(FFCONSTANTFORCE) );
+         if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(constant, 0, sizeof(FFCONSTANTFORCE));
+
+         /* Specifics */
+         constant->lMagnitude = CONVERT(hap_constant->level);
+         dest->cbTypeSpecificParams = sizeof(FFCONSTANTFORCE); 
+         dest->lpvTypeSpecificParams = constant;
+
+         /* Generics */
+         dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_constant->button);
+         dest->dwTriggerRepeatInterval = hap_constant->interval;
+         dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_constant->attack_length==0) && (hap_constant->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         hap_periodic = &src->periodic;
+         periodic = SDL_malloc(sizeof(FFPERIODIC));
+         if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(periodic, 0, sizeof(FFPERIODIC));
+
+         /* Specifics */
+         periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+         periodic->lOffset = CONVERT(hap_periodic->offset);
+         periodic->dwPhase = hap_periodic->phase;
+         periodic->dwPeriod = hap_periodic->period * 1000;
+         dest->cbTypeSpecificParams = sizeof(FFPERIODIC);
+         dest->lpvTypeSpecificParams = periodic;
+
+         /* Generics */
+         dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_periodic->button);
+         dest->dwTriggerRepeatInterval = hap_periodic->interval;
+         dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+         
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_periodic->attack_length==0) && (hap_periodic->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         hap_condition = &src->condition;
+         condition = SDL_malloc(sizeof(FFCONDITION) * dest->cAxes);
+         if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(condition, 0, sizeof(FFCONDITION));
+
+         /* Specifics */
+         for (i=0; i<dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient = CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient = CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation = CCONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation = CCONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CCONVERT(hap_condition->deadband[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCONDITION) * dest->cAxes;
+         dest->lpvTypeSpecificParams = condition;
+
+         /* Generics */
+         dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_condition->button);
+         dest->dwTriggerRepeatInterval = hap_condition->interval;
+         dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
+            return -1;                
+         }                            
+                                      
+         /* Envelope - Not actually supported by most CONDITION implementations. */
+         SDL_free(dest->lpEnvelope);
+         dest->lpEnvelope = NULL;
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         hap_ramp = &src->ramp;
+         ramp = SDL_malloc(sizeof(FFRAMPFORCE));
+         if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(ramp, 0, sizeof(FFRAMPFORCE));
+
+         /* Specifics */
+         ramp->lStart = CONVERT(hap_ramp->start);
+         ramp->lEnd = CONVERT(hap_ramp->end);
+         dest->cbTypeSpecificParams = sizeof(FFRAMPFORCE);
+         dest->lpvTypeSpecificParams = ramp;
+
+         /* Generics */
+         dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_ramp->button);
+         dest->dwTriggerRepeatInterval = hap_ramp->interval;
+         dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+
+         /* Envelope */
+         if ((hap_ramp->attack_length==0) && (hap_ramp->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_CUSTOM:
+         hap_custom = &src->custom;
+         custom = SDL_malloc(sizeof(FFCUSTOMFORCE));
+         if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(custom, 0, sizeof(FFCUSTOMFORCE));
+
+         /* Specifics */
+         custom->cChannels = hap_custom->channels;
+         custom->dwSamplePeriod = hap_custom->period * 1000;
+         custom->cSamples = hap_custom->samples;
+         custom->rglForceData = SDL_malloc(sizeof(LONG)*custom->cSamples*custom->cChannels);
+         for (i=0; i<hap_custom->samples*hap_custom->channels; i++) { /* Copy data. */
+            custom->rglForceData[i] = CCONVERT(hap_custom->data[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCUSTOMFORCE);
+         dest->lpvTypeSpecificParams = custom;
+
+         /* Generics */
+         dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_custom->button);
+         dest->dwTriggerRepeatInterval = hap_custom->interval;
+         dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_custom->attack_length==0) && (hap_custom->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+         }
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees an FFEFFECT allocated by SDL_SYS_ToFFEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeFFEFFECT( FFEFFECT * effect, int type )
+{
+   FFCUSTOMFORCE *custom;
+
+   if (effect->lpEnvelope != NULL) {
+      SDL_free(effect->lpEnvelope);
+      effect->lpEnvelope = NULL;
+   }
+   if (effect->rgdwAxes != NULL) {
+      SDL_free(effect->rgdwAxes);
+      effect->rgdwAxes = NULL;
+   }
+   if (effect->lpvTypeSpecificParams != NULL) {
+      if (type == SDL_HAPTIC_CUSTOM) { /* Must free the custom data. */
+         custom = (FFCUSTOMFORCE*) effect->lpvTypeSpecificParams;
+         SDL_free(custom->rglForceData);
+         custom->rglForceData = NULL;
+      }
+      SDL_free(effect->lpvTypeSpecificParams);
+      effect->lpvTypeSpecificParams = NULL;
+   }
+   if (effect->rglDirection != NULL) {
+      SDL_free(effect->rglDirection);
+      effect->rglDirection = NULL;
+   }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+CFUUIDRef
+SDL_SYS_HapticEffectType( Uint16 type )
+{
+   switch (type) {
+      case SDL_HAPTIC_CONSTANT:
+         return kFFEffectType_ConstantForce_ID;
+
+      case SDL_HAPTIC_RAMP:
+         return kFFEffectType_RampForce_ID;
+
+      case SDL_HAPTIC_SQUARE:
+         return kFFEffectType_Square_ID;
+
+      case SDL_HAPTIC_SINE:
+         return kFFEffectType_Sine_ID;
+
+      case SDL_HAPTIC_TRIANGLE:
+         return kFFEffectType_Triangle_ID;
+
+      case SDL_HAPTIC_SAWTOOTHUP:
+         return kFFEffectType_SawtoothUp_ID;
+
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         return kFFEffectType_SawtoothDown_ID;
+
+      case SDL_HAPTIC_SPRING:
+         return kFFEffectType_Spring_ID;
+
+      case SDL_HAPTIC_DAMPER:
+         return kFFEffectType_Damper_ID;
+
+      case SDL_HAPTIC_INERTIA:
+         return kFFEffectType_Inertia_ID;
+
+      case SDL_HAPTIC_FRICTION:
+         return kFFEffectType_Friction_ID;
+
+      case SDL_HAPTIC_CUSTOM:
+         return kFFEffectType_CustomForce_ID;
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return NULL;
+   }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   HRESULT ret;
+   CFUUIDRef type;
+
+   /* Alloc the effect. */
+   effect->hweffect = (struct haptic_hweffect *)
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      goto err_hweffect;
+   }
+
+   /* Get the type. */
+   type = SDL_SYS_HapticEffectType(base->type);
+   if (type == NULL) {
+      goto err_hweffect;
+   }
+
+   /* Get the effect. */
+   if (SDL_SYS_ToFFEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+      goto err_effectdone;
+   }
+
+   /* Create the actual effect. */
+   ret = FFDeviceCreateEffect(haptic->hwdata->device, type,
+         &effect->hweffect->effect, &effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create effect: %s.", FFStrError(ret));
+      goto err_effectdone;
+   }
+
+   return 0;
+
+err_effectdone:
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, base->type);
+err_hweffect:
+   if (effect->hweffect != NULL) {
+      SDL_free(effect->hweffect);
+      effect->hweffect = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   HRESULT ret;
+   FFEffectParameterFlag flags;
+   FFEFFECT temp;
+
+   /* Get the effect. */
+   SDL_memset(&temp, 0, sizeof(FFEFFECT));
+   if (SDL_SYS_ToFFEFFECT(haptic, &temp, data) < 0) {
+      goto err_update;
+   }
+
+   /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+    *  only change those parameters. */
+   flags = FFEP_DIRECTION |
+           FFEP_DURATION |
+           FFEP_ENVELOPE |
+           FFEP_STARTDELAY |
+           FFEP_TRIGGERBUTTON |
+           FFEP_TRIGGERREPEATINTERVAL |
+           FFEP_TYPESPECIFICPARAMS;
+
+   /* Create the actual effect. */
+   ret = FFEffectSetParameters(effect->hweffect->ref, &temp, flags);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to update effect: %s.", FFStrError(ret));
+      goto err_update;
+   }
+
+   /* Copy it over. */
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, data->type);
+   SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(FFEFFECT));
+
+   return 0;
+
+err_update:
+   SDL_SYS_HapticFreeFFEFFECT(&temp, data->type);
+   return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   HRESULT ret;
+   Uint32 iter;
+
+   /* Check if it's infinite. */
+   if (iterations == SDL_HAPTIC_INFINITY) {
+      iter = FF_INFINITE;
+   }
+   else
+      iter = iterations;
+
+   /* Run the effect. */
+   ret = FFEffectStart(effect->hweffect->ref, iter, 0);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to run the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFEffectStop(effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFDeviceReleaseEffect(haptic->hwdata->device, effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s.",
+                   FFStrError(ret));
+   }
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, effect->effect.type);
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+   FFEffectStatusFlag status;
+
+   ret = FFEffectGetEffectStatus(effect->hweffect->ref, &status);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get effect status: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   if (status == 0) return SDL_FALSE;
+   return SDL_TRUE; /* Assume it's playing or emulated. */
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   val = gain * 100; /* Mac OS X uses 0 to 10,000 */
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device, FFPROP_FFGAIN, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting gain: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   /* Mac OS X only has 0 (off) and 1 (on) */
+   if (autocenter == 0) val = 0;
+   else val = 1;
+
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device,
+               FFPROP_AUTOCENTER, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting autocenter: %s.", FFStrError(ret));
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_PAUSE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Unpauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_CONTINUE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops all currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_STOPALL); 
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error stopping device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_IOKIT */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/haptic/darwin/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/haptic/darwin/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/haptic/darwin/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/darwin/SDL_syshaptic.c.bak	2017-12-18 13:27:38 +0000
@@ -0,0 +1,1284 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_IOKIT
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/darwin/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <IOKit/IOKitLib.h>
+#include <IOKit/hid/IOHIDKeys.h>
+#include <ForceFeedback/ForceFeedback.h>
+#include <ForceFeedback/ForceFeedbackConstants.h>
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char name[256]; /* Name of the device. */
+
+   io_service_t dev; /* Node we use to create the device. */
+   SDL_Haptic *haptic; /* Haptic currently assosciated with it. */
+   
+   /* Usage pages for determining if it's a mouse or not. */
+   long usage;
+   long usagePage;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   FFDeviceObjectReference device; /* Hardware device. */
+   UInt8 axes[3];
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   FFEffectObjectReference ref; /* Reference. */
+   struct FFEFFECT effect; /* Hardware effect. */
+};
+
+/*
+ * Prototypes.
+ */
+static void SDL_SYS_HapticFreeFFEFFECT(FFEFFECT * effect, int type);
+static int HIDGetDeviceProduct(io_service_t dev, char * name);
+
+
+/* 
+ * Like strerror but for force feedback errors.
+ */
+static const char *
+FFStrError(HRESULT err)
+{
+   switch (err) {
+      case FFERR_DEVICEFULL:
+         return "device full";
+      /* This should be valid, but for some reason isn't defined... */
+      /*case FFERR_DEVICENOTREG:
+         return "device not registered";*/
+      case FFERR_DEVICEPAUSED:
+         return "device paused";
+      case FFERR_DEVICERELEASED:
+         return "device released";
+      case FFERR_EFFECTPLAYING:
+         return "effect playing";
+      case FFERR_EFFECTTYPEMISMATCH:
+         return "effect type mismatch";
+      case FFERR_EFFECTTYPENOTSUPPORTED:
+         return "effect type not supported";
+      case FFERR_GENERIC:
+         return "undetermined error";
+      case FFERR_HASEFFECTS:
+         return "device has effects";
+      case FFERR_INCOMPLETEEFFECT:
+         return "incomplete effect";
+      case FFERR_INTERNAL:
+         return "internal fault";
+      case FFERR_INVALIDDOWNLOADID:
+         return "invalid download id";
+      case FFERR_INVALIDPARAM:
+         return "invalid parameter";
+      case FFERR_MOREDATA:
+         return "more data";
+      case FFERR_NOINTERFACE:
+         return "interface not supported";
+      case FFERR_NOTDOWNLOADED:
+         return "effect is not downloaded";
+      case FFERR_NOTINITIALIZED:
+         return "object has not been initialized";
+      case FFERR_OUTOFMEMORY:
+         return "out of memory";
+      case FFERR_UNPLUGGED:
+         return "device is unplugged";
+      case FFERR_UNSUPPORTED:
+         return "function call unsupported";
+      case FFERR_UNSUPPORTEDAXIS:
+         return "axis unsupported";
+
+      default:
+         return "unknown error";
+   }
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   int numhaptics;
+   IOReturn result;
+   io_iterator_t iter;
+   CFDictionaryRef match;
+   io_service_t device;
+   CFMutableDictionaryRef hidProperties;
+   CFTypeRef refCF;
+
+   /* Clear all the memory. */
+   SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+   /* Get HID devices. */
+   match = IOServiceMatching(kIOHIDDeviceKey);
+   if (match == NULL) {
+      SDL_SetError("Haptic: Failed to get IOServiceMatching.");
+      return -1;
+   }
+
+   /* Now search I/O Registry for matching devices. */
+   result = IOServiceGetMatchingServices(kIOMasterPortDefault, match, &iter);
+   if (result != kIOReturnSuccess) {
+      SDL_SetError("Haptic: Couldn't create a HID object iterator.");
+      return -1;
+   }
+   /* IOServiceGetMatchingServices consumes dictionary. */
+
+   if (!IOIteratorIsValid(iter)) { /* No iterator. */
+      numhaptics = 0;
+      return 0;
+   }
+
+   numhaptics = 0;
+   while ((device = IOIteratorNext(iter)) != IO_OBJECT_NULL) {
+
+      /* Check for force feedback. */
+      if (FFIsForceFeedback(device) == FF_OK) {
+
+         /* Set basic device data. */
+         HIDGetDeviceProduct(device, SDL_hapticlist[numhaptics].name);
+         SDL_hapticlist[numhaptics].dev = device;
+         SDL_hapticlist[numhaptics].haptic = NULL;
+
+         /* Set usage pages. */
+         hidProperties = 0;
+         refCF = 0;
+         result = IORegistryEntryCreateCFProperties(device,
+               &hidProperties, kCFAllocatorDefault, kNilOptions);
+         if ((result == KERN_SUCCESS) && hidProperties) {
+            refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
+            if (refCF) {
+               if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                     &SDL_hapticlist[numhaptics].usagePage))
+                  SDL_SetError("Haptic: Recieving device's usage page.");
+               refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
+               if (refCF) {
+                  if (!CFNumberGetValue(refCF, kCFNumberLongType,
+                        &SDL_hapticlist[numhaptics].usage))
+                     SDL_SetError("Haptic: Recieving device's usage.");
+               }
+            }
+            CFRelease(hidProperties);
+         }
+
+         /* Device has been added. */
+         numhaptics++;
+      }
+      else { /* Free the unused device. */
+         IOObjectRelease(device);
+      }
+
+      /* Reached haptic limit. */
+      if (numhaptics >= MAX_HAPTICS)
+         break;
+   }
+   IOObjectRelease(iter);
+
+   return numhaptics;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   return SDL_hapticlist[index].name;
+}
+
+/*
+ * Gets the device's product name.
+ */
+static int
+HIDGetDeviceProduct(io_service_t dev, char *name)
+{
+   CFMutableDictionaryRef hidProperties, usbProperties;
+   io_registry_entry_t parent1, parent2;
+   kern_return_t ret;
+
+   hidProperties = usbProperties = 0;
+
+   ret = IORegistryEntryCreateCFProperties(dev, &hidProperties,
+                                           kCFAllocatorDefault,
+                                           kNilOptions);
+   if ((ret != KERN_SUCCESS) || !hidProperties) {
+      SDL_SetError("Haptic: Unable to create CFProperties.");
+      return -1;
+   }
+
+   /* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
+    * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
+    */
+   if ((KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(dev, kIOServicePlane, &parent1))
+         && (KERN_SUCCESS ==
+            IORegistryEntryGetParentEntry(parent1, kIOServicePlane, &parent2))
+         && (KERN_SUCCESS ==
+            IORegistryEntryCreateCFProperties(parent2, &usbProperties,
+                                              kCFAllocatorDefault,
+                                              kNilOptions))) {
+      if (usbProperties) {
+         CFTypeRef refCF = 0;
+         /* get device info
+          * try hid dictionary first, if fail then go to usb dictionary
+          */
+
+
+         /* Get product name */
+         refCF = CFDictionaryGetValue(hidProperties, CFSTR(kIOHIDProductKey));
+         if (!refCF)
+            refCF =
+               CFDictionaryGetValue(usbProperties, CFSTR("USB Product Name"));
+         if (refCF) {
+            if (!CFStringGetCString(refCF, name, 256,
+                                    CFStringGetSystemEncoding())) {
+               SDL_SetError("Haptic: CFStringGetCString error retrieving pDevice->product.");
+               return -1;
+            }
+         }
+
+         CFRelease(usbProperties);
+      }
+      else {
+         SDL_SetError("Haptic: IORegistryEntryCreateCFProperties failed to create usbProperties.");
+         return -1;
+      }
+
+      /* Release stuff. */
+      if (kIOReturnSuccess != IOObjectRelease(parent2)) {
+         SDL_SetError("Haptic: IOObjectRelease error with parent2.");
+      }
+      if (kIOReturnSuccess != IOObjectRelease(parent1))  {
+         SDL_SetError("Haptic: IOObjectRelease error with parent1.");
+      }
+   }
+   else {
+      SDL_SetError("Haptic: Error getting registry entries.");
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#define FF_TEST(ff, s) \
+if (features.supportedEffects & (ff)) supported |= (s)
+/*
+ * Gets supported features.
+ */
+static unsigned int
+GetSupportedFeatures(SDL_Haptic* haptic)
+{
+   HRESULT ret;
+   FFDeviceObjectReference device;
+   FFCAPABILITIES features;
+   unsigned int supported;
+   Uint32 val;
+
+   device = haptic->hwdata->device;
+
+   ret = FFDeviceGetForceFeedbackCapabilities(device, &features);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get device's supported features.");
+      return -1;
+   }
+
+   supported = 0;
+
+   /* Get maximum effects. */
+   haptic->neffects = features.storageCapacity;
+   haptic->nplaying = features.playbackCapacity;
+
+   /* Test for effects. */
+   FF_TEST(FFCAP_ET_CONSTANTFORCE, SDL_HAPTIC_CONSTANT);
+   FF_TEST(FFCAP_ET_RAMPFORCE,     SDL_HAPTIC_RAMP);
+   FF_TEST(FFCAP_ET_SQUARE,        SDL_HAPTIC_SQUARE);
+   FF_TEST(FFCAP_ET_SINE,          SDL_HAPTIC_SINE);
+   FF_TEST(FFCAP_ET_TRIANGLE,      SDL_HAPTIC_TRIANGLE);
+   FF_TEST(FFCAP_ET_SAWTOOTHUP,    SDL_HAPTIC_SAWTOOTHUP);
+   FF_TEST(FFCAP_ET_SAWTOOTHDOWN,  SDL_HAPTIC_SAWTOOTHDOWN);
+   FF_TEST(FFCAP_ET_SPRING,        SDL_HAPTIC_SPRING);
+   FF_TEST(FFCAP_ET_DAMPER,        SDL_HAPTIC_DAMPER);
+   FF_TEST(FFCAP_ET_INERTIA,       SDL_HAPTIC_INERTIA);
+   FF_TEST(FFCAP_ET_FRICTION,      SDL_HAPTIC_FRICTION);
+   FF_TEST(FFCAP_ET_CUSTOMFORCE,   SDL_HAPTIC_CUSTOM);
+
+   /* Check if supports gain. */
+   ret = FFDeviceGetForceFeedbackProperty( device, FFPROP_FFGAIN,
+                                           &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_GAIN;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports gain: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Checks if supports autocenter. */
+   ret = FFDeviceGetForceFeedbackProperty(device, FFPROP_AUTOCENTER,
+                                          &val, sizeof(val));
+   if (ret == FF_OK) supported |= SDL_HAPTIC_AUTOCENTER;
+   else if (ret != FFERR_UNSUPPORTED) {
+      SDL_SetError("Haptic: Unable to get if device supports autocenter: %s.",
+                   FFStrError(ret));
+      return -1;
+   }
+
+   /* Check for axes, we have an artificial limit on axes */
+   haptic->naxes = ((features.numFfAxes) > 3) ?
+         3 : features.numFfAxes;
+   /* Actually store the axes we want to use */
+   SDL_memcpy( haptic->hwdata->axes, features.ffAxes, haptic->naxes * sizeof(Uint8));
+
+   /* Always supported features. */
+   supported |= SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+   haptic->supported = supported;
+   return 0;;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromService(SDL_Haptic * haptic, io_service_t service)
+{
+   HRESULT ret;
+   int ret2;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto creat_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+  
+   /* Open the device */
+   ret = FFCreateDevice( service, &haptic->hwdata->device);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create device from service: %s.",
+                   FFStrError(ret));
+      goto creat_err;
+   }
+
+   /* Get supported features. */
+   ret2 = GetSupportedFeatures( haptic );
+   if (haptic->supported < 0) {
+      goto open_err;
+   }
+
+
+   /* Reset and then enable actuators. */
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_RESET );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to reset device: %s.", FFStrError(ret));
+      goto open_err;
+   }
+   ret = FFDeviceSendForceFeedbackCommand( haptic->hwdata->device,
+                                           FFSFFC_SETACTUATORSON  );
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to enable actuators: %s.", FFStrError(ret));
+      goto open_err;
+   }
+
+
+   /* Allocate effects memory. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+   
+   return 0;
+   
+   /* Error handling */
+open_err:
+   FFReleaseDevice(haptic->hwdata->device);
+creat_err:
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;                                              
+   }
+   return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                SDL_hapticlist[haptic->index].dev);
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+      if ((SDL_hapticlist[i].usagePage == kHIDPage_GenericDesktop) &&
+            (SDL_hapticlist[i].usage == kHIDUsage_GD_Mouse))
+         return i;
+   }
+
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   if (joystick->hwdata->ffservice != 0)
+      return SDL_TRUE;
+   return SDL_FALSE;
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   if (IOObjectIsEqualTo((io_object_t) haptic->hwdata->device,
+                                       joystick->hwdata->ffservice))
+      return 1;
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return SDL_SYS_HapticOpenFromService(haptic,
+                joystick->hwdata->ffservice);
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free Effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      FFReleaseDevice(haptic->hwdata->device);
+
+      /* Free */
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; i < SDL_numhaptics; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      /* Free the io_service_t */
+      IOObjectRelease(SDL_hapticlist[i].dev);
+   }
+}
+
+
+/*
+ * Converts an SDL trigger button to an FFEFFECT trigger button.
+ */
+static DWORD
+FFGetTriggerButton( Uint16 button )
+{
+   DWORD dwTriggerButton;
+
+   dwTriggerButton = FFEB_NOTRIGGER;
+
+   if (button != 0) {
+      dwTriggerButton = FFJOFS_BUTTON(button - 1);
+   }
+
+   return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection( FFEFFECT * effect, SDL_HapticDirection *dir, int naxes )
+{
+   LONG *rglDir;
+
+   /* Handle no axes a part. */
+   if (naxes == 0) {
+      effect->dwFlags |= FFEFF_SPHERICAL; /* Set as default. */
+      effect->rglDirection = NULL;
+      return 0;
+   }
+
+   /* Has axes. */
+   rglDir = SDL_malloc( sizeof(LONG) * naxes );
+   if (rglDir == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset( rglDir, 0, sizeof(LONG) * naxes );
+   effect->rglDirection = rglDir;
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         effect->dwFlags |= FFEFF_POLAR;
+         rglDir[0] = dir->dir[0];
+         return 0;
+      case SDL_HAPTIC_CARTESIAN:
+         effect->dwFlags |= FFEFF_CARTESIAN;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+      case SDL_HAPTIC_SPHERICAL:
+         effect->dwFlags |= FFEFF_SPHERICAL;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+
+      default:
+         SDL_SetError("Haptic: Unknown direction type.");
+         return -1;
+   }
+}
+
+
+/* Clamps and converts. */
+#define CCONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/* Just converts. */
+#define CONVERT(x)    (((x)*10000) / 0x7FFF)
+/*
+ * Creates the FFEFFECT from a SDL_HapticEffect.
+ */
+static int
+SDL_SYS_ToFFEFFECT( SDL_Haptic * haptic, FFEFFECT * dest, SDL_HapticEffect * src )
+{
+   int i;
+   FFCONSTANTFORCE *constant;
+   FFPERIODIC *periodic;
+   FFCONDITION *condition; /* Actually an array of conditions - one per axis. */
+   FFRAMPFORCE *ramp;
+   FFCUSTOMFORCE *custom;
+   FFENVELOPE *envelope;
+   SDL_HapticConstant *hap_constant;
+   SDL_HapticPeriodic *hap_periodic;
+   SDL_HapticCondition *hap_condition;
+   SDL_HapticRamp *hap_ramp;
+   SDL_HapticCustom *hap_custom;
+   DWORD *axes;
+
+   /* Set global stuff. */
+   SDL_memset(dest, 0, sizeof(FFEFFECT));
+   dest->dwSize = sizeof(FFEFFECT); /* Set the structure size. */
+   dest->dwSamplePeriod = 0; /* Not used by us. */
+   dest->dwGain = 10000; /* Gain is set globally, not locally. */
+   dest->dwFlags = FFEFF_OBJECTOFFSETS; /* Seems obligatory. */
+
+   /* Envelope. */
+   envelope = SDL_malloc( sizeof(FFENVELOPE) );
+   if (envelope == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(envelope, 0, sizeof(FFENVELOPE));
+   dest->lpEnvelope = envelope;
+   envelope->dwSize = sizeof(FFENVELOPE); /* Always should be this. */
+
+   /* Axes. */
+   dest->cAxes = haptic->naxes;
+   if (dest->cAxes > 0) {
+      axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+      if (axes == NULL) {
+         SDL_OutOfMemory();
+         return -1;
+      }
+      axes[0] = haptic->hwdata->axes[0]; /* Always at least one axis. */
+      if (dest->cAxes > 1) {
+         axes[1] = haptic->hwdata->axes[1];
+      }
+      if (dest->cAxes > 2) {
+         axes[2] = haptic->hwdata->axes[2];
+      }
+      dest->rgdwAxes = axes;
+   }
+
+
+   /* The big type handling switch, even bigger then linux's version. */
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         hap_constant = &src->constant;
+         constant = SDL_malloc( sizeof(FFCONSTANTFORCE) );
+         if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(constant, 0, sizeof(FFCONSTANTFORCE));
+
+         /* Specifics */
+         constant->lMagnitude = CONVERT(hap_constant->level);
+         dest->cbTypeSpecificParams = sizeof(FFCONSTANTFORCE); 
+         dest->lpvTypeSpecificParams = constant;
+
+         /* Generics */
+         dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_constant->button);
+         dest->dwTriggerRepeatInterval = hap_constant->interval;
+         dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_constant->attack_length==0) && (hap_constant->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         hap_periodic = &src->periodic;
+         periodic = SDL_malloc(sizeof(FFPERIODIC));
+         if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(periodic, 0, sizeof(FFPERIODIC));
+
+         /* Specifics */
+         periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+         periodic->lOffset = CONVERT(hap_periodic->offset);
+         periodic->dwPhase = hap_periodic->phase;
+         periodic->dwPeriod = hap_periodic->period * 1000;
+         dest->cbTypeSpecificParams = sizeof(FFPERIODIC);
+         dest->lpvTypeSpecificParams = periodic;
+
+         /* Generics */
+         dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_periodic->button);
+         dest->dwTriggerRepeatInterval = hap_periodic->interval;
+         dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+         
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_periodic->attack_length==0) && (hap_periodic->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         hap_condition = &src->condition;
+         condition = SDL_malloc(sizeof(FFCONDITION) * dest->cAxes);
+         if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(condition, 0, sizeof(FFCONDITION));
+
+         /* Specifics */
+         for (i=0; i<dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient = CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient = CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation = CCONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation = CCONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CCONVERT(hap_condition->deadband[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCONDITION) * dest->cAxes;
+         dest->lpvTypeSpecificParams = condition;
+
+         /* Generics */
+         dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_condition->button);
+         dest->dwTriggerRepeatInterval = hap_condition->interval;
+         dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
+            return -1;                
+         }                            
+                                      
+         /* Envelope - Not actually supported by most CONDITION implementations. */
+         SDL_free(dest->lpEnvelope);
+         dest->lpEnvelope = NULL;
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         hap_ramp = &src->ramp;
+         ramp = SDL_malloc(sizeof(FFRAMPFORCE));
+         if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(ramp, 0, sizeof(FFRAMPFORCE));
+
+         /* Specifics */
+         ramp->lStart = CONVERT(hap_ramp->start);
+         ramp->lEnd = CONVERT(hap_ramp->end);
+         dest->cbTypeSpecificParams = sizeof(FFRAMPFORCE);
+         dest->lpvTypeSpecificParams = ramp;
+
+         /* Generics */
+         dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_ramp->button);
+         dest->dwTriggerRepeatInterval = hap_ramp->interval;
+         dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+
+         /* Envelope */
+         if ((hap_ramp->attack_length==0) && (hap_ramp->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_CUSTOM:
+         hap_custom = &src->custom;
+         custom = SDL_malloc(sizeof(FFCUSTOMFORCE));
+         if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(custom, 0, sizeof(FFCUSTOMFORCE));
+
+         /* Specifics */
+         custom->cChannels = hap_custom->channels;
+         custom->dwSamplePeriod = hap_custom->period * 1000;
+         custom->cSamples = hap_custom->samples;
+         custom->rglForceData = SDL_malloc(sizeof(LONG)*custom->cSamples*custom->cChannels);
+         for (i=0; i<hap_custom->samples*hap_custom->channels; i++) { /* Copy data. */
+            custom->rglForceData[i] = CCONVERT(hap_custom->data[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(FFCUSTOMFORCE);
+         dest->lpvTypeSpecificParams = custom;
+
+         /* Generics */
+         dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = FFGetTriggerButton(hap_custom->button);
+         dest->dwTriggerRepeatInterval = hap_custom->interval;
+         dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_custom->attack_length==0) && (hap_custom->fade_length==0)) {
+            SDL_free(envelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CCONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CCONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+         }
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees an FFEFFECT allocated by SDL_SYS_ToFFEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeFFEFFECT( FFEFFECT * effect, int type )
+{
+   FFCUSTOMFORCE *custom;
+
+   if (effect->lpEnvelope != NULL) {
+      SDL_free(effect->lpEnvelope);
+      effect->lpEnvelope = NULL;
+   }
+   if (effect->rgdwAxes != NULL) {
+      SDL_free(effect->rgdwAxes);
+      effect->rgdwAxes = NULL;
+   }
+   if (effect->lpvTypeSpecificParams != NULL) {
+      if (type == SDL_HAPTIC_CUSTOM) { /* Must free the custom data. */
+         custom = (FFCUSTOMFORCE*) effect->lpvTypeSpecificParams;
+         SDL_free(custom->rglForceData);
+         custom->rglForceData = NULL;
+      }
+      SDL_free(effect->lpvTypeSpecificParams);
+      effect->lpvTypeSpecificParams = NULL;
+   }
+   if (effect->rglDirection != NULL) {
+      SDL_free(effect->rglDirection);
+      effect->rglDirection = NULL;
+   }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+CFUUIDRef
+SDL_SYS_HapticEffectType( Uint16 type )
+{
+   switch (type) {
+      case SDL_HAPTIC_CONSTANT:
+         return kFFEffectType_ConstantForce_ID;
+
+      case SDL_HAPTIC_RAMP:
+         return kFFEffectType_RampForce_ID;
+
+      case SDL_HAPTIC_SQUARE:
+         return kFFEffectType_Square_ID;
+
+      case SDL_HAPTIC_SINE:
+         return kFFEffectType_Sine_ID;
+
+      case SDL_HAPTIC_TRIANGLE:
+         return kFFEffectType_Triangle_ID;
+
+      case SDL_HAPTIC_SAWTOOTHUP:
+         return kFFEffectType_SawtoothUp_ID;
+
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         return kFFEffectType_SawtoothDown_ID;
+
+      case SDL_HAPTIC_SPRING:
+         return kFFEffectType_Spring_ID;
+
+      case SDL_HAPTIC_DAMPER:
+         return kFFEffectType_Damper_ID;
+
+      case SDL_HAPTIC_INERTIA:
+         return kFFEffectType_Inertia_ID;
+
+      case SDL_HAPTIC_FRICTION:
+         return kFFEffectType_Friction_ID;
+
+      case SDL_HAPTIC_CUSTOM:
+         return kFFEffectType_CustomForce_ID;
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return NULL;
+   }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   HRESULT ret;
+   CFUUIDRef type;
+
+   /* Alloc the effect. */
+   effect->hweffect = (struct haptic_hweffect *)
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      goto err_hweffect;
+   }
+
+   /* Get the type. */
+   type = SDL_SYS_HapticEffectType(base->type);
+   if (type == NULL) {
+      goto err_hweffect;
+   }
+
+   /* Get the effect. */
+   if (SDL_SYS_ToFFEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+      goto err_effectdone;
+   }
+
+   /* Create the actual effect. */
+   ret = FFDeviceCreateEffect(haptic->hwdata->device, type,
+         &effect->hweffect->effect, &effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to create effect: %s.", FFStrError(ret));
+      goto err_effectdone;
+   }
+
+   return 0;
+
+err_effectdone:
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, base->type);
+err_hweffect:
+   if (effect->hweffect != NULL) {
+      SDL_free(effect->hweffect);
+      effect->hweffect = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   HRESULT ret;
+   FFEffectParameterFlag flags;
+   FFEFFECT temp;
+
+   /* Get the effect. */
+   SDL_memset(&temp, 0, sizeof(FFEFFECT));
+   if (SDL_SYS_ToFFEFFECT(haptic, &temp, data) < 0) {
+      goto err_update;
+   }
+
+   /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+    *  only change those parameters. */
+   flags = FFEP_DIRECTION |
+           FFEP_DURATION |
+           FFEP_ENVELOPE |
+           FFEP_STARTDELAY |
+           FFEP_TRIGGERBUTTON |
+           FFEP_TRIGGERREPEATINTERVAL |
+           FFEP_TYPESPECIFICPARAMS;
+
+   /* Create the actual effect. */
+   ret = FFEffectSetParameters(effect->hweffect->ref, &temp, flags);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to update effect: %s.", FFStrError(ret));
+      goto err_update;
+   }
+
+   /* Copy it over. */
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, data->type);
+   SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(FFEFFECT));
+
+   return 0;
+
+err_update:
+   SDL_SYS_HapticFreeFFEFFECT(&temp, data->type);
+   return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   HRESULT ret;
+   Uint32 iter;
+
+   /* Check if it's infinite. */
+   if (iterations == SDL_HAPTIC_INFINITY) {
+      iter = FF_INFINITE;
+   }
+   else
+      iter = iterations;
+
+   /* Run the effect. */
+   ret = FFEffectStart(effect->hweffect->ref, iter, 0);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to run the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFEffectStop(effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = FFDeviceReleaseEffect(haptic->hwdata->device, effect->hweffect->ref);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s.",
+                   FFStrError(ret));
+   }
+   SDL_SYS_HapticFreeFFEFFECT(&effect->hweffect->effect, effect->effect.type);
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+   FFEffectStatusFlag status;
+
+   ret = FFEffectGetEffectStatus(effect->hweffect->ref, &status);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Unable to get effect status: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   if (status == 0) return SDL_FALSE;
+   return SDL_TRUE; /* Assume it's playing or emulated. */
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   val = gain * 100; /* Mac OS X uses 0 to 10,000 */
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device, FFPROP_FFGAIN, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting gain: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   HRESULT ret;
+   Uint32 val;
+
+   /* Mac OS X only has 0 (off) and 1 (on) */
+   if (autocenter == 0) val = 0;
+   else val = 1;
+
+   ret = FFDeviceSetForceFeedbackProperty(haptic->hwdata->device,
+               FFPROP_AUTOCENTER, &val);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error setting autocenter: %s.", FFStrError(ret));
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_PAUSE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Unpauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_CONTINUE);
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error pausing device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops all currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   ret = FFDeviceSendForceFeedbackCommand(haptic->hwdata->device,
+                                          FFSFFC_STOPALL); 
+   if (ret != FF_OK) {
+      SDL_SetError("Haptic: Error stopping device: %s.", FFStrError(ret));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_IOKIT */
diff -ruN SDL-1.2.13/src/haptic/dummy/SDL_syshaptic.c SDL-1.2.13_OOx64/src/haptic/dummy/SDL_syshaptic.c
--- SDL-1.2.13/src/haptic/dummy/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/dummy/SDL_syshaptic.c	2017-12-18 15:09:06 +0000
@@ -0,0 +1,193 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#if defined(SDL_HAPTIC_DUMMY) || defined(SDL_HAPTIC_DISABLED)
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+
+
+static int
+SDL_SYS_LogicError(void)
+{
+   SDL_SetError("Logic error: No haptic devices available.");
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticInit(void)
+{
+   return 0;
+}
+
+
+const char *
+SDL_SYS_HapticName(int index)
+{
+   SDL_SYS_LogicError();
+   return NULL;
+}
+
+
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticMouse(void)
+{
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   return;
+}
+
+
+void
+SDL_SYS_HapticQuit(void)
+{
+   return;
+}
+
+
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                        struct haptic_effect * effect,
+                        SDL_HapticEffect * base)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect * effect,
+                           SDL_HapticEffect * data)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect, Uint32 iterations)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return;
+}
+
+
+int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+
+#endif /* SDL_HAPTIC_DUMMY || SDL_HAPTIC_DISABLED */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/haptic/dummy/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/haptic/dummy/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/haptic/dummy/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/dummy/SDL_syshaptic.c.bak	2017-12-18 13:29:10 +0000
@@ -0,0 +1,193 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#if defined(SDL_HAPTIC_DUMMY) || defined(SDL_HAPTIC_DISABLED)
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+
+
+static int
+SDL_SYS_LogicError(void)
+{
+   SDL_SetError("Logic error: No haptic devices available.");
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticInit(void)
+{
+   return 0;
+}
+
+
+const char *
+SDL_SYS_HapticName(int index)
+{
+   SDL_SYS_LogicError();
+   return NULL;
+}
+
+
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticMouse(void)
+{
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   return 0;
+}
+
+
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   return;
+}
+
+
+void
+SDL_SYS_HapticQuit(void)
+{
+   return;
+}
+
+
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic,
+                        struct haptic_effect * effect,
+                        SDL_HapticEffect * base)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+                           struct haptic_effect * effect,
+                           SDL_HapticEffect * data)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect, Uint32 iterations)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return;
+}
+
+
+int SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   SDL_SYS_LogicError();
+   return -1;
+}
+
+
+
+#endif /* SDL_HAPTIC_DUMMY || SDL_HAPTIC_DISABLED */
diff -ruN SDL-1.2.13/src/haptic/linux/SDL_syshaptic.c SDL-1.2.13_OOx64/src/haptic/linux/SDL_syshaptic.c
--- SDL-1.2.13/src/haptic/linux/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/linux/SDL_syshaptic.c	2017-12-18 15:09:16 +0000
@@ -0,0 +1,961 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_LINUX
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/linux/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <unistd.h> /* close */
+#include <linux/input.h> /* Force feedback linux stuff. */
+#include <fcntl.h> /* O_RDWR */
+#include <limits.h> /* INT_MAX */
+#include <errno.h> /* errno, strerror */
+#include <math.h> /* atan2 */
+#include <sys/stat.h> /* stat */
+
+/* Just in case. */
+#ifndef M_PI
+#  define M_PI     3.14159265358979323846
+#endif
+
+
+#define MAX_HAPTICS  32 /* It's doubtful someone has more then 32 evdev */
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char *fname; /* Dev path name (like /dev/input/event1) */
+   SDL_Haptic *haptic; /* Assosciated haptic. */
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   int fd; /* File descriptor of the device. */
+   char *fname; /* Points to the name in SDL_hapticlist. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   struct ff_effect effect; /* The linux kernel effect structure. */
+};
+
+
+
+#define test_bit(nr, addr) \
+   (((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+#define EV_TEST(ev,f) \
+   if (test_bit((ev), features)) ret |= (f);
+/*
+ * Test whether a device has haptic properties.
+ * Returns available properties or 0 if there are none.
+ */
+static int
+EV_IsHaptic(int fd)
+{
+   unsigned int ret;
+   unsigned long features[1 + FF_MAX/sizeof(unsigned long)];
+
+   /* Ask device for what it has. */
+   ret = 0;
+   if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(features)), features) < 0) {
+      SDL_SetError("Haptic: Unable to get device's features: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Convert supported features to SDL_HAPTIC platform-neutral features. */
+   EV_TEST(FF_CONSTANT,   SDL_HAPTIC_CONSTANT);
+   EV_TEST(FF_SINE,       SDL_HAPTIC_SINE);
+   EV_TEST(FF_SQUARE,     SDL_HAPTIC_SQUARE);
+   EV_TEST(FF_TRIANGLE,   SDL_HAPTIC_TRIANGLE);
+   EV_TEST(FF_SAW_UP,     SDL_HAPTIC_SAWTOOTHUP);
+   EV_TEST(FF_SAW_DOWN,   SDL_HAPTIC_SAWTOOTHDOWN);
+   EV_TEST(FF_RAMP,       SDL_HAPTIC_RAMP);
+   EV_TEST(FF_SPRING,     SDL_HAPTIC_SPRING);
+   EV_TEST(FF_FRICTION,   SDL_HAPTIC_FRICTION);
+   EV_TEST(FF_DAMPER,     SDL_HAPTIC_DAMPER);
+   EV_TEST(FF_INERTIA,    SDL_HAPTIC_INERTIA);
+   EV_TEST(FF_CUSTOM,     SDL_HAPTIC_CUSTOM);
+   EV_TEST(FF_GAIN,       SDL_HAPTIC_GAIN);
+   EV_TEST(FF_AUTOCENTER, SDL_HAPTIC_AUTOCENTER);
+
+   /* Return what it supports. */
+   return ret;
+}
+
+
+/*
+ * Tests whether a device is a mouse or not.
+ */
+static int
+EV_IsMouse(int fd)
+{
+   unsigned long argp[40];
+
+   /* Ask for supported features. */
+   if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(argp)), argp) < 0) {
+      return -1;
+   }
+
+   /* Currently we only test for BTN_MOUSE which can give fake positives. */
+   if (test_bit(BTN_MOUSE,argp) != 0) {
+      return 1;
+   }
+
+   return 0;
+}
+
+/*
+ * Initializes the haptic subsystem by finding available devices.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   const char joydev_pattern[] = "/dev/input/event%d";
+   dev_t dev_nums[MAX_HAPTICS];
+   char path[PATH_MAX];
+   struct stat sb;
+   int fd;
+   int i, j, k;
+   int duplicate;
+   int numhaptics;
+
+   numhaptics = 0;
+
+   /* 
+    * Limit amount of checks to MAX_HAPTICS since we may or may not have
+    * permission to some or all devices.
+    */
+   i = 0;
+   for (j = 0; j < MAX_HAPTICS; ++j) {
+
+      snprintf(path, PATH_MAX, joydev_pattern, i++);
+
+      /* check to see if file exists */
+      if (stat(path,&sb) != 0)
+         break;
+
+      /* check for duplicates */
+      duplicate = 0;
+      for (k = 0; (k < numhaptics) && !duplicate; ++k) {
+         if (sb.st_rdev == dev_nums[k]) {
+            duplicate = 1;
+         }                                                     
+      }                                                         
+      if (duplicate) {
+         continue;
+      }
+
+      /* try to open */
+      fd = open(path, O_RDWR, 0);
+      if (fd < 0) continue;
+
+#ifdef DEBUG_INPUT_EVENTS
+      printf("Checking %s\n", path);
+#endif          
+
+      /* see if it works */
+      if (EV_IsHaptic(fd) > 0) {
+         SDL_hapticlist[numhaptics].fname = SDL_strdup(path);
+         SDL_hapticlist[numhaptics].haptic = NULL;
+         dev_nums[numhaptics] = sb.st_rdev;
+         ++numhaptics;
+      }
+      close(fd);
+   }
+
+   return numhaptics;
+}
+
+
+/*
+ * Gets the name from a file descriptor.
+ */
+static const char *
+SDL_SYS_HapticNameFromFD(int fd)
+{
+   static char namebuf[128];
+
+   /* We use the evdev name ioctl. */
+   if (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) {
+      return NULL;
+   }
+
+   return namebuf;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   int fd;
+   const char *name;
+
+   /* Open the haptic device. */
+   name = NULL;
+   fd = open(SDL_hapticlist[index].fname, O_RDONLY, 0);
+
+   if (fd >= 0) {
+
+      name = SDL_SYS_HapticNameFromFD(fd);
+      if (name==NULL) {
+         /* No name found, return device character device */
+         name = SDL_hapticlist[index].fname;
+      }
+   }
+   close(fd);
+
+   return name;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromFD(SDL_Haptic * haptic, int fd)
+{
+   const char *name;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+   /* Set the data. */
+   haptic->hwdata->fd = fd;
+   haptic->supported = EV_IsHaptic(fd);
+   haptic->naxes = 2; /* Hardcoded for now, not sure if it's possible to find out. */
+
+   /* Set the effects */
+   if (ioctl(fd, EVIOCGEFFECTS, &haptic->neffects) < 0) {
+      SDL_SetError("Haptic: Unable to query device memory: %s", strerror(errno));
+      goto open_err;
+   }
+   haptic->nplaying = haptic->neffects; /* Linux makes no distinction. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+
+   return 0;
+
+   /* Error handling */
+open_err:
+   close(fd);
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   int fd;
+   int ret;
+
+   /* Open the character device */
+   fd = open(SDL_hapticlist[haptic->index].fname, O_RDWR, 0);
+   if (fd < 0) {
+      SDL_SetError("Haptic: Unable to open %s: %s",
+            SDL_hapticlist[haptic->index], strerror(errno));
+      return -1;
+   }
+
+   /* Try to create the haptic. */
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   /* Set the fname. */
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int fd;
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+
+      /* Open the device. */
+      fd = open(SDL_hapticlist[i].fname, O_RDWR, 0);
+      if (fd < 0) {
+         SDL_SetError("Haptic: Unable to open %s: %s",
+               SDL_hapticlist[i], strerror(errno));
+         return -1;
+      }
+
+      /* Is it a mouse? */
+      if (EV_IsMouse(fd)) {
+         close(fd);
+         return i;
+      }
+
+      close(fd);
+   }
+   
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return EV_IsHaptic(joystick->hwdata->fd);
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   /* We are assuming linux is using evdev which should trump the old
+    * joystick methods. */
+   if (SDL_strcmp(joystick->hwdata->fname,haptic->hwdata->fname)==0) {
+      return 1;
+   }
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   int i;
+   int fd;
+   int ret;
+
+   /* Find the joystick in the haptic list. */
+   for (i=0; i<MAX_HAPTICS; i++) {
+      if (SDL_hapticlist[i].fname != NULL) {
+         if (SDL_strcmp(SDL_hapticlist[i].fname, joystick->hwdata->fname)==0) {
+            haptic->index = i;
+         }
+      }
+   }
+
+   fd = open(joystick->hwdata->fname, O_RDWR, 0);
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      close(haptic->hwdata->fd);
+
+      /* Free */
+      SDL_free(haptic->hwdata);                                           
+      haptic->hwdata = NULL;  
+   }
+
+   /* Clear the rest. */
+   SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; SDL_hapticlist[i].fname != NULL; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      SDL_free(SDL_hapticlist[i].fname);
+   }
+   SDL_hapticlist[0].fname = NULL;
+}
+
+
+/*
+ * Converts an SDL button to a ff_trigger button.
+ */
+static Uint16
+SDL_SYS_ToButton( Uint16 button )
+{
+   Uint16 ff_button;
+
+   ff_button = 0;
+
+   /*
+    * Not sure what the proper syntax is because this actually isn't implemented
+    * in the current kernel from what I've seen (2.6.26).
+    */
+   if (button != 0) {
+      ff_button = BTN_GAMEPAD + button - 1;
+   }
+
+   return ff_button;
+}
+
+
+/*
+ * Returns the ff_effect usable direction from a SDL_HapticDirection.
+ */
+static Uint16
+SDL_SYS_ToDirection( SDL_HapticDirection * dir )
+{
+   Uint32 tmp;
+   float f; /* Ideally we'd use fixed point math instead of floats... */
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         /* Linux directions start from south.
+         		(and range from 0 to 0xFFFF)
+	 			   Quoting include/linux/input.h, line 926:
+	 			   Direction of the effect is encoded as follows:
+	 					0 deg -> 0x0000 (down)
+	 					90 deg -> 0x4000 (left)
+	 					180 deg -> 0x8000 (up)
+	 					270 deg -> 0xC000 (right)
+	 				*/
+         tmp = (((18000 + dir->dir[0]) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_CARTESIAN:
+         f = atan2(dir->dir[1], dir->dir[0]);
+		 /* 
+		   atan2 takes the parameters: Y-axis-value and X-axis-value (in that order)
+		    - Y-axis-value is the second coordinate (from center to SOUTH)
+		    - X-axis-value is the first coordinate (from center to EAST)
+		   	 We add 36000, because atan2 also returns negative values. Then we practically
+			 have the first spherical value. Therefore we proceed as in case
+			 SDL_HAPTIC_SPHERICAL and add another 9000 to get the polar value.
+		   --> add 45000 in total
+		   --> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+		 tmp = (((int) (f * 18000. / M_PI)) + 45000) % 36000;
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_SPHERICAL:
+		 /*
+			We convert to polar, because that's the only supported direction on Linux.
+			The first value of a spherical direction is practically the same as a
+			Polar direction, except that we have to add 90 degrees. It is the angle
+			from EAST {1,0} towards SOUTH {0,1}.
+			--> add 9000
+			--> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+         tmp = ((dir->dir[0]) + 9000) % 36000;    /* Convert to polars */
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      default:
+         SDL_SetError("Haptic: Unsupported direction type.");
+         return (Uint16)-1;
+   }
+
+   return 0;
+}
+
+
+#define  CLAMP(x)    (((x) > 32767) ? 32767 : x)
+/*
+ * Initializes the linux effect struct from a haptic_effect.
+ * Values above 32767 (for unsigned) are unspecified so we must clamp.
+ */
+static int
+SDL_SYS_ToFFEffect( struct ff_effect * dest, SDL_HapticEffect * src )
+{
+   Uint32 tmp;
+   SDL_HapticConstant *constant;
+   SDL_HapticPeriodic *periodic;
+   SDL_HapticCondition *condition;
+   SDL_HapticRamp *ramp;
+
+   /* Clear up */
+   SDL_memset(dest, 0, sizeof(struct ff_effect));
+
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         constant = &src->constant;
+
+         /* Header */
+         dest->type = FF_CONSTANT;
+         dest->direction = SDL_SYS_ToDirection(&constant->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
+               0 : CLAMP(constant->length);
+         dest->replay.delay = CLAMP(constant->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(constant->button);
+         dest->trigger.interval = CLAMP(constant->interval);
+
+         /* Constant */
+         dest->u.constant.level = constant->level;
+
+         /* Envelope */
+         dest->u.constant.envelope.attack_length = CLAMP(constant->attack_length);
+         dest->u.constant.envelope.attack_level = CLAMP(constant->attack_level);
+         dest->u.constant.envelope.fade_length = CLAMP(constant->fade_length);
+         dest->u.constant.envelope.fade_level = CLAMP(constant->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         periodic = &src->periodic;
+
+         /* Header */
+         dest->type = FF_PERIODIC;
+         dest->direction = SDL_SYS_ToDirection(&periodic->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+         
+         /* Replay */
+         dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(periodic->length);
+         dest->replay.delay = CLAMP(periodic->delay);
+         
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(periodic->button);
+         dest->trigger.interval = CLAMP(periodic->interval);
+         
+         /* Periodic */
+         if (periodic->type == SDL_HAPTIC_SINE)
+            dest->u.periodic.waveform = FF_SINE;
+         else if (periodic->type == SDL_HAPTIC_SQUARE)
+            dest->u.periodic.waveform = FF_SQUARE;
+         else if (periodic->type == SDL_HAPTIC_TRIANGLE)       
+            dest->u.periodic.waveform = FF_TRIANGLE;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)       
+            dest->u.periodic.waveform = FF_SAW_UP;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)       
+            dest->u.periodic.waveform = FF_SAW_DOWN;
+         dest->u.periodic.period = CLAMP(periodic->period);
+         dest->u.periodic.magnitude = periodic->magnitude;
+         dest->u.periodic.offset = periodic->offset;
+         /* Phase is calculated based of offset from period and then clamped. */
+         tmp = ((periodic->phase % 36000) * dest->u.periodic.period) / 36000;
+         dest->u.periodic.phase = CLAMP(tmp);
+         
+         /* Envelope */
+         dest->u.periodic.envelope.attack_length = CLAMP(periodic->attack_length);
+         dest->u.periodic.envelope.attack_level = CLAMP(periodic->attack_level);
+         dest->u.periodic.envelope.fade_length = CLAMP(periodic->fade_length);
+         dest->u.periodic.envelope.fade_level = CLAMP(periodic->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         condition = &src->condition;
+
+         /* Header */
+         if (condition->type == SDL_HAPTIC_SPRING)
+            dest->type = FF_SPRING;
+         else if (condition->type == SDL_HAPTIC_DAMPER)
+            dest->type = FF_DAMPER;
+         else if (condition->type == SDL_HAPTIC_INERTIA)
+            dest->type = FF_INERTIA;
+         else if (condition->type == SDL_HAPTIC_FRICTION)
+            dest->type = FF_FRICTION;
+         dest->direction = 0; /* Handled by the condition-specifics. */
+
+         /* Replay */
+         dest->replay.length = (condition->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(condition->length);
+         dest->replay.delay = CLAMP(condition->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(condition->button);
+         dest->trigger.interval = CLAMP(condition->interval);
+
+         /* Condition */
+         /* X axis */
+         dest->u.condition[0].right_saturation = CLAMP(condition->right_sat[0]);
+         dest->u.condition[0].left_saturation = CLAMP(condition->left_sat[0]);
+         dest->u.condition[0].right_coeff = condition->right_coeff[0];
+         dest->u.condition[0].left_coeff = condition->left_coeff[0];
+         dest->u.condition[0].deadband = CLAMP(condition->deadband[0]);
+         dest->u.condition[0].center = condition->center[0];
+         /* Y axis */
+         dest->u.condition[1].right_saturation = CLAMP(condition->right_sat[1]);
+         dest->u.condition[1].left_saturation = CLAMP(condition->left_sat[1]);
+         dest->u.condition[1].right_coeff = condition->right_coeff[1];
+         dest->u.condition[1].left_coeff = condition->left_coeff[1];  
+         dest->u.condition[1].deadband = CLAMP(condition->deadband[1]);
+         dest->u.condition[1].center = condition->center[1];
+
+         /*
+          * There is no envelope in the linux force feedback api for conditions.
+          */
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         ramp = &src->ramp;
+
+         /* Header */
+         dest->type = FF_RAMP;
+         dest->direction = SDL_SYS_ToDirection(&ramp->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(ramp->length);
+         dest->replay.delay = CLAMP(ramp->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(ramp->button);
+         dest->trigger.interval = CLAMP(ramp->interval);
+
+         /* Ramp */
+         dest->u.ramp.start_level = ramp->start;
+         dest->u.ramp.end_level = ramp->end;
+
+         /* Envelope */
+         dest->u.ramp.envelope.attack_length = CLAMP(ramp->attack_length);
+         dest->u.ramp.envelope.attack_level = CLAMP(ramp->attack_level);
+         dest->u.ramp.envelope.fade_length = CLAMP(ramp->fade_length);
+         dest->u.ramp.envelope.fade_level = CLAMP(ramp->fade_level);
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   struct ff_effect * linux_effect;
+
+   /* Allocate the hardware effect */
+   effect->hweffect = (struct haptic_hweffect *) 
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+
+   /* Prepare the ff_effect */
+   linux_effect = &effect->hweffect->effect;
+   if (SDL_SYS_ToFFEffect( linux_effect, base ) != 0) {
+      goto new_effect_err;
+   }
+   linux_effect->id = -1; /* Have the kernel give it an id */
+
+   /* Upload the effect */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, linux_effect) < 0) {
+      SDL_SetError("Haptic: Error uploading effect to the device: %s", strerror(errno));
+      goto new_effect_err;
+   }
+
+   return 0;
+
+new_effect_err:
+   free(effect->hweffect);
+   effect->hweffect = NULL;
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ *
+ * Note: Dynamically updating the direction can in some cases force
+ * the effect to restart and run once.
+ */
+int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   struct ff_effect linux_effect;
+
+   /* Create the new effect */
+   if (SDL_SYS_ToFFEffect( &linux_effect, data ) != 0) {
+      return -1;
+   }
+   linux_effect.id = effect->hweffect->effect.id;
+
+   /* See if it can be uploaded. */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, &linux_effect) < 0) {
+      SDL_SetError("Haptic: Error updating the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Copy the new effect into memory. */
+   SDL_memcpy( &effect->hweffect->effect, &linux_effect, sizeof(struct ff_effect) );
+
+   return effect->hweffect->effect.id;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   struct input_event run;
+
+   /* Prepare to run the effect */
+   run.type = EV_FF;
+   run.code = effect->hweffect->effect.id;
+   /* We don't actually have infinity here, so we just do INT_MAX which is pretty damn close. */
+   run.value = (iterations > INT_MAX) ? INT_MAX : iterations;
+
+   if (write(haptic->hwdata->fd, (const void*) &run, sizeof(run)) < 0) {
+      SDL_SetError("Haptic: Unable to run the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   struct input_event stop;
+
+   stop.type = EV_FF;
+   stop.code = effect->hweffect->effect.id;
+   stop.value = 0;
+
+   if (write(haptic->hwdata->fd, (const void*) &stop, sizeof(stop)) < 0) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   if (ioctl(haptic->hwdata->fd, EVIOCRMFF, effect->hweffect->effect.id) < 0) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s",
+            strerror(errno));
+   }
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+#if 0  /* Not supported atm. */
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.type = EV_FF_STATUS;
+   ie.code = effect->hweffect->effect.id;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error getting device status.");
+      return -1;
+   }
+
+   return 0;
+#endif
+
+   return -1;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_GAIN;
+   ie.value = (0xFFFFUL * gain) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting gain: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_AUTOCENTER;
+   ie.value = (0xFFFFUL * autocenter) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting autocenter: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Pausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Unpausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   int i, ret;
+
+   /* Linux does not support this natively so we have to loop. */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect != NULL) {
+         ret = SDL_SYS_HapticStopEffect(haptic, &haptic->effects[i]);
+         if (ret < 0) {
+            SDL_SetError("Haptic: Error while trying to stop all playing effects.");
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_LINUX */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/haptic/linux/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/haptic/linux/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/haptic/linux/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/linux/SDL_syshaptic.c.bak	2017-12-18 13:30:26 +0000
@@ -0,0 +1,961 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_LINUX
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/linux/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <unistd.h> /* close */
+#include <linux/input.h> /* Force feedback linux stuff. */
+#include <fcntl.h> /* O_RDWR */
+#include <limits.h> /* INT_MAX */
+#include <errno.h> /* errno, strerror */
+#include <math.h> /* atan2 */
+#include <sys/stat.h> /* stat */
+
+/* Just in case. */
+#ifndef M_PI
+#  define M_PI     3.14159265358979323846
+#endif
+
+
+#define MAX_HAPTICS  32 /* It's doubtful someone has more then 32 evdev */
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char *fname; /* Dev path name (like /dev/input/event1) */
+   SDL_Haptic *haptic; /* Assosciated haptic. */
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   int fd; /* File descriptor of the device. */
+   char *fname; /* Points to the name in SDL_hapticlist. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   struct ff_effect effect; /* The linux kernel effect structure. */
+};
+
+
+
+#define test_bit(nr, addr) \
+   (((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+#define EV_TEST(ev,f) \
+   if (test_bit((ev), features)) ret |= (f);
+/*
+ * Test whether a device has haptic properties.
+ * Returns available properties or 0 if there are none.
+ */
+static int
+EV_IsHaptic(int fd)
+{
+   unsigned int ret;
+   unsigned long features[1 + FF_MAX/sizeof(unsigned long)];
+
+   /* Ask device for what it has. */
+   ret = 0;
+   if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(features)), features) < 0) {
+      SDL_SetError("Haptic: Unable to get device's features: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Convert supported features to SDL_HAPTIC platform-neutral features. */
+   EV_TEST(FF_CONSTANT,   SDL_HAPTIC_CONSTANT);
+   EV_TEST(FF_SINE,       SDL_HAPTIC_SINE);
+   EV_TEST(FF_SQUARE,     SDL_HAPTIC_SQUARE);
+   EV_TEST(FF_TRIANGLE,   SDL_HAPTIC_TRIANGLE);
+   EV_TEST(FF_SAW_UP,     SDL_HAPTIC_SAWTOOTHUP);
+   EV_TEST(FF_SAW_DOWN,   SDL_HAPTIC_SAWTOOTHDOWN);
+   EV_TEST(FF_RAMP,       SDL_HAPTIC_RAMP);
+   EV_TEST(FF_SPRING,     SDL_HAPTIC_SPRING);
+   EV_TEST(FF_FRICTION,   SDL_HAPTIC_FRICTION);
+   EV_TEST(FF_DAMPER,     SDL_HAPTIC_DAMPER);
+   EV_TEST(FF_INERTIA,    SDL_HAPTIC_INERTIA);
+   EV_TEST(FF_CUSTOM,     SDL_HAPTIC_CUSTOM);
+   EV_TEST(FF_GAIN,       SDL_HAPTIC_GAIN);
+   EV_TEST(FF_AUTOCENTER, SDL_HAPTIC_AUTOCENTER);
+
+   /* Return what it supports. */
+   return ret;
+}
+
+
+/*
+ * Tests whether a device is a mouse or not.
+ */
+static int
+EV_IsMouse(int fd)
+{
+   unsigned long argp[40];
+
+   /* Ask for supported features. */
+   if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(argp)), argp) < 0) {
+      return -1;
+   }
+
+   /* Currently we only test for BTN_MOUSE which can give fake positives. */
+   if (test_bit(BTN_MOUSE,argp) != 0) {
+      return 1;
+   }
+
+   return 0;
+}
+
+/*
+ * Initializes the haptic subsystem by finding available devices.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   const char joydev_pattern[] = "/dev/input/event%d";
+   dev_t dev_nums[MAX_HAPTICS];
+   char path[PATH_MAX];
+   struct stat sb;
+   int fd;
+   int i, j, k;
+   int duplicate;
+   int numhaptics;
+
+   numhaptics = 0;
+
+   /* 
+    * Limit amount of checks to MAX_HAPTICS since we may or may not have
+    * permission to some or all devices.
+    */
+   i = 0;
+   for (j = 0; j < MAX_HAPTICS; ++j) {
+
+      snprintf(path, PATH_MAX, joydev_pattern, i++);
+
+      /* check to see if file exists */
+      if (stat(path,&sb) != 0)
+         break;
+
+      /* check for duplicates */
+      duplicate = 0;
+      for (k = 0; (k < numhaptics) && !duplicate; ++k) {
+         if (sb.st_rdev == dev_nums[k]) {
+            duplicate = 1;
+         }                                                     
+      }                                                         
+      if (duplicate) {
+         continue;
+      }
+
+      /* try to open */
+      fd = open(path, O_RDWR, 0);
+      if (fd < 0) continue;
+
+#ifdef DEBUG_INPUT_EVENTS
+      printf("Checking %s\n", path);
+#endif          
+
+      /* see if it works */
+      if (EV_IsHaptic(fd) > 0) {
+         SDL_hapticlist[numhaptics].fname = SDL_strdup(path);
+         SDL_hapticlist[numhaptics].haptic = NULL;
+         dev_nums[numhaptics] = sb.st_rdev;
+         ++numhaptics;
+      }
+      close(fd);
+   }
+
+   return numhaptics;
+}
+
+
+/*
+ * Gets the name from a file descriptor.
+ */
+static const char *
+SDL_SYS_HapticNameFromFD(int fd)
+{
+   static char namebuf[128];
+
+   /* We use the evdev name ioctl. */
+   if (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) {
+      return NULL;
+   }
+
+   return namebuf;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   int fd;
+   const char *name;
+
+   /* Open the haptic device. */
+   name = NULL;
+   fd = open(SDL_hapticlist[index].fname, O_RDONLY, 0);
+
+   if (fd >= 0) {
+
+      name = SDL_SYS_HapticNameFromFD(fd);
+      if (name==NULL) {
+         /* No name found, return device character device */
+         name = SDL_hapticlist[index].fname;
+      }
+   }
+   close(fd);
+
+   return name;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromFD(SDL_Haptic * haptic, int fd)
+{
+   const char *name;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+   /* Set the data. */
+   haptic->hwdata->fd = fd;
+   haptic->supported = EV_IsHaptic(fd);
+   haptic->naxes = 2; /* Hardcoded for now, not sure if it's possible to find out. */
+
+   /* Set the effects */
+   if (ioctl(fd, EVIOCGEFFECTS, &haptic->neffects) < 0) {
+      SDL_SetError("Haptic: Unable to query device memory: %s", strerror(errno));
+      goto open_err;
+   }
+   haptic->nplaying = haptic->neffects; /* Linux makes no distinction. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+
+   return 0;
+
+   /* Error handling */
+open_err:
+   close(fd);
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   int fd;
+   int ret;
+
+   /* Open the character device */
+   fd = open(SDL_hapticlist[haptic->index].fname, O_RDWR, 0);
+   if (fd < 0) {
+      SDL_SetError("Haptic: Unable to open %s: %s",
+            SDL_hapticlist[haptic->index], strerror(errno));
+      return -1;
+   }
+
+   /* Try to create the haptic. */
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   /* Set the fname. */
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int fd;
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+
+      /* Open the device. */
+      fd = open(SDL_hapticlist[i].fname, O_RDWR, 0);
+      if (fd < 0) {
+         SDL_SetError("Haptic: Unable to open %s: %s",
+               SDL_hapticlist[i], strerror(errno));
+         return -1;
+      }
+
+      /* Is it a mouse? */
+      if (EV_IsMouse(fd)) {
+         close(fd);
+         return i;
+      }
+
+      close(fd);
+   }
+   
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return EV_IsHaptic(joystick->hwdata->fd);
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   /* We are assuming linux is using evdev which should trump the old
+    * joystick methods. */
+   if (SDL_strcmp(joystick->hwdata->fname,haptic->hwdata->fname)==0) {
+      return 1;
+   }
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   int i;
+   int fd;
+   int ret;
+
+   /* Find the joystick in the haptic list. */
+   for (i=0; i<MAX_HAPTICS; i++) {
+      if (SDL_hapticlist[i].fname != NULL) {
+         if (SDL_strcmp(SDL_hapticlist[i].fname, joystick->hwdata->fname)==0) {
+            haptic->index = i;
+         }
+      }
+   }
+
+   fd = open(joystick->hwdata->fname, O_RDWR, 0);
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      close(haptic->hwdata->fd);
+
+      /* Free */
+      SDL_free(haptic->hwdata);                                           
+      haptic->hwdata = NULL;  
+   }
+
+   /* Clear the rest. */
+   SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; SDL_hapticlist[i].fname != NULL; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      SDL_free(SDL_hapticlist[i].fname);
+   }
+   SDL_hapticlist[0].fname = NULL;
+}
+
+
+/*
+ * Converts an SDL button to a ff_trigger button.
+ */
+static Uint16
+SDL_SYS_ToButton( Uint16 button )
+{
+   Uint16 ff_button;
+
+   ff_button = 0;
+
+   /*
+    * Not sure what the proper syntax is because this actually isn't implemented
+    * in the current kernel from what I've seen (2.6.26).
+    */
+   if (button != 0) {
+      ff_button = BTN_GAMEPAD + button - 1;
+   }
+
+   return ff_button;
+}
+
+
+/*
+ * Returns the ff_effect usable direction from a SDL_HapticDirection.
+ */
+static Uint16
+SDL_SYS_ToDirection( SDL_HapticDirection * dir )
+{
+   Uint32 tmp;
+   float f; /* Ideally we'd use fixed point math instead of floats... */
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         /* Linux directions start from south.
+         		(and range from 0 to 0xFFFF)
+	 			   Quoting include/linux/input.h, line 926:
+	 			   Direction of the effect is encoded as follows:
+	 					0 deg -> 0x0000 (down)
+	 					90 deg -> 0x4000 (left)
+	 					180 deg -> 0x8000 (up)
+	 					270 deg -> 0xC000 (right)
+	 				*/
+         tmp = (((18000 + dir->dir[0]) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_CARTESIAN:
+         f = atan2(dir->dir[1], dir->dir[0]);
+		 /* 
+		   atan2 takes the parameters: Y-axis-value and X-axis-value (in that order)
+		    - Y-axis-value is the second coordinate (from center to SOUTH)
+		    - X-axis-value is the first coordinate (from center to EAST)
+		   	 We add 36000, because atan2 also returns negative values. Then we practically
+			 have the first spherical value. Therefore we proceed as in case
+			 SDL_HAPTIC_SPHERICAL and add another 9000 to get the polar value.
+		   --> add 45000 in total
+		   --> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+		 tmp = (((int) (f * 18000. / M_PI)) + 45000) % 36000;
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_SPHERICAL:
+		 /*
+			We convert to polar, because that's the only supported direction on Linux.
+			The first value of a spherical direction is practically the same as a
+			Polar direction, except that we have to add 90 degrees. It is the angle
+			from EAST {1,0} towards SOUTH {0,1}.
+			--> add 9000
+			--> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+         tmp = ((dir->dir[0]) + 9000) % 36000;    /* Convert to polars */
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      default:
+         SDL_SetError("Haptic: Unsupported direction type.");
+         return (Uint16)-1;
+   }
+
+   return 0;
+}
+
+
+#define  CLAMP(x)    (((x) > 32767) ? 32767 : x)
+/*
+ * Initializes the linux effect struct from a haptic_effect.
+ * Values above 32767 (for unsigned) are unspecified so we must clamp.
+ */
+static int
+SDL_SYS_ToFFEffect( struct ff_effect * dest, SDL_HapticEffect * src )
+{
+   Uint32 tmp;
+   SDL_HapticConstant *constant;
+   SDL_HapticPeriodic *periodic;
+   SDL_HapticCondition *condition;
+   SDL_HapticRamp *ramp;
+
+   /* Clear up */
+   SDL_memset(dest, 0, sizeof(struct ff_effect));
+
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         constant = &src->constant;
+
+         /* Header */
+         dest->type = FF_CONSTANT;
+         dest->direction = SDL_SYS_ToDirection(&constant->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
+               0 : CLAMP(constant->length);
+         dest->replay.delay = CLAMP(constant->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(constant->button);
+         dest->trigger.interval = CLAMP(constant->interval);
+
+         /* Constant */
+         dest->u.constant.level = constant->level;
+
+         /* Envelope */
+         dest->u.constant.envelope.attack_length = CLAMP(constant->attack_length);
+         dest->u.constant.envelope.attack_level = CLAMP(constant->attack_level);
+         dest->u.constant.envelope.fade_length = CLAMP(constant->fade_length);
+         dest->u.constant.envelope.fade_level = CLAMP(constant->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         periodic = &src->periodic;
+
+         /* Header */
+         dest->type = FF_PERIODIC;
+         dest->direction = SDL_SYS_ToDirection(&periodic->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+         
+         /* Replay */
+         dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(periodic->length);
+         dest->replay.delay = CLAMP(periodic->delay);
+         
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(periodic->button);
+         dest->trigger.interval = CLAMP(periodic->interval);
+         
+         /* Periodic */
+         if (periodic->type == SDL_HAPTIC_SINE)
+            dest->u.periodic.waveform = FF_SINE;
+         else if (periodic->type == SDL_HAPTIC_SQUARE)
+            dest->u.periodic.waveform = FF_SQUARE;
+         else if (periodic->type == SDL_HAPTIC_TRIANGLE)       
+            dest->u.periodic.waveform = FF_TRIANGLE;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)       
+            dest->u.periodic.waveform = FF_SAW_UP;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)       
+            dest->u.periodic.waveform = FF_SAW_DOWN;
+         dest->u.periodic.period = CLAMP(periodic->period);
+         dest->u.periodic.magnitude = periodic->magnitude;
+         dest->u.periodic.offset = periodic->offset;
+         /* Phase is calculated based of offset from period and then clamped. */
+         tmp = ((periodic->phase % 36000) * dest->u.periodic.period) / 36000;
+         dest->u.periodic.phase = CLAMP(tmp);
+         
+         /* Envelope */
+         dest->u.periodic.envelope.attack_length = CLAMP(periodic->attack_length);
+         dest->u.periodic.envelope.attack_level = CLAMP(periodic->attack_level);
+         dest->u.periodic.envelope.fade_length = CLAMP(periodic->fade_length);
+         dest->u.periodic.envelope.fade_level = CLAMP(periodic->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         condition = &src->condition;
+
+         /* Header */
+         if (condition->type == SDL_HAPTIC_SPRING)
+            dest->type = FF_SPRING;
+         else if (condition->type == SDL_HAPTIC_DAMPER)
+            dest->type = FF_DAMPER;
+         else if (condition->type == SDL_HAPTIC_INERTIA)
+            dest->type = FF_INERTIA;
+         else if (condition->type == SDL_HAPTIC_FRICTION)
+            dest->type = FF_FRICTION;
+         dest->direction = 0; /* Handled by the condition-specifics. */
+
+         /* Replay */
+         dest->replay.length = (condition->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(condition->length);
+         dest->replay.delay = CLAMP(condition->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(condition->button);
+         dest->trigger.interval = CLAMP(condition->interval);
+
+         /* Condition */
+         /* X axis */
+         dest->u.condition[0].right_saturation = CLAMP(condition->right_sat[0]);
+         dest->u.condition[0].left_saturation = CLAMP(condition->left_sat[0]);
+         dest->u.condition[0].right_coeff = condition->right_coeff[0];
+         dest->u.condition[0].left_coeff = condition->left_coeff[0];
+         dest->u.condition[0].deadband = CLAMP(condition->deadband[0]);
+         dest->u.condition[0].center = condition->center[0];
+         /* Y axis */
+         dest->u.condition[1].right_saturation = CLAMP(condition->right_sat[1]);
+         dest->u.condition[1].left_saturation = CLAMP(condition->left_sat[1]);
+         dest->u.condition[1].right_coeff = condition->right_coeff[1];
+         dest->u.condition[1].left_coeff = condition->left_coeff[1];  
+         dest->u.condition[1].deadband = CLAMP(condition->deadband[1]);
+         dest->u.condition[1].center = condition->center[1];
+
+         /*
+          * There is no envelope in the linux force feedback api for conditions.
+          */
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         ramp = &src->ramp;
+
+         /* Header */
+         dest->type = FF_RAMP;
+         dest->direction = SDL_SYS_ToDirection(&ramp->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(ramp->length);
+         dest->replay.delay = CLAMP(ramp->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(ramp->button);
+         dest->trigger.interval = CLAMP(ramp->interval);
+
+         /* Ramp */
+         dest->u.ramp.start_level = ramp->start;
+         dest->u.ramp.end_level = ramp->end;
+
+         /* Envelope */
+         dest->u.ramp.envelope.attack_length = CLAMP(ramp->attack_length);
+         dest->u.ramp.envelope.attack_level = CLAMP(ramp->attack_level);
+         dest->u.ramp.envelope.fade_length = CLAMP(ramp->fade_length);
+         dest->u.ramp.envelope.fade_level = CLAMP(ramp->fade_level);
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   struct ff_effect * linux_effect;
+
+   /* Allocate the hardware effect */
+   effect->hweffect = (struct haptic_hweffect *) 
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+
+   /* Prepare the ff_effect */
+   linux_effect = &effect->hweffect->effect;
+   if (SDL_SYS_ToFFEffect( linux_effect, base ) != 0) {
+      goto new_effect_err;
+   }
+   linux_effect->id = -1; /* Have the kernel give it an id */
+
+   /* Upload the effect */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, linux_effect) < 0) {
+      SDL_SetError("Haptic: Error uploading effect to the device: %s", strerror(errno));
+      goto new_effect_err;
+   }
+
+   return 0;
+
+new_effect_err:
+   free(effect->hweffect);
+   effect->hweffect = NULL;
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ *
+ * Note: Dynamically updating the direction can in some cases force
+ * the effect to restart and run once.
+ */
+int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   struct ff_effect linux_effect;
+
+   /* Create the new effect */
+   if (SDL_SYS_ToFFEffect( &linux_effect, data ) != 0) {
+      return -1;
+   }
+   linux_effect.id = effect->hweffect->effect.id;
+
+   /* See if it can be uploaded. */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, &linux_effect) < 0) {
+      SDL_SetError("Haptic: Error updating the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Copy the new effect into memory. */
+   SDL_memcpy( &effect->hweffect->effect, &linux_effect, sizeof(struct ff_effect) );
+
+   return effect->hweffect->effect.id;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   struct input_event run;
+
+   /* Prepare to run the effect */
+   run.type = EV_FF;
+   run.code = effect->hweffect->effect.id;
+   /* We don't actually have infinity here, so we just do INT_MAX which is pretty damn close. */
+   run.value = (iterations > INT_MAX) ? INT_MAX : iterations;
+
+   if (write(haptic->hwdata->fd, (const void*) &run, sizeof(run)) < 0) {
+      SDL_SetError("Haptic: Unable to run the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   struct input_event stop;
+
+   stop.type = EV_FF;
+   stop.code = effect->hweffect->effect.id;
+   stop.value = 0;
+
+   if (write(haptic->hwdata->fd, (const void*) &stop, sizeof(stop)) < 0) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   if (ioctl(haptic->hwdata->fd, EVIOCRMFF, effect->hweffect->effect.id) < 0) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s",
+            strerror(errno));
+   }
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+#if 0  /* Not supported atm. */
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.type = EV_FF_STATUS;
+   ie.code = effect->hweffect->effect.id;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error getting device status.");
+      return -1;
+   }
+
+   return 0;
+#endif
+
+   return -1;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_GAIN;
+   ie.value = (0xFFFFUL * gain) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting gain: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_AUTOCENTER;
+   ie.value = (0xFFFFUL * autocenter) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting autocenter: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Pausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Unpausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   int i, ret;
+
+   /* Linux does not support this natively so we have to loop. */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect != NULL) {
+         ret = SDL_SYS_HapticStopEffect(haptic, &haptic->effects[i]);
+         if (ret < 0) {
+            SDL_SetError("Haptic: Error while trying to stop all playing effects.");
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_LINUX */
diff -ruN SDL-1.2.13/src/haptic/win32/SDL_syshaptic.c SDL-1.2.13_OOx64/src/haptic/win32/SDL_syshaptic.c
--- SDL-1.2.13/src/haptic/win32/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/haptic/win32/SDL_syshaptic.c	2017-12-20 15:03:05 +0000
@@ -0,0 +1,1368 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_DINPUT
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/win32/SDL_dxjoystick_c.h" /* For joystick hwdata */
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+#define DIRECTINPUT_VERSION 0x0700 /* Need at least DirectX 7 for dwStartDelay */
+#include <dinput.h>
+#include <dxerr8.h>
+#ifdef _MSC_VER
+#  pragma comment (lib, "dinput8.lib")
+#  pragma comment (lib, "dxguid.lib")
+#  pragma comment (lib, "dxerr8.lib")
+#endif /* _MSC_VER */
+
+    /* an ISO hack for VisualC++ */
+#ifdef _MSC_VER
+#define   snprintf   _snprintf
+#endif /* _MSC_VER */
+
+
+#define MAX_HAPTICS  32
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   DIDEVICEINSTANCE instance;
+   SDL_Haptic *haptic;
+   DIDEVCAPS capabilities;
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   LPDIRECTINPUTDEVICE2 device;
+   DWORD axes[3]; /* Axes to use. */
+   int is_joystick; /* Device is loaded as joystick. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   DIEFFECT effect;
+   LPDIRECTINPUTEFFECT ref;
+};
+
+
+/*
+ * Internal stuff.
+ */
+static LPDIRECTINPUT dinput = NULL;
+
+
+/*
+ * External stuff.
+ */
+extern HWND SDL_HelperWindow;
+
+
+/*
+ * Prototypes.
+ */
+static void DI_SetError(const char *str, HRESULT err);
+static int DI_GUIDIsSame(const GUID * a, const GUID * b);
+static int SDL_SYS_HapticOpenFromInstance(SDL_Haptic * haptic, DIDEVICEINSTANCE instance);
+static int SDL_SYS_HapticOpenFromDevice2(SDL_Haptic * haptic, LPDIRECTINPUTDEVICE2 device2);
+static DWORD DIGetTriggerButton( Uint16 button );
+static int SDL_SYS_SetDirection( DIEFFECT * effect, SDL_HapticDirection *dir, int naxes );
+static int SDL_SYS_ToDIEFFECT( SDL_Haptic * haptic, DIEFFECT * dest, SDL_HapticEffect * src );
+static void SDL_SYS_HapticFreeDIEFFECT( DIEFFECT * effect, int type );
+static REFGUID SDL_SYS_HapticEffectType(SDL_HapticEffect * effect);
+/* Callbacks. */
+static BOOL CALLBACK EnumHapticsCallback(const DIDEVICEINSTANCE * pdidInstance, VOID * pContext);
+static BOOL CALLBACK DI_EffectCallback(LPCDIEFFECTINFO pei, LPVOID pv);
+
+
+/* 
+ * Like SDL_SetError but for DX error codes.
+ */
+static void
+DI_SetError(const char *str, HRESULT err)
+{
+   SDL_SetError( "Haptic: %s - %s: %s", str,
+                 DXGetErrorString8A(err),
+                 DXGetErrorDescription8A(err));
+}
+
+
+/*
+ * Checks to see if two GUID are the same.
+ */
+static int
+DI_GUIDIsSame(const GUID * a, const GUID * b)
+{
+   if (((a)->Data1 == (b)->Data1) &&
+         ((a)->Data2 == (b)->Data2) &&
+         ((a)->Data3 == (b)->Data3) &&
+         (SDL_strcmp((a)->Data4, (b)->Data4)==0))
+      return 1;
+   return 0;
+}
+
+
+/*
+ * Initializes the haptic subsystem.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   HRESULT ret;
+   HINSTANCE instance;
+
+   if (dinput != NULL) { /* Already open. */
+      SDL_SetError("Haptic: SubSystem already open.");
+      return -1;
+   }
+
+   /* Clear all the memory. */
+   SDL_memset(SDL_hapticlist, 0, sizeof(SDL_hapticlist));
+
+   SDL_numhaptics = 0;
+
+   ret = CoInitialize(NULL);
+   if (FAILED(ret)) {
+      DI_SetError("Coinitialize",ret);
+      return -1;
+   }
+
+   ret = CoCreateInstance(&CLSID_DirectInput, NULL, CLSCTX_INPROC_SERVER,
+                          &IID_IDirectInput, (LPVOID)&dinput);
+   if (FAILED(ret)) {
+      DI_SetError("CoCreateInstance",ret);
+      return -1;
+   }
+
+   /* Because we used CoCreateInstance, we need to Initialize it, first. */
+   instance = GetModuleHandle(NULL);
+   if (instance == NULL) {
+      SDL_SetError("GetModuleHandle() failed with error code %d.", GetLastError());
+      return -1;
+   }
+   ret = IDirectInput_Initialize(dinput, instance, DIRECTINPUT_VERSION);
+   if (FAILED(ret)) {
+      DI_SetError("Initializing DirectInput device",ret);
+      return -1;
+   }
+
+   /* Look for haptic devices. */
+   ret = IDirectInput_EnumDevices( dinput,
+                                   0,
+                                   EnumHapticsCallback,
+                                   NULL, DIEDFL_FORCEFEEDBACK | DIEDFL_ATTACHEDONLY);
+   if (FAILED(ret)) {
+      DI_SetError("Enumerating DirectInput devices",ret);
+      return -1;
+   }
+
+   return SDL_numhaptics;
+}
+
+/*
+ * Callback to find the haptic devices.
+ */
+static BOOL CALLBACK
+EnumHapticsCallback(const DIDEVICEINSTANCE * pdidInstance, VOID * pContext)
+{
+   HRESULT ret;
+   LPDIRECTINPUTDEVICE device;
+
+   /* Copy the instance over, useful for creating devices. */
+   SDL_memcpy(&SDL_hapticlist[SDL_numhaptics].instance, pdidInstance,
+         sizeof(DIDEVICEINSTANCE));
+
+   /* Open the device */
+   ret = IDirectInput_CreateDevice( dinput, &pdidInstance->guidInstance,
+                                    &device, NULL );
+   if (FAILED(ret)) {
+      /* DI_SetError("Creating DirectInput device",ret); */
+      return DIENUM_CONTINUE;
+   }
+
+   /* Get capabilities. */
+   SDL_hapticlist[SDL_numhaptics].capabilities.dwSize = sizeof(DIDEVCAPS);
+   ret = IDirectInputDevice_GetCapabilities( device,
+                                             &SDL_hapticlist[SDL_numhaptics].capabilities );
+   if (FAILED(ret)) {
+      /* DI_SetError("Getting device capabilities",ret); */
+      IDirectInputDevice_Release(device);
+      return DIENUM_CONTINUE;
+   }
+
+   /* Close up device and count it. */
+   IDirectInputDevice_Release(device);
+   SDL_numhaptics++;
+
+   /* Watch out for hard limit. */
+   if (SDL_numhaptics >= MAX_HAPTICS)
+      return DIENUM_STOP;
+
+   return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   return SDL_hapticlist[index].instance.tszProductName;
+}
+
+
+/*
+ * Callback to get all supported effects.
+ */
+#define EFFECT_TEST(e,s)               \
+if (DI_GUIDIsSame(&pei->guid, &(e)))   \
+   haptic->supported |= (s)
+static BOOL CALLBACK
+DI_EffectCallback(LPCDIEFFECTINFO pei, LPVOID pv)
+{
+   /* Prepare the haptic device. */
+   SDL_Haptic *haptic = (SDL_Haptic*) pv;
+
+   /* Get supported. */
+   EFFECT_TEST(GUID_Spring,         SDL_HAPTIC_SPRING);
+   EFFECT_TEST(GUID_Damper,         SDL_HAPTIC_DAMPER);
+   EFFECT_TEST(GUID_Inertia,        SDL_HAPTIC_INERTIA);
+   EFFECT_TEST(GUID_Friction,       SDL_HAPTIC_FRICTION);
+   EFFECT_TEST(GUID_ConstantForce,  SDL_HAPTIC_CONSTANT);
+   EFFECT_TEST(GUID_CustomForce,    SDL_HAPTIC_CUSTOM);
+   EFFECT_TEST(GUID_Sine,           SDL_HAPTIC_SINE);
+   EFFECT_TEST(GUID_Square,         SDL_HAPTIC_SQUARE);
+   EFFECT_TEST(GUID_Triangle,       SDL_HAPTIC_TRIANGLE);
+   EFFECT_TEST(GUID_SawtoothUp,     SDL_HAPTIC_SAWTOOTHUP);
+   EFFECT_TEST(GUID_SawtoothDown,   SDL_HAPTIC_SAWTOOTHDOWN);
+   EFFECT_TEST(GUID_RampForce,      SDL_HAPTIC_RAMP);
+  
+   /* Check for more. */
+   return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Callback to get supported axes.
+ */
+static BOOL CALLBACK
+DI_DeviceObjectCallback(LPCDIDEVICEOBJECTINSTANCE dev, LPVOID pvRef)
+{
+   SDL_Haptic *haptic = (SDL_Haptic *) pvRef;
+
+   if ((dev->dwType & DIDFT_AXIS) && (dev->dwFlags & DIDOI_FFACTUATOR)) {
+
+      haptic->hwdata->axes[haptic->naxes] = dev->dwOfs;
+      haptic->naxes++;
+
+      /* Currently using the artificial limit of 3 axes. */
+      if (haptic->naxes >= 3) {
+         return DIENUM_STOP;
+      }
+   }
+
+   return DIENUM_CONTINUE;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ *
+ *    Steps:
+ *       - Open temporary DirectInputDevice interface.
+ *       - Create DirectInputDevice2 interface.
+ *       - Release DirectInputDevice interface.
+ *       - Call SDL_SYS_HapticOpenFromDevice2
+ */
+static int
+SDL_SYS_HapticOpenFromInstance(SDL_Haptic * haptic, DIDEVICEINSTANCE instance)
+{
+   HRESULT ret;
+   int ret2;
+   LPDIRECTINPUTDEVICE device;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto creat_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+  
+   /* Open the device */
+   ret = IDirectInput_CreateDevice( dinput, &instance.guidInstance,
+                                    &device, NULL );
+   if (FAILED(ret)) {
+      DI_SetError("Creating DirectInput device",ret);
+      goto creat_err;
+   }
+
+   /* Now get the IDirectInputDevice2 interface, instead. */
+   ret = IDirectInputDevice_QueryInterface( device,
+                                            &IID_IDirectInputDevice2,
+                                            (LPVOID *) &haptic->hwdata->device );
+   /* Done with the temporary one now. */
+   IDirectInputDevice_Release(device);
+   if (FAILED(ret)) {
+      DI_SetError("Querying DirectInput interface",ret);
+      goto creat_err;
+   }
+
+   ret2 = SDL_SYS_HapticOpenFromDevice2( haptic, haptic->hwdata->device );
+   if (ret2 < 0) {
+      goto query_err;
+   }
+
+   return 0;
+
+query_err:
+   IDirectInputDevice2_Release(haptic->hwdata->device);   
+creat_err:
+   if (haptic->hwdata != NULL) {
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;                                              
+   }
+   return -1;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ *
+ *    Steps:
+ *       - Set cooperative level.
+ *       - Set data format.
+ *       - Acquire exclusiveness.
+ *       - Reset actuators.
+ *       - Get supported featuers.
+ */
+static int
+SDL_SYS_HapticOpenFromDevice2(SDL_Haptic * haptic, LPDIRECTINPUTDEVICE2 device2)
+
+{
+   HRESULT ret;
+   DIPROPDWORD dipdw;
+
+   /* We'll use the device2 from now on. */
+   haptic->hwdata->device = device2;
+
+   /* Grab it exclusively to use force feedback stuff. */
+   ret =IDirectInputDevice2_SetCooperativeLevel( haptic->hwdata->device,
+                                                 SDL_HelperWindow,
+                                                 DISCL_EXCLUSIVE | DISCL_BACKGROUND );
+   if (FAILED(ret)) {
+      DI_SetError("Setting cooperative level to exclusive",ret);
+      goto acquire_err;
+   }
+
+   /* Set data format. */
+   ret = IDirectInputDevice2_SetDataFormat( haptic->hwdata->device,
+                                            &c_dfDIJoystick2 );
+   if (FAILED(ret)) {
+      DI_SetError("Setting data format",ret);
+      goto acquire_err;
+   }
+
+   /* Get number of axes. */
+   ret = IDirectInputDevice2_EnumObjects( haptic->hwdata->device,
+                                          DI_DeviceObjectCallback,
+                                          haptic, DIDFT_AXIS );
+   if (FAILED(ret)) {
+      DI_SetError("Getting device axes",ret);
+      goto acquire_err;
+   }
+
+   /* Acquire the device. */
+   ret = IDirectInputDevice2_Acquire(haptic->hwdata->device);
+   if (FAILED(ret)) {
+      DI_SetError("Acquiring DirectInput device",ret);
+      goto acquire_err;
+   }
+
+   /* Reset all actuators - just in case. */
+   ret = IDirectInputDevice2_SendForceFeedbackCommand( haptic->hwdata->device,
+                                                       DISFFC_RESET );
+   if (FAILED(ret)) {
+      DI_SetError("Resetting device",ret);
+      goto acquire_err;
+   }
+
+   /* Enabling actuators. */
+   ret = IDirectInputDevice2_SendForceFeedbackCommand( haptic->hwdata->device,
+                                                       DISFFC_SETACTUATORSON );
+   if (FAILED(ret)) {
+      DI_SetError("Enabling actuators",ret);
+      goto acquire_err;
+   }
+
+   /* Get supported effects. */
+   ret = IDirectInputDevice2_EnumEffects( haptic->hwdata->device, 
+                                          DI_EffectCallback, haptic, DIEFT_ALL );
+   if (FAILED(ret)) {
+      DI_SetError("Enumerating supported effects",ret);
+      goto acquire_err;
+   }
+   if (haptic->supported == 0) { /* Error since device supports nothing. */
+      SDL_SetError("Haptic: Internal error on finding supported effects.");
+      goto acquire_err;
+   }
+
+   /* Check autogain and autocenter. */
+   dipdw.diph.dwSize       = sizeof(DIPROPDWORD); 
+   dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER); 
+   dipdw.diph.dwObj        = 0;
+   dipdw.diph.dwHow        = DIPH_DEVICE;
+   dipdw.dwData            = 10000;
+   ret = IDirectInputDevice2_SetProperty( haptic->hwdata->device,        
+                                          DIPROP_FFGAIN, &dipdw.diph );
+   if (!FAILED(ret)) { /* Gain is supported. */
+      haptic->supported |= SDL_HAPTIC_GAIN;
+   }
+   dipdw.diph.dwObj        = 0;
+   dipdw.diph.dwHow        = DIPH_DEVICE;
+   dipdw.dwData            = DIPROPAUTOCENTER_OFF;
+   ret = IDirectInputDevice2_SetProperty( haptic->hwdata->device,
+                                          DIPROP_AUTOCENTER, &dipdw.diph );
+   if (!FAILED(ret)) { /* Autocenter is supported. */
+      haptic->supported |= SDL_HAPTIC_AUTOCENTER;
+   }
+
+   /* Status is always supported. */
+   haptic->supported |= SDL_HAPTIC_STATUS | SDL_HAPTIC_PAUSE;
+
+   /* Check maximum effects. */
+   haptic->neffects = 128; /* This is not actually supported as thus under windows,
+                              there is no way to tell the number of EFFECTS that a
+                              device can hold, so we'll just use a "random" number
+                              instead and put warnings in SDL_haptic.h */
+   haptic->nplaying = 128; /* Even more impossible to get this then neffects. */
+
+   /* Prepare effects memory. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto acquire_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+   
+   return 0;
+   
+   /* Error handling */
+acquire_err:
+   IDirectInputDevice2_Unacquire(haptic->hwdata->device);
+   return -1;
+
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   return SDL_SYS_HapticOpenFromInstance( haptic,
+         SDL_hapticlist[haptic->index].instance );
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int i;
+
+   /* Grab the first mouse haptic device we find. */
+   for (i=0; i<SDL_numhaptics; i++) {
+      if (SDL_hapticlist[i].capabilities.dwDevType == DIDEVTYPE_MOUSE ) {
+         return i;
+      }
+   }
+
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   if (joystick->hwdata->Capabilities.dwFlags & DIDC_FORCEFEEDBACK) {
+      return SDL_TRUE;
+   }
+
+   return SDL_FALSE;
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   HRESULT ret;
+   DIDEVICEINSTANCE hap_instance, joy_instance;
+
+   /* Get the device instances. */
+   ret = IDirectInputDevice2_GetDeviceInfo( haptic->hwdata->device,
+                                            &hap_instance );
+   if (FAILED(ret)) {
+      return 0;
+   }
+   ret = IDirectInputDevice2_GetDeviceInfo( joystick->hwdata->InputDevice,
+                                            &joy_instance );
+   if (FAILED(ret)) {
+      return 0;
+   }
+
+   if (DI_GUIDIsSame(&hap_instance.guidInstance, &joy_instance.guidInstance))
+      return 1;
+
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   int ret;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+   /* Now open the device. */
+   ret = SDL_SYS_HapticOpenFromDevice2( haptic, joystick->hwdata->InputDevice );  
+   if (ret < 0) {
+      return -1;
+   }
+
+   /* It's using the joystick device. */
+   haptic->hwdata->is_joystick = 1;
+
+   return 0;
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      IDirectInputDevice2_Unacquire(haptic->hwdata->device);
+      /* Only release if isn't grabbed by a joystick. */
+      if (haptic->hwdata->is_joystick == 0) {
+         IDirectInputDevice2_Release(haptic->hwdata->device);   
+      }
+
+      /* Free */
+      SDL_free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   IDirectInput_Release(dinput);
+   dinput = NULL;
+}
+
+
+/*
+ * Converts an SDL trigger button to an DIEFFECT trigger button.
+ */
+static DWORD
+DIGetTriggerButton( Uint16 button )
+{
+   DWORD dwTriggerButton;
+   
+   dwTriggerButton = DIEB_NOTRIGGER;
+   
+   if (button != 0) {
+      dwTriggerButton = DIJOFS_BUTTON(button - 1);
+   }                                                                      
+                                                                          
+   return dwTriggerButton;
+}
+
+
+/*
+ * Sets the direction.
+ */
+static int
+SDL_SYS_SetDirection( DIEFFECT * effect, SDL_HapticDirection *dir, int naxes )
+{
+   LONG *rglDir;
+
+   /* Handle no axes a part. */
+   if (naxes == 0) {
+      effect->dwFlags |= DIEFF_SPHERICAL; /* Set as default. */
+      effect->rglDirection = NULL;
+      return 0;
+   }
+
+   /* Has axes. */
+   rglDir = SDL_malloc( sizeof(LONG) * naxes );
+   if (rglDir == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset( rglDir, 0, sizeof(LONG) * naxes );
+   effect->rglDirection = rglDir;
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         effect->dwFlags |= DIEFF_POLAR;
+         rglDir[0] = dir->dir[0];
+         return 0;
+      case SDL_HAPTIC_CARTESIAN:
+         effect->dwFlags |= DIEFF_CARTESIAN;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+      case SDL_HAPTIC_SPHERICAL:
+         effect->dwFlags |= DIEFF_SPHERICAL;
+         rglDir[0] = dir->dir[0];
+         if (naxes > 1)
+            rglDir[1] = dir->dir[1];
+         if (naxes > 2)
+            rglDir[2] = dir->dir[2];
+         return 0;
+
+      default:
+         SDL_SetError("Haptic: Unknown direction type.");
+         return -1;
+   }
+}
+
+#define CONVERT(x)   (((x) > 0x7FFF) ? 10000 : ((x)*10000) / 0x7FFF)
+/*
+ * Creates the DIEFFECT from a SDL_HapticEffect.
+ */
+
+static int
+SDL_SYS_ToDIEFFECT( SDL_Haptic * haptic, DIEFFECT * dest, SDL_HapticEffect * src )
+{
+   int i;
+   DICONSTANTFORCE *constant;
+   DIPERIODIC *periodic;
+   DICONDITION *condition; /* Actually an array of conditions - one per axis. */
+   DIRAMPFORCE *ramp;
+   DICUSTOMFORCE *custom;
+   DIENVELOPE *envelope;
+   SDL_HapticConstant *hap_constant;
+   SDL_HapticPeriodic *hap_periodic;
+   SDL_HapticCondition *hap_condition;
+   SDL_HapticRamp *hap_ramp;
+   SDL_HapticCustom *hap_custom;
+   DWORD *axes;
+
+   /* Set global stuff. */
+   SDL_memset(dest, 0, sizeof(DIEFFECT));
+   dest->dwSize = sizeof(DIEFFECT); /* Set the structure size. */
+   dest->dwSamplePeriod = 0; /* Not used by us. */
+   dest->dwGain = 10000; /* Gain is set globally, not locally. */
+   dest->dwFlags = DIEFF_OBJECTOFFSETS; /* Seems obligatory. */
+
+   /* Envelope. */
+   envelope = SDL_malloc( sizeof(DIENVELOPE) );
+   if (envelope == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+   SDL_memset(envelope, 0, sizeof(DIENVELOPE));
+   dest->lpEnvelope = envelope;
+   envelope->dwSize = sizeof(DIENVELOPE); /* Always should be this. */
+
+   /* Axes. */
+   dest->cAxes = haptic->naxes;
+   if (dest->cAxes > 0) {
+      axes = SDL_malloc(sizeof(DWORD) * dest->cAxes);
+      if (axes == NULL) {
+         SDL_OutOfMemory();
+         return -1;
+      }
+      axes[0] = haptic->hwdata->axes[0]; /* Always at least one axis. */
+      if (dest->cAxes > 1) {
+         axes[1] = haptic->hwdata->axes[1];
+      }
+      if (dest->cAxes > 2) {
+         axes[2] = haptic->hwdata->axes[2];
+      }
+      dest->rgdwAxes = axes;
+   }
+
+
+   /* The big type handling switch, even bigger then linux's version. */
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         hap_constant = &src->constant;
+         constant = SDL_malloc( sizeof(DICONSTANTFORCE) );
+         if (constant == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(constant, 0, sizeof(DICONSTANTFORCE));
+
+         /* Specifics */
+         constant->lMagnitude = CONVERT(hap_constant->level);
+         dest->cbTypeSpecificParams = sizeof(DICONSTANTFORCE); 
+         dest->lpvTypeSpecificParams = constant;
+
+         /* Generics */
+         dest->dwDuration = hap_constant->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = DIGetTriggerButton(hap_constant->button);
+         dest->dwTriggerRepeatInterval = hap_constant->interval;
+         dest->dwStartDelay = hap_constant->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_constant->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_constant->attack_length==0) && (hap_constant->fade_length==0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CONVERT(hap_constant->attack_level);
+            envelope->dwAttackTime = hap_constant->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_constant->fade_level);
+            envelope->dwFadeTime = hap_constant->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         hap_periodic = &src->periodic;
+         periodic = SDL_malloc(sizeof(DIPERIODIC));
+         if (periodic == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(periodic, 0, sizeof(DIPERIODIC));
+
+         /* Specifics */
+         periodic->dwMagnitude = CONVERT(hap_periodic->magnitude);
+         periodic->lOffset = CONVERT(hap_periodic->offset);
+         periodic->dwPhase = hap_periodic->phase;
+         periodic->dwPeriod = hap_periodic->period * 1000;
+         dest->cbTypeSpecificParams = sizeof(DIPERIODIC);
+         dest->lpvTypeSpecificParams = periodic;
+
+         /* Generics */
+         dest->dwDuration = hap_periodic->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = DIGetTriggerButton(hap_periodic->button);
+         dest->dwTriggerRepeatInterval = hap_periodic->interval;
+         dest->dwStartDelay = hap_periodic->delay * 1000; /* In microseconds. */
+         
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_periodic->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_periodic->attack_length==0) && (hap_periodic->fade_length==0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CONVERT(hap_periodic->attack_level);
+            envelope->dwAttackTime = hap_periodic->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_periodic->fade_level);
+            envelope->dwFadeTime = hap_periodic->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         hap_condition = &src->condition;
+         condition = SDL_malloc(sizeof(DICONDITION) * dest->cAxes);
+         if (condition == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(condition, 0, sizeof(DICONDITION));
+
+         /* Specifics */
+         for (i=0; i<(int)dest->cAxes; i++) {
+            condition[i].lOffset = CONVERT(hap_condition->center[i]);
+            condition[i].lPositiveCoefficient = CONVERT(hap_condition->right_coeff[i]);
+            condition[i].lNegativeCoefficient = CONVERT(hap_condition->left_coeff[i]);
+            condition[i].dwPositiveSaturation = CONVERT(hap_condition->right_sat[i]);
+            condition[i].dwNegativeSaturation = CONVERT(hap_condition->left_sat[i]);
+            condition[i].lDeadBand = CONVERT(hap_condition->deadband[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(DICONDITION) * dest->cAxes;
+         dest->lpvTypeSpecificParams = condition;
+
+         /* Generics */
+         dest->dwDuration = hap_condition->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = DIGetTriggerButton(hap_condition->button);
+         dest->dwTriggerRepeatInterval = hap_condition->interval;
+         dest->dwStartDelay = hap_condition->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_condition->direction, dest->cAxes) < 0) {
+            return -1;                
+         }                            
+                                      
+         /* Envelope - Not actually supported by most CONDITION implementations. */
+         SDL_free(dest->lpEnvelope);
+         dest->lpEnvelope = NULL;
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         hap_ramp = &src->ramp;
+         ramp = SDL_malloc(sizeof(DIRAMPFORCE));
+         if (ramp == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(ramp, 0, sizeof(DIRAMPFORCE));
+
+         /* Specifics */
+         ramp->lStart = CONVERT(hap_ramp->start);
+         ramp->lEnd = CONVERT(hap_ramp->end);
+         dest->cbTypeSpecificParams = sizeof(DIRAMPFORCE);
+         dest->lpvTypeSpecificParams = ramp;
+
+         /* Generics */
+         dest->dwDuration = hap_ramp->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = DIGetTriggerButton(hap_ramp->button);
+         dest->dwTriggerRepeatInterval = hap_ramp->interval;
+         dest->dwStartDelay = hap_ramp->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_ramp->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+
+         /* Envelope */
+         if ((hap_ramp->attack_length==0) && (hap_ramp->fade_length==0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CONVERT(hap_ramp->attack_level);
+            envelope->dwAttackTime = hap_ramp->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_ramp->fade_level);
+            envelope->dwFadeTime = hap_ramp->fade_length * 1000;
+         }
+
+         break;
+
+      case SDL_HAPTIC_CUSTOM:
+         hap_custom = &src->custom;
+         custom = SDL_malloc(sizeof(DICUSTOMFORCE));
+         if (custom == NULL) {
+            SDL_OutOfMemory();
+            return -1;
+         }
+         SDL_memset(custom, 0, sizeof(DICUSTOMFORCE));
+
+         /* Specifics */
+         custom->cChannels = hap_custom->channels;
+         custom->dwSamplePeriod = hap_custom->period * 1000;
+         custom->cSamples = hap_custom->samples;
+         custom->rglForceData = SDL_malloc(sizeof(LONG)*custom->cSamples*custom->cChannels);
+         for (i=0; i<hap_custom->samples*hap_custom->channels; i++) { /* Copy data. */
+            custom->rglForceData[i] = CONVERT(hap_custom->data[i]);
+         }
+         dest->cbTypeSpecificParams = sizeof(DICUSTOMFORCE);
+         dest->lpvTypeSpecificParams = custom;
+
+         /* Generics */
+         dest->dwDuration = hap_custom->length * 1000; /* In microseconds. */
+         dest->dwTriggerButton = DIGetTriggerButton(hap_custom->button);
+         dest->dwTriggerRepeatInterval = hap_custom->interval;
+         dest->dwStartDelay = hap_custom->delay * 1000; /* In microseconds. */
+
+         /* Direction. */
+         if (SDL_SYS_SetDirection(dest, &hap_custom->direction, dest->cAxes) < 0) {
+            return -1;
+         }
+         
+         /* Envelope */
+         if ((hap_custom->attack_length==0) && (hap_custom->fade_length==0)) {
+            SDL_free(dest->lpEnvelope);
+            dest->lpEnvelope = NULL;
+         }
+         else {
+            envelope->dwAttackLevel = CONVERT(hap_custom->attack_level);
+            envelope->dwAttackTime = hap_custom->attack_length * 1000;
+            envelope->dwFadeLevel = CONVERT(hap_custom->fade_level);
+            envelope->dwFadeTime = hap_custom->fade_length * 1000;
+         }
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees an DIEFFECT allocated by SDL_SYS_ToDIEFFECT.
+ */
+static void
+SDL_SYS_HapticFreeDIEFFECT( DIEFFECT * effect, int type )
+{
+   DICUSTOMFORCE *custom;
+
+   if (effect->lpEnvelope != NULL) {
+      SDL_free(effect->lpEnvelope);
+      effect->lpEnvelope = NULL;
+   }
+   if (effect->rgdwAxes != NULL) {
+      SDL_free(effect->rgdwAxes);
+      effect->rgdwAxes = NULL;
+   }
+   if (effect->lpvTypeSpecificParams != NULL) {
+      if (type == SDL_HAPTIC_CUSTOM) { /* Must free the custom data. */
+         custom = (DICUSTOMFORCE*) effect->lpvTypeSpecificParams;
+         SDL_free(custom->rglForceData);
+         custom->rglForceData = NULL;
+      }
+      SDL_free(effect->lpvTypeSpecificParams);
+      effect->lpvTypeSpecificParams = NULL;
+   }
+   if (effect->rglDirection != NULL) {
+      SDL_free(effect->rglDirection);
+      effect->rglDirection = NULL;
+   }
+}
+
+
+/*
+ * Gets the effect type from the generic SDL haptic effect wrapper.
+ */
+static REFGUID
+SDL_SYS_HapticEffectType(SDL_HapticEffect * effect)
+{
+   switch (effect->type) {
+      case SDL_HAPTIC_CONSTANT:
+         return &GUID_ConstantForce;
+
+      case SDL_HAPTIC_RAMP:
+         return &GUID_RampForce;
+
+      case SDL_HAPTIC_SQUARE:
+         return &GUID_Square;
+
+      case SDL_HAPTIC_SINE:
+         return &GUID_Sine;
+
+      case SDL_HAPTIC_TRIANGLE:
+         return &GUID_Triangle;
+
+      case SDL_HAPTIC_SAWTOOTHUP:
+         return &GUID_SawtoothUp;
+
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         return &GUID_SawtoothDown;
+
+      case SDL_HAPTIC_SPRING:
+         return &GUID_Spring;
+
+      case SDL_HAPTIC_DAMPER:
+         return &GUID_Damper;
+
+      case SDL_HAPTIC_INERTIA:
+         return &GUID_Inertia;
+
+      case SDL_HAPTIC_FRICTION:
+         return &GUID_Friction;
+
+      case SDL_HAPTIC_CUSTOM:
+         return &GUID_CustomForce;
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return NULL;
+   }
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   HRESULT ret;
+
+   /* Get the type. */
+   REFGUID type = SDL_SYS_HapticEffectType(base);
+   if (type == NULL) {
+      goto err_hweffect;
+   }
+
+   /* Alloc the effect. */
+   effect->hweffect = (struct haptic_hweffect *)
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      goto err_hweffect;
+   }
+
+   /* Get the effect. */
+   if (SDL_SYS_ToDIEFFECT(haptic, &effect->hweffect->effect, base) < 0) {
+      goto err_effectdone;
+   }
+
+   /* Create the actual effect. */
+   ret = IDirectInputDevice2_CreateEffect(haptic->hwdata->device, type,
+         &effect->hweffect->effect, &effect->hweffect->ref, NULL);
+   if (FAILED(ret)) {
+      DI_SetError("Unable to create effect",ret);
+      goto err_effectdone;
+   }
+
+   return 0;
+
+err_effectdone:
+   SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect, base->type);
+err_hweffect:
+   if (effect->hweffect != NULL) {
+      SDL_free(effect->hweffect);
+      effect->hweffect = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ */
+int
+SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   HRESULT ret;
+   DWORD flags;
+   DIEFFECT temp;
+
+   /* Get the effect. */
+   SDL_memset(&temp, 0, sizeof(DIEFFECT));
+   if (SDL_SYS_ToDIEFFECT(haptic, &temp, data) < 0) {
+      goto err_update;
+   }
+
+   /* Set the flags.  Might be worthwhile to diff temp with loaded effect and
+    *  only change those parameters. */
+   flags = DIEP_DIRECTION | 
+           DIEP_DURATION |
+           DIEP_ENVELOPE |
+           DIEP_STARTDELAY |
+           DIEP_TRIGGERBUTTON |
+           DIEP_TRIGGERREPEATINTERVAL |
+           DIEP_TYPESPECIFICPARAMS;
+
+   /* Create the actual effect. */
+   ret = IDirectInputEffect_SetParameters(effect->hweffect->ref, &temp, flags);
+   if (FAILED(ret)) {
+      DI_SetError("Unable to update effect",ret);
+      goto err_update;
+   }
+
+   /* Copy it over. */
+   SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect, data->type);
+   SDL_memcpy(&effect->hweffect->effect, &temp, sizeof(DIEFFECT));
+
+   return 0;
+
+err_update:
+   SDL_SYS_HapticFreeDIEFFECT(&temp, data->type);
+   return -1;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   HRESULT ret;
+   DWORD iter;
+
+   /* Check if it's infinite. */
+   if (iterations == SDL_HAPTIC_INFINITY) {
+      iter = INFINITE;
+   }
+   else
+      iter = iterations;
+
+   /* Run the effect. */
+   ret = IDirectInputEffect_Start( effect->hweffect->ref, iter, 0 );
+   if (FAILED(ret)) {
+      DI_SetError("Running the effect",ret);
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = IDirectInputEffect_Stop(effect->hweffect->ref);
+   if (FAILED(ret)) {
+      DI_SetError("Unable to stop effect",ret);
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+
+   ret = IDirectInputEffect_Unload(effect->hweffect->ref);
+   if (FAILED(ret)) {
+      DI_SetError("Removing effect from the device",ret);
+   }
+   SDL_SYS_HapticFreeDIEFFECT(&effect->hweffect->effect, effect->effect.type);   
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   HRESULT ret;
+   DWORD status;
+
+   ret = IDirectInputEffect_GetEffectStatus(effect->hweffect->ref, &status);
+   if (FAILED(ret)) {
+      DI_SetError("Getting effect status",ret);
+      return -1;
+   }
+
+   if (status == 0) return SDL_FALSE;
+   return SDL_TRUE;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   HRESULT ret;
+   DIPROPDWORD dipdw;
+
+   /* Create the weird structure thingy. */
+   dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
+   dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+   dipdw.diph.dwObj        = 0;
+   dipdw.diph.dwHow        = DIPH_DEVICE;
+   dipdw.dwData            = gain * 100; /* 0 to 10,000 */
+
+   /* Try to set the autocenter. */
+   ret = IDirectInputDevice2_SetProperty( haptic->hwdata->device,
+                                          DIPROP_FFGAIN, &dipdw.diph );
+   if (FAILED(ret)) {
+      DI_SetError("Setting gain",ret);
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   HRESULT ret;
+   DIPROPDWORD dipdw;
+
+   /* Create the weird structure thingy. */
+   dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
+   dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+   dipdw.diph.dwObj        = 0;
+   dipdw.diph.dwHow        = DIPH_DEVICE;
+   dipdw.dwData            = (autocenter == 0) ? DIPROPAUTOCENTER_OFF : 
+                                                 DIPROPAUTOCENTER_ON;
+
+   /* Try to set the autocenter. */
+   ret = IDirectInputDevice2_SetProperty( haptic->hwdata->device,
+                                          DIPROP_AUTOCENTER, &dipdw.diph );
+   if (FAILED(ret)) {
+      DI_SetError("Setting autocenter",ret);
+      return -1;
+   }
+  
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   /* Pause the device. */
+   ret = IDirectInputDevice2_SendForceFeedbackCommand( haptic->hwdata->device,
+                                                       DISFFC_PAUSE );
+   if (FAILED(ret)) {
+      DI_SetError("Pausing the device",ret);
+      return -1;
+   }
+   
+   return 0;
+}
+
+
+/*
+ * Pauses the device.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   /* Unpause the device. */
+   ret = IDirectInputDevice2_SendForceFeedbackCommand( haptic->hwdata->device,
+                                                       DISFFC_CONTINUE );
+   if (FAILED(ret)) {
+      DI_SetError("Pausing the device",ret);
+      return -1;
+   }
+   
+   return 0;
+}
+
+
+/*
+ * Stops all the playing effects on the device.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   HRESULT ret;
+
+   /* Try to stop the effects. */
+   ret = IDirectInputDevice2_SendForceFeedbackCommand( haptic->hwdata->device,
+                                                       DISFFC_STOPALL );
+   if (FAILED(ret)) {
+      DI_SetError("Stopping the device",ret);
+      return -1;
+   }
+   
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_DINPUT */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/hermes/mmx_main.asm SDL-1.2.13_OOx64/src/hermes/mmx_main.asm
--- SDL-1.2.13/src/hermes/mmx_main.asm	2007-12-31 04:47:53 +0000
+++ SDL-1.2.13_OOx64/src/hermes/mmx_main.asm	2013-10-03 18:48:18 +0000
@@ -11,7 +11,7 @@
 
 %include "common.inc"
 
-SDL_FUNC _ConvertMMX
+SDL_FUNC ConvertMMX
 
 SECTION .text
 		
@@ -29,8 +29,8 @@
 ;;  28:	int d_add
 ;;  32:	void (*converter_function)() 
 ;;  36: int32 *lookup
-	
-_ConvertMMX:
+
+ConvertMMX:
 	push ebp
 	mov ebp,esp
 
diff -ruN SDL-1.2.13/src/hermes/mmxp2_32.asm SDL-1.2.13_OOx64/src/hermes/mmxp2_32.asm
--- SDL-1.2.13/src/hermes/mmxp2_32.asm	2007-12-31 04:47:53 +0000
+++ SDL-1.2.13_OOx64/src/hermes/mmxp2_32.asm	2013-10-03 18:48:28 +0000
@@ -22,11 +22,11 @@
 
 %include "common.inc"
 	
-SDL_FUNC _ConvertMMXpII32_24RGB888
-SDL_FUNC _ConvertMMXpII32_16RGB565
-SDL_FUNC _ConvertMMXpII32_16BGR565
-SDL_FUNC _ConvertMMXpII32_16RGB555
-SDL_FUNC _ConvertMMXpII32_16BGR555
+SDL_FUNC ConvertMMXpII32_24RGB888
+SDL_FUNC ConvertMMXpII32_16RGB565
+SDL_FUNC ConvertMMXpII32_16BGR565
+SDL_FUNC ConvertMMXpII32_16RGB555
+SDL_FUNC ConvertMMXpII32_16BGR555
 
 ;; Macros for conversion routines
 
@@ -60,7 +60,7 @@
 
 SECTION .text
 
-_ConvertMMXpII32_24RGB888:
+ConvertMMXpII32_24RGB888:
 
         ; set up mm6 as the mask, mm7 as zero
         load_immq mm6, mmx32_rgb888_mask
@@ -123,7 +123,7 @@
 
 
 
-_ConvertMMXpII32_16RGB565:
+ConvertMMXpII32_16RGB565:
 
         ; set up masks
         load_immq mm5, mmx32_rgb565_b
@@ -191,7 +191,7 @@
 	retn
 
 	
-_ConvertMMXpII32_16BGR565:
+ConvertMMXpII32_16BGR565:
 
         load_immq mm5, mmx32_rgb565_r
         load_immq mm6, mmx32_rgb565_g
@@ -260,7 +260,7 @@
 .L4:
         retn
 
-_ConvertMMXpII32_16BGR555:
+ConvertMMXpII32_16BGR555:
 
         ; the 16BGR555 converter is identical to the RGB555 one,
         ; except it uses a different multiplier for the pmaddwd
@@ -274,7 +274,7 @@
 ; would almost certainly be faster, even if only a little.
 ; I did rename 'mmx32_rgb555_add' to 'mmx32_rgb555_mul', which is
 ; (I think) a more accurate name..
-_ConvertMMXpII32_16RGB555:
+ConvertMMXpII32_16RGB555:
 
 	load_immq mm7, mmx32_rgb555_mul
 _convert_bgr555_cheat:
diff -ruN SDL-1.2.13/src/hermes/x86_main.asm SDL-1.2.13_OOx64/src/hermes/x86_main.asm
--- SDL-1.2.13/src/hermes/x86_main.asm	2007-12-31 04:47:53 +0000
+++ SDL-1.2.13_OOx64/src/hermes/x86_main.asm	2013-10-03 18:48:32 +0000
@@ -13,7 +13,7 @@
 
 %include "common.inc"
 
-SDL_FUNC _ConvertX86
+SDL_FUNC ConvertX86
 
 SECTION .text
 		
@@ -32,7 +32,7 @@
 ;;  32:	void (*converter_function)() 
 ;;  36: int32 *lookup
 	
-_ConvertX86:
+ConvertX86:
 	push ebp
 	mov ebp,esp
 
diff -ruN SDL-1.2.13/src/hermes/x86p_16.asm SDL-1.2.13_OOx64/src/hermes/x86p_16.asm
--- SDL-1.2.13/src/hermes/x86p_16.asm	2007-12-31 04:47:53 +0000
+++ SDL-1.2.13_OOx64/src/hermes/x86p_16.asm	2013-10-03 18:48:10 +0000
@@ -14,16 +14,16 @@
 
 %include "common.inc"
 
-SDL_FUNC _ConvertX86p16_16BGR565
-SDL_FUNC _ConvertX86p16_16RGB555
-SDL_FUNC _ConvertX86p16_16BGR555
-SDL_FUNC _ConvertX86p16_8RGB332
+SDL_FUNC ConvertX86p16_16BGR565
+SDL_FUNC ConvertX86p16_16RGB555
+SDL_FUNC ConvertX86p16_16BGR555
+SDL_FUNC ConvertX86p16_8RGB332
 
-EXTERN _ConvertX86
+EXTERN ConvertX86
 
 SECTION .text
 
-_ConvertX86p16_16BGR565:
+ConvertX86p16_16BGR565:
 
     ; check short
     cmp ecx,BYTE 16
@@ -133,7 +133,7 @@
 
 
 
-_ConvertX86p16_16RGB555:
+ConvertX86p16_16RGB555:
 
     ; check short
     cmp ecx,BYTE 32
@@ -241,7 +241,7 @@
 
 
 
-_ConvertX86p16_16BGR555:
+ConvertX86p16_16BGR555:
 
     ; check short
     cmp ecx,BYTE 16
@@ -359,7 +359,7 @@
 
 
 
-_ConvertX86p16_8RGB332:
+ConvertX86p16_8RGB332:
 
     ; check short
     cmp ecx,BYTE 16
diff -ruN SDL-1.2.13/src/hermes/x86p_32.asm SDL-1.2.13_OOx64/src/hermes/x86p_32.asm
--- SDL-1.2.13/src/hermes/x86p_32.asm	2007-12-31 04:47:53 +0000
+++ SDL-1.2.13_OOx64/src/hermes/x86p_32.asm	2013-10-03 18:48:14 +0000
@@ -13,16 +13,16 @@
 
 %include "common.inc"
 
-SDL_FUNC _ConvertX86p32_32BGR888
-SDL_FUNC _ConvertX86p32_32RGBA888
-SDL_FUNC _ConvertX86p32_32BGRA888
-SDL_FUNC _ConvertX86p32_24RGB888	
-SDL_FUNC _ConvertX86p32_24BGR888
-SDL_FUNC _ConvertX86p32_16RGB565
-SDL_FUNC _ConvertX86p32_16BGR565
-SDL_FUNC _ConvertX86p32_16RGB555
-SDL_FUNC _ConvertX86p32_16BGR555
-SDL_FUNC _ConvertX86p32_8RGB332
+SDL_FUNC ConvertX86p32_32BGR888
+SDL_FUNC ConvertX86p32_32RGBA888
+SDL_FUNC ConvertX86p32_32BGRA888
+SDL_FUNC ConvertX86p32_24RGB888	
+SDL_FUNC ConvertX86p32_24BGR888
+SDL_FUNC ConvertX86p32_16RGB565
+SDL_FUNC ConvertX86p32_16BGR565
+SDL_FUNC ConvertX86p32_16RGB555
+SDL_FUNC ConvertX86p32_16BGR555
+SDL_FUNC ConvertX86p32_8RGB332
 
 SECTION .text
 
@@ -35,7 +35,7 @@
 ;;   EAX, EBX, EDX
 
 
-_ConvertX86p32_32BGR888:
+ConvertX86p32_32BGR888:
 
     ; check short
     cmp ecx,BYTE 32
@@ -116,7 +116,7 @@
 
 	
 		
-_ConvertX86p32_32RGBA888:
+ConvertX86p32_32RGBA888:
 	
     ; check short
     cmp ecx,BYTE 32
@@ -187,7 +187,7 @@
 	
 
 
-_ConvertX86p32_32BGRA888:
+ConvertX86p32_32BGRA888:
 
     ; check short
     cmp ecx,BYTE 32
@@ -262,7 +262,7 @@
 	
 ;; 32 bit RGB 888 to 24 BIT RGB 888
 
-_ConvertX86p32_24RGB888:
+ConvertX86p32_24RGB888:
 
 	; check short
 	cmp ecx,BYTE 32
@@ -359,7 +359,7 @@
 
 ;; 32 bit RGB 888 to 24 bit BGR 888
 
-_ConvertX86p32_24BGR888:
+ConvertX86p32_24BGR888:
 
 	; check short
 	cmp ecx,BYTE 32
@@ -460,7 +460,7 @@
 		
 ;; 32 bit RGB 888 to 16 BIT RGB 565 
 
-_ConvertX86p32_16RGB565:
+ConvertX86p32_16RGB565:
 	; check short
 	cmp ecx,BYTE 16
 	ja .L3
@@ -575,7 +575,7 @@
 	
 ;; 32 bit RGB 888 to 16 BIT BGR 565 
 
-_ConvertX86p32_16BGR565:
+ConvertX86p32_16BGR565:
 	
 	; check short
 	cmp ecx,BYTE 16
@@ -689,7 +689,7 @@
 	
 ;; 32 BIT RGB TO 16 BIT RGB 555
 
-_ConvertX86p32_16RGB555:
+ConvertX86p32_16RGB555:
 
 	; check short
 	cmp ecx,BYTE 16
@@ -800,7 +800,7 @@
 
 ;; 32 BIT RGB TO 16 BIT BGR 555
 	
-_ConvertX86p32_16BGR555:
+ConvertX86p32_16BGR555:
 	
 	; check short
 	cmp ecx,BYTE 16
@@ -917,7 +917,7 @@
 ;; FROM 32 BIT RGB to 8 BIT RGB (rrrgggbbb)
 ;; This routine writes FOUR pixels at once (dword) and then, if they exist
 ;; the trailing three pixels
-_ConvertX86p32_8RGB332:
+ConvertX86p32_8RGB332:
 
 	
 .L_ALIGNED
diff -ruN SDL-1.2.13/src/joystick/SDL_joystick.c SDL-1.2.13_OOx64/src/joystick/SDL_joystick.c
--- SDL-1.2.13/src/joystick/SDL_joystick.c	2007-12-31 04:47:55 +0000
+++ SDL-1.2.13_OOx64/src/joystick/SDL_joystick.c	2017-12-19 14:10:51 +0000
@@ -190,7 +190,7 @@
 	return(opened);
 }
 
-static int ValidJoystick(SDL_Joystick **joystick)
+int SDL_PrivateJoystickValid(SDL_Joystick **joystick)
 {
 	int valid;
 
@@ -211,7 +211,7 @@
  */
 int SDL_JoystickIndex(SDL_Joystick *joystick)
 {
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->index);
@@ -222,7 +222,7 @@
  */
 int SDL_JoystickNumAxes(SDL_Joystick *joystick)
 {
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->naxes);
@@ -233,7 +233,7 @@
  */
 int SDL_JoystickNumHats(SDL_Joystick *joystick)
 {
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nhats);
@@ -244,7 +244,7 @@
  */
 int SDL_JoystickNumBalls(SDL_Joystick *joystick)
 {
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nballs);
@@ -255,7 +255,7 @@
  */
 int SDL_JoystickNumButtons(SDL_Joystick *joystick)
 {
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 	return(joystick->nbuttons);
@@ -268,7 +268,7 @@
 {
 	Sint16 state;
 
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(0);
 	}
 	if ( axis < joystick->naxes ) {
@@ -287,7 +287,7 @@
 {
 	Uint8 state;
 
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(0);
 	}
 	if ( hat < joystick->nhats ) {
@@ -306,7 +306,7 @@
 {
 	int retval;
 
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(-1);
 	}
 
@@ -334,7 +334,7 @@
 {
 	Uint8 state;
 
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return(0);
 	}
 	if ( button < joystick->nbuttons ) {
@@ -353,7 +353,7 @@
 {
 	int i;
 
-	if ( ! ValidJoystick(&joystick) ) {
+	if ( ! SDL_PrivateJoystickValid(&joystick) ) {
 		return;
 	}
 
diff -ruN SDL-1.2.13/src/joystick/SDL_joystick.c.bak SDL-1.2.13_OOx64/src/joystick/SDL_joystick.c.bak
--- SDL-1.2.13/src/joystick/SDL_joystick.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/SDL_joystick.c.bak	2007-12-30 18:47:56 +0000
@@ -0,0 +1,573 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* This is the joystick API for Simple DirectMedia Layer */
+
+#include "SDL_events.h"
+#include "SDL_sysjoystick.h"
+#include "SDL_joystick_c.h"
+#if !SDL_EVENTS_DISABLED
+#include "../events/SDL_events_c.h"
+#endif
+
+/* This is used for Quake III Arena */
+#if SDL_EVENTS_DISABLED
+#define SDL_Lock_EventThread()
+#define SDL_Unlock_EventThread()
+#endif
+
+Uint8 SDL_numjoysticks = 0;
+SDL_Joystick **SDL_joysticks = NULL;
+static SDL_Joystick *default_joystick = NULL;
+
+int SDL_JoystickInit(void)
+{
+	int arraylen;
+	int status;
+
+	SDL_numjoysticks = 0;
+	status = SDL_SYS_JoystickInit();
+	if ( status >= 0 ) {
+		arraylen = (status+1)*sizeof(*SDL_joysticks);
+		SDL_joysticks = (SDL_Joystick **)SDL_malloc(arraylen);
+		if ( SDL_joysticks == NULL ) {
+			SDL_numjoysticks = 0;
+		} else {
+			SDL_memset(SDL_joysticks, 0, arraylen);
+			SDL_numjoysticks = status;
+		}
+		status = 0;
+	}
+	default_joystick = NULL;
+	return(status);
+}
+
+/*
+ * Count the number of joysticks attached to the system
+ */
+int SDL_NumJoysticks(void)
+{
+	return SDL_numjoysticks;
+}
+
+/*
+ * Get the implementation dependent name of a joystick
+ */
+const char *SDL_JoystickName(int device_index)
+{
+	if ( (device_index < 0) || (device_index >= SDL_numjoysticks) ) {
+		SDL_SetError("There are %d joysticks available",
+		             SDL_numjoysticks);
+		return(NULL);
+	}
+	return(SDL_SYS_JoystickName(device_index));
+}
+
+/*
+ * Open a joystick for use - the index passed as an argument refers to
+ * the N'th joystick on the system.  This index is the value which will
+ * identify this joystick in future joystick events.
+ *
+ * This function returns a joystick identifier, or NULL if an error occurred.
+ */
+SDL_Joystick *SDL_JoystickOpen(int device_index)
+{
+	int i;
+	SDL_Joystick *joystick;
+
+	if ( (device_index < 0) || (device_index >= SDL_numjoysticks) ) {
+		SDL_SetError("There are %d joysticks available",
+		             SDL_numjoysticks);
+		return(NULL);
+	}
+
+	/* If the joystick is already open, return it */
+	for ( i=0; SDL_joysticks[i]; ++i ) {
+		if ( device_index == SDL_joysticks[i]->index ) {
+			joystick = SDL_joysticks[i];
+			++joystick->ref_count;
+			return(joystick);
+		}
+	}
+
+	/* Create and initialize the joystick */
+	joystick = (SDL_Joystick *)SDL_malloc((sizeof *joystick));
+	if ( joystick != NULL ) {
+		SDL_memset(joystick, 0, (sizeof *joystick));
+		joystick->index = device_index;
+		if ( SDL_SYS_JoystickOpen(joystick) < 0 ) {
+			SDL_free(joystick);
+			joystick = NULL;
+		} else {
+			if ( joystick->naxes > 0 ) {
+				joystick->axes = (Sint16 *)SDL_malloc
+					(joystick->naxes*sizeof(Sint16));
+			}
+			if ( joystick->nhats > 0 ) {
+				joystick->hats = (Uint8 *)SDL_malloc
+					(joystick->nhats*sizeof(Uint8));
+			}
+			if ( joystick->nballs > 0 ) {
+				joystick->balls = (struct balldelta *)SDL_malloc
+				  (joystick->nballs*sizeof(*joystick->balls));
+			}
+			if ( joystick->nbuttons > 0 ) {
+				joystick->buttons = (Uint8 *)SDL_malloc
+					(joystick->nbuttons*sizeof(Uint8));
+			}
+			if ( ((joystick->naxes > 0) && !joystick->axes)
+			  || ((joystick->nhats > 0) && !joystick->hats)
+			  || ((joystick->nballs > 0) && !joystick->balls)
+			  || ((joystick->nbuttons > 0) && !joystick->buttons)) {
+				SDL_OutOfMemory();
+				SDL_JoystickClose(joystick);
+				joystick = NULL;
+			}
+			if ( joystick->axes ) {
+				SDL_memset(joystick->axes, 0,
+					joystick->naxes*sizeof(Sint16));
+			}
+			if ( joystick->hats ) {
+				SDL_memset(joystick->hats, 0,
+					joystick->nhats*sizeof(Uint8));
+			}
+			if ( joystick->balls ) {
+				SDL_memset(joystick->balls, 0,
+				  joystick->nballs*sizeof(*joystick->balls));
+			}
+			if ( joystick->buttons ) {
+				SDL_memset(joystick->buttons, 0,
+					joystick->nbuttons*sizeof(Uint8));
+			}
+		}
+	}
+	if ( joystick ) {
+		/* Add joystick to list */
+		++joystick->ref_count;
+		SDL_Lock_EventThread();
+		for ( i=0; SDL_joysticks[i]; ++i )
+			/* Skip to next joystick */;
+		SDL_joysticks[i] = joystick;
+		SDL_Unlock_EventThread();
+	}
+	return(joystick);
+}
+
+/*
+ * Returns 1 if the joystick has been opened, or 0 if it has not.
+ */
+int SDL_JoystickOpened(int device_index)
+{
+	int i, opened;
+
+	opened = 0;
+	for ( i=0; SDL_joysticks[i]; ++i ) {
+		if ( SDL_joysticks[i]->index == (Uint8)device_index ) {
+			opened = 1;
+			break;
+		}
+	}
+	return(opened);
+}
+
+static int ValidJoystick(SDL_Joystick **joystick)
+{
+	int valid;
+
+	if ( *joystick == NULL ) {
+		*joystick = default_joystick;
+	}
+	if ( *joystick == NULL ) {
+		SDL_SetError("Joystick hasn't been opened yet");
+		valid = 0;
+	} else {
+		valid = 1;
+	}
+	return valid;
+}
+
+/*
+ * Get the device index of an opened joystick.
+ */
+int SDL_JoystickIndex(SDL_Joystick *joystick)
+{
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+	return(joystick->index);
+}
+
+/*
+ * Get the number of multi-dimensional axis controls on a joystick
+ */
+int SDL_JoystickNumAxes(SDL_Joystick *joystick)
+{
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+	return(joystick->naxes);
+}
+
+/*
+ * Get the number of hats on a joystick
+ */
+int SDL_JoystickNumHats(SDL_Joystick *joystick)
+{
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+	return(joystick->nhats);
+}
+
+/*
+ * Get the number of trackballs on a joystick
+ */
+int SDL_JoystickNumBalls(SDL_Joystick *joystick)
+{
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+	return(joystick->nballs);
+}
+
+/*
+ * Get the number of buttons on a joystick
+ */
+int SDL_JoystickNumButtons(SDL_Joystick *joystick)
+{
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+	return(joystick->nbuttons);
+}
+
+/*
+ * Get the current state of an axis control on a joystick
+ */
+Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis)
+{
+	Sint16 state;
+
+	if ( ! ValidJoystick(&joystick) ) {
+		return(0);
+	}
+	if ( axis < joystick->naxes ) {
+		state = joystick->axes[axis];
+	} else {
+		SDL_SetError("Joystick only has %d axes", joystick->naxes);
+		state = 0;
+	}
+	return(state);
+}
+
+/*
+ * Get the current state of a hat on a joystick
+ */
+Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick, int hat)
+{
+	Uint8 state;
+
+	if ( ! ValidJoystick(&joystick) ) {
+		return(0);
+	}
+	if ( hat < joystick->nhats ) {
+		state = joystick->hats[hat];
+	} else {
+		SDL_SetError("Joystick only has %d hats", joystick->nhats);
+		state = 0;
+	}
+	return(state);
+}
+
+/*
+ * Get the ball axis change since the last poll
+ */
+int SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy)
+{
+	int retval;
+
+	if ( ! ValidJoystick(&joystick) ) {
+		return(-1);
+	}
+
+	retval = 0;
+	if ( ball < joystick->nballs ) {
+		if ( dx ) {
+			*dx = joystick->balls[ball].dx;
+		}
+		if ( dy ) {
+			*dy = joystick->balls[ball].dy;
+		}
+		joystick->balls[ball].dx = 0;
+		joystick->balls[ball].dy = 0;
+	} else {
+		SDL_SetError("Joystick only has %d balls", joystick->nballs);
+		retval = -1;
+	}
+	return(retval);
+}
+
+/*
+ * Get the current state of a button on a joystick
+ */
+Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick, int button)
+{
+	Uint8 state;
+
+	if ( ! ValidJoystick(&joystick) ) {
+		return(0);
+	}
+	if ( button < joystick->nbuttons ) {
+		state = joystick->buttons[button];
+	} else {
+		SDL_SetError("Joystick only has %d buttons",joystick->nbuttons);
+		state = 0;
+	}
+	return(state);
+}
+
+/*
+ * Close a joystick previously opened with SDL_JoystickOpen()
+ */
+void SDL_JoystickClose(SDL_Joystick *joystick)
+{
+	int i;
+
+	if ( ! ValidJoystick(&joystick) ) {
+		return;
+	}
+
+	/* First decrement ref count */
+	if ( --joystick->ref_count > 0 ) {
+		return;
+	}
+
+	/* Lock the event queue - prevent joystick polling */
+	SDL_Lock_EventThread();
+
+	if ( joystick == default_joystick ) {
+		default_joystick = NULL;
+	}
+	SDL_SYS_JoystickClose(joystick);
+
+	/* Remove joystick from list */
+	for ( i=0; SDL_joysticks[i]; ++i ) {
+		if ( joystick == SDL_joysticks[i] ) {
+			SDL_memcpy(&SDL_joysticks[i], &SDL_joysticks[i+1],
+			       (SDL_numjoysticks-i)*sizeof(joystick));
+			break;
+		}
+	}
+
+	/* Let the event thread keep running */
+	SDL_Unlock_EventThread();
+
+	/* Free the data associated with this joystick */
+	if ( joystick->axes ) {
+		SDL_free(joystick->axes);
+	}
+	if ( joystick->hats ) {
+		SDL_free(joystick->hats);
+	}
+	if ( joystick->balls ) {
+		SDL_free(joystick->balls);
+	}
+	if ( joystick->buttons ) {
+		SDL_free(joystick->buttons);
+	}
+	SDL_free(joystick);
+}
+
+void SDL_JoystickQuit(void)
+{
+	/* Stop the event polling */
+	SDL_Lock_EventThread();
+	SDL_numjoysticks = 0;
+	SDL_Unlock_EventThread();
+
+	/* Quit the joystick setup */
+	SDL_SYS_JoystickQuit();
+	if ( SDL_joysticks ) {
+		SDL_free(SDL_joysticks);
+		SDL_joysticks = NULL;
+	}
+}
+
+
+/* These are global for SDL_sysjoystick.c and SDL_events.c */
+
+int SDL_PrivateJoystickAxis(SDL_Joystick *joystick, Uint8 axis, Sint16 value)
+{
+	int posted;
+
+	/* Update internal joystick state */
+	joystick->axes[axis] = value;
+
+	/* Post the event, if desired */
+	posted = 0;
+#if !SDL_EVENTS_DISABLED
+	if ( SDL_ProcessEvents[SDL_JOYAXISMOTION] == SDL_ENABLE ) {
+		SDL_Event event;
+		event.type = SDL_JOYAXISMOTION;
+		event.jaxis.which = joystick->index;
+		event.jaxis.axis = axis;
+		event.jaxis.value = value;
+		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
+			posted = 1;
+			SDL_PushEvent(&event);
+		}
+	}
+#endif /* !SDL_EVENTS_DISABLED */
+	return(posted);
+}
+
+int SDL_PrivateJoystickHat(SDL_Joystick *joystick, Uint8 hat, Uint8 value)
+{
+	int posted;
+
+	/* Update internal joystick state */
+	joystick->hats[hat] = value;
+
+	/* Post the event, if desired */
+	posted = 0;
+#if !SDL_EVENTS_DISABLED
+	if ( SDL_ProcessEvents[SDL_JOYHATMOTION] == SDL_ENABLE ) {
+		SDL_Event event;
+		event.jhat.type = SDL_JOYHATMOTION;
+		event.jhat.which = joystick->index;
+		event.jhat.hat = hat;
+		event.jhat.value = value;
+		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
+			posted = 1;
+			SDL_PushEvent(&event);
+		}
+	}
+#endif /* !SDL_EVENTS_DISABLED */
+	return(posted);
+}
+
+int SDL_PrivateJoystickBall(SDL_Joystick *joystick, Uint8 ball,
+					Sint16 xrel, Sint16 yrel)
+{
+	int posted;
+
+	/* Update internal mouse state */
+	joystick->balls[ball].dx += xrel;
+	joystick->balls[ball].dy += yrel;
+
+	/* Post the event, if desired */
+	posted = 0;
+#if !SDL_EVENTS_DISABLED
+	if ( SDL_ProcessEvents[SDL_JOYBALLMOTION] == SDL_ENABLE ) {
+		SDL_Event event;
+		event.jball.type = SDL_JOYBALLMOTION;
+		event.jball.which = joystick->index;
+		event.jball.ball = ball;
+		event.jball.xrel = xrel;
+		event.jball.yrel = yrel;
+		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
+			posted = 1;
+			SDL_PushEvent(&event);
+		}
+	}
+#endif /* !SDL_EVENTS_DISABLED */
+	return(posted);
+}
+
+int SDL_PrivateJoystickButton(SDL_Joystick *joystick, Uint8 button, Uint8 state)
+{
+	int posted;
+#if !SDL_EVENTS_DISABLED
+	SDL_Event event;
+
+	switch ( state ) {
+		case SDL_PRESSED:
+			event.type = SDL_JOYBUTTONDOWN;
+			break;
+		case SDL_RELEASED:
+			event.type = SDL_JOYBUTTONUP;
+			break;
+		default:
+			/* Invalid state -- bail */
+			return(0);
+	}
+#endif /* !SDL_EVENTS_DISABLED */
+
+	/* Update internal joystick state */
+	joystick->buttons[button] = state;
+
+	/* Post the event, if desired */
+	posted = 0;
+#if !SDL_EVENTS_DISABLED
+	if ( SDL_ProcessEvents[event.type] == SDL_ENABLE ) {
+		event.jbutton.which = joystick->index;
+		event.jbutton.button = button;
+		event.jbutton.state = state;
+		if ( (SDL_EventOK == NULL) || (*SDL_EventOK)(&event) ) {
+			posted = 1;
+			SDL_PushEvent(&event);
+		}
+	}
+#endif /* !SDL_EVENTS_DISABLED */
+	return(posted);
+}
+
+void SDL_JoystickUpdate(void)
+{
+	int i;
+
+	for ( i=0; SDL_joysticks[i]; ++i ) {
+		SDL_SYS_JoystickUpdate(SDL_joysticks[i]);
+	}
+}
+
+int SDL_JoystickEventState(int state)
+{
+#if SDL_EVENTS_DISABLED
+	return SDL_IGNORE;
+#else
+	const Uint8 event_list[] = {
+		SDL_JOYAXISMOTION, SDL_JOYBALLMOTION, SDL_JOYHATMOTION,
+		SDL_JOYBUTTONDOWN, SDL_JOYBUTTONUP,
+	};
+	unsigned int i;
+
+	switch (state) {
+		case SDL_QUERY:
+			state = SDL_IGNORE;
+			for ( i=0; i<SDL_arraysize(event_list); ++i ) {
+				state = SDL_EventState(event_list[i],SDL_QUERY);
+				if ( state == SDL_ENABLE ) {
+					break;
+				}
+			}
+			break;
+		default:
+			for ( i=0; i<SDL_arraysize(event_list); ++i ) {
+				SDL_EventState(event_list[i], state);
+			}
+			break;
+	}
+	return(state);
+#endif /* SDL_EVENTS_DISABLED */
+}
diff -ruN SDL-1.2.13/src/joystick/SDL_joystick_c.h SDL-1.2.13_OOx64/src/joystick/SDL_joystick_c.h
--- SDL-1.2.13/src/joystick/SDL_joystick_c.h	2007-12-31 04:47:55 +0000
+++ SDL-1.2.13_OOx64/src/joystick/SDL_joystick_c.h	2017-12-19 14:11:09 +0000
@@ -36,3 +36,6 @@
                                  Uint8 hat, Uint8 value);
 extern int SDL_PrivateJoystickButton(SDL_Joystick *joystick,
                                      Uint8 button, Uint8 state);
+
+/* Internal sanity checking functions */
+extern int SDL_PrivateJoystickValid(SDL_Joystick ** joystick);
diff -ruN SDL-1.2.13/src/joystick/SDL_joystick_c.h.bak SDL-1.2.13_OOx64/src/joystick/SDL_joystick_c.h.bak
--- SDL-1.2.13/src/joystick/SDL_joystick_c.h.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/SDL_joystick_c.h.bak	2007-12-30 18:47:56 +0000
@@ -0,0 +1,38 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Useful functions and variables from SDL_joystick.c */
+#include "SDL_joystick.h"
+
+/* The number of available joysticks on the system */
+extern Uint8 SDL_numjoysticks;
+
+/* Internal event queueing functions */
+extern int SDL_PrivateJoystickAxis(SDL_Joystick *joystick,
+                                   Uint8 axis, Sint16 value);
+extern int SDL_PrivateJoystickBall(SDL_Joystick *joystick,
+                                   Uint8 ball, Sint16 xrel, Sint16 yrel);
+extern int SDL_PrivateJoystickHat(SDL_Joystick *joystick,
+                                 Uint8 hat, Uint8 value);
+extern int SDL_PrivateJoystickButton(SDL_Joystick *joystick,
+                                     Uint8 button, Uint8 state);
diff -ruN SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick.c SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick.c
--- SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick.c	2007-12-31 04:47:55 +0000
+++ SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick.c	2017-12-20 15:07:39 +0000
@@ -48,59 +48,14 @@
 #include <CoreFoundation/CoreFoundation.h>
 #include <Carbon/Carbon.h> /* for NewPtrClear, DisposePtr */
 
+/* For force feedback testing. */
+#include <ForceFeedback/ForceFeedback.h>
+#include <ForceFeedback/ForceFeedbackConstants.h>
+
 #include "SDL_joystick.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
-
-struct recElement
-{
-	IOHIDElementCookie cookie;				/* unique value which identifies element, will NOT change */
-	long min;								/* reported min value possible */
-	long max;								/* reported max value possible */
-#if 0
-	/* TODO: maybe should handle the following stuff somehow? */
-
-	long scaledMin;							/* reported scaled min value possible */
-	long scaledMax;							/* reported scaled max value possible */
-	long size;								/* size in bits of data return from element */
-	Boolean relative;						/* are reports relative to last report (deltas) */
-	Boolean wrapping;						/* does element wrap around (one value higher than max is min) */
-	Boolean nonLinear;						/* are the values reported non-linear relative to element movement */
-	Boolean preferredState;					/* does element have a preferred state (such as a button) */
-	Boolean nullState;						/* does element have null state */
-#endif /* 0 */
-
-	/* runtime variables used for auto-calibration */
-	long minReport;							/* min returned value */
-	long maxReport;							/* max returned value */
-	
-	struct recElement * pNext;				/* next element in list */
-};
-typedef struct recElement recElement;
-
-struct joystick_hwdata
-{
-	IOHIDDeviceInterface ** interface;		/* interface to device, NULL = no interface */
-
-	char product[256];							/* name of product */
-	long usage;								/* usage page from IOUSBHID Parser.h which defines general usage */
-	long usagePage;							/* usage within above page from IOUSBHID Parser.h which defines specific usage */
-
-	long axes;								/* number of axis (calculated, not reported by device) */
-	long buttons;							/* number of buttons (calculated, not reported by device) */
-	long hats;								/* number of hat switches (calculated, not reported by device) */
-	long elements;							/* number of total elements (shouldbe total of above) (calculated, not reported by device) */
-
-	recElement* firstAxis;
-	recElement* firstButton;
-	recElement* firstHat;
-
-	int removed;
-	int uncentered;
-
-	struct joystick_hwdata* pNext;			/* next device */
-};
-typedef struct joystick_hwdata recDevice;
+#include "SDL_sysjoystick_c.h"
 
 
 /* Linked list of all available devices */
@@ -550,7 +505,13 @@
 	{
 		/* save next device prior to disposing of this device */
 		pDeviceNext = (*ppDevice)->pNext;
-		
+
+		/* free posible io_service_t */
+		if ((*ppDevice)->ffservice) {
+			IOObjectRelease((*ppDevice)->ffservice);
+			(*ppDevice)->ffservice = 0;
+		}
+
 		/* free element lists */
 		HIDDisposeElementList (&(*ppDevice)->firstAxis);
 		HIDDisposeElementList (&(*ppDevice)->firstButton);
@@ -645,12 +606,6 @@
 		if (!device)
 			continue;
 
-		/* dump device object, it is no longer needed */
-		result = IOObjectRelease (ioHIDDeviceObject);
-/*		if (KERN_SUCCESS != result)
-			HIDReportErrorNum ("IOObjectRelease error with ioHIDDeviceObject.", result);
-*/
-
 		/* Filter device list to non-keyboard/mouse stuff */ 
 		if ( (device->usagePage != kHIDPage_GenericDesktop) ||
 		     ((device->usage != kHIDUsage_GD_Joystick &&
@@ -662,7 +617,16 @@
 			DisposePtr((Ptr)device);
 			continue;
 		}
-		
+
+		/* We have to do some storage of the io_service_t for
+		 * SDL_HapticOpenFromJoystick */
+		if (FFIsForceFeedback(ioHIDDeviceObject) == FF_OK) {
+			device->ffservice = ioHIDDeviceObject;
+		}
+		else {
+			device->ffservice = 0;
+		}
+
 		/* Add device to the end of the list */
 		if (lastDevice)
 			lastDevice->pNext = device;
diff -ruN SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick.c.bak SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick.c.bak
--- SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick.c.bak	2007-12-30 18:47:56 +0000
@@ -0,0 +1,846 @@
+/*
+	SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	You should have received a copy of the GNU Library General Public
+	License along with this library; if not, write to the Free
+	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+	Sam Lantinga
+	slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_IOKIT
+
+/* SDL joystick driver for Darwin / Mac OS X, based on the IOKit HID API */
+/* Written 2001 by Max Horn */
+
+#include <unistd.h>
+#include <ctype.h>
+#include <sysexits.h>
+#include <mach/mach.h>
+#include <mach/mach_error.h>
+#include <IOKit/IOKitLib.h>
+#include <IOKit/IOCFPlugIn.h>
+#ifdef MACOS_10_0_4
+#include <IOKit/hidsystem/IOHIDUsageTables.h>
+#else
+/* The header was moved here in Mac OS X 10.1 */
+#include <Kernel/IOKit/hidsystem/IOHIDUsageTables.h>
+#endif
+#if MAC_OS_X_VERSION_MIN_REQUIRED == 1030
+#include "10.3.9-FIX/IOHIDLib.h"
+#else
+#include <IOKit/hid/IOHIDLib.h>
+#endif
+#include <IOKit/hid/IOHIDKeys.h>
+#include <CoreFoundation/CoreFoundation.h>
+#include <Carbon/Carbon.h> /* for NewPtrClear, DisposePtr */
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+struct recElement
+{
+	IOHIDElementCookie cookie;				/* unique value which identifies element, will NOT change */
+	long min;								/* reported min value possible */
+	long max;								/* reported max value possible */
+#if 0
+	/* TODO: maybe should handle the following stuff somehow? */
+
+	long scaledMin;							/* reported scaled min value possible */
+	long scaledMax;							/* reported scaled max value possible */
+	long size;								/* size in bits of data return from element */
+	Boolean relative;						/* are reports relative to last report (deltas) */
+	Boolean wrapping;						/* does element wrap around (one value higher than max is min) */
+	Boolean nonLinear;						/* are the values reported non-linear relative to element movement */
+	Boolean preferredState;					/* does element have a preferred state (such as a button) */
+	Boolean nullState;						/* does element have null state */
+#endif /* 0 */
+
+	/* runtime variables used for auto-calibration */
+	long minReport;							/* min returned value */
+	long maxReport;							/* max returned value */
+	
+	struct recElement * pNext;				/* next element in list */
+};
+typedef struct recElement recElement;
+
+struct joystick_hwdata
+{
+	IOHIDDeviceInterface ** interface;		/* interface to device, NULL = no interface */
+
+	char product[256];							/* name of product */
+	long usage;								/* usage page from IOUSBHID Parser.h which defines general usage */
+	long usagePage;							/* usage within above page from IOUSBHID Parser.h which defines specific usage */
+
+	long axes;								/* number of axis (calculated, not reported by device) */
+	long buttons;							/* number of buttons (calculated, not reported by device) */
+	long hats;								/* number of hat switches (calculated, not reported by device) */
+	long elements;							/* number of total elements (shouldbe total of above) (calculated, not reported by device) */
+
+	recElement* firstAxis;
+	recElement* firstButton;
+	recElement* firstHat;
+
+	int removed;
+	int uncentered;
+
+	struct joystick_hwdata* pNext;			/* next device */
+};
+typedef struct joystick_hwdata recDevice;
+
+
+/* Linked list of all available devices */
+static recDevice *gpDeviceList = NULL;
+
+
+static void HIDReportErrorNum (char * strError, long numError)
+{
+	SDL_SetError(strError);
+}
+
+static void HIDGetCollectionElements (CFMutableDictionaryRef deviceProperties, recDevice *pDevice);
+
+/* returns current value for element, polling element
+ * will return 0 on error conditions which should be accounted for by application
+ */
+
+static SInt32 HIDGetElementValue (recDevice *pDevice, recElement *pElement)
+{
+	IOReturn result = kIOReturnSuccess;
+	IOHIDEventStruct hidEvent;
+	hidEvent.value = 0;
+	
+	if (NULL != pDevice && NULL != pElement && NULL != pDevice->interface)
+	{
+		result = (*(pDevice->interface))->getElementValue(pDevice->interface, pElement->cookie, &hidEvent);
+		if (kIOReturnSuccess == result)
+		{
+			/* record min and max for auto calibration */
+			if (hidEvent.value < pElement->minReport)
+				pElement->minReport = hidEvent.value;
+			if (hidEvent.value > pElement->maxReport)
+				pElement->maxReport = hidEvent.value;
+		}
+	}
+
+	/* auto user scale */
+	return hidEvent.value;
+}
+
+static SInt32 HIDScaledCalibratedValue (recDevice *pDevice, recElement *pElement, long min, long max)
+{
+	float deviceScale = max - min;
+	float readScale = pElement->maxReport - pElement->minReport;
+	SInt32 value = HIDGetElementValue(pDevice, pElement);
+	if (readScale == 0)
+		return value; /* no scaling at all */
+	else
+		return ((value - pElement->minReport) * deviceScale / readScale) + min;
+}
+
+
+static void HIDRemovalCallback(void * target,
+                               IOReturn result,
+                               void * refcon,
+                               void * sender)
+{
+	recDevice *device = (recDevice *) refcon;
+	device->removed = 1;
+	device->uncentered = 1;
+}
+
+
+
+/* Create and open an interface to device, required prior to extracting values or building queues.
+ * Note: appliction now owns the device and must close and release it prior to exiting
+ */
+
+static IOReturn HIDCreateOpenDeviceInterface (io_object_t hidDevice, recDevice *pDevice)
+{
+	IOReturn result = kIOReturnSuccess;
+	HRESULT plugInResult = S_OK;
+	SInt32 score = 0;
+	IOCFPlugInInterface ** ppPlugInInterface = NULL;
+	
+	if (NULL == pDevice->interface)
+	{
+		result = IOCreatePlugInInterfaceForService (hidDevice, kIOHIDDeviceUserClientTypeID,
+													kIOCFPlugInInterfaceID, &ppPlugInInterface, &score);
+		if (kIOReturnSuccess == result)
+		{
+			/* Call a method of the intermediate plug-in to create the device interface */
+			plugInResult = (*ppPlugInInterface)->QueryInterface (ppPlugInInterface,
+								CFUUIDGetUUIDBytes (kIOHIDDeviceInterfaceID), (void *) &(pDevice->interface));
+			if (S_OK != plugInResult)
+				HIDReportErrorNum ("Couldnt query HID class device interface from plugInInterface", plugInResult);
+			(*ppPlugInInterface)->Release (ppPlugInInterface);
+		}
+		else
+			HIDReportErrorNum ("Failed to create **plugInInterface via IOCreatePlugInInterfaceForService.", result);
+	}
+	if (NULL != pDevice->interface)
+	{
+		result = (*(pDevice->interface))->open (pDevice->interface, 0);
+		if (kIOReturnSuccess != result)
+			HIDReportErrorNum ("Failed to open pDevice->interface via open.", result);
+		else
+			(*(pDevice->interface))->setRemovalCallback (pDevice->interface, HIDRemovalCallback, pDevice, pDevice);
+
+	}
+	return result;
+}
+
+/* Closes and releases interface to device, should be done prior to exting application
+ * Note: will have no affect if device or interface do not exist
+ * application will "own" the device if interface is not closed
+ * (device may have to be plug and re-plugged in different location to get it working again without a restart)
+ */
+
+static IOReturn HIDCloseReleaseInterface (recDevice *pDevice)
+{
+	IOReturn result = kIOReturnSuccess;
+	
+	if ((NULL != pDevice) && (NULL != pDevice->interface))
+	{
+		/* close the interface */
+		result = (*(pDevice->interface))->close (pDevice->interface);
+		if (kIOReturnNotOpen == result)
+		{
+			/* do nothing as device was not opened, thus can't be closed */
+		}
+		else if (kIOReturnSuccess != result)
+			HIDReportErrorNum ("Failed to close IOHIDDeviceInterface.", result);
+		/* release the interface */
+		result = (*(pDevice->interface))->Release (pDevice->interface);
+		if (kIOReturnSuccess != result)
+			HIDReportErrorNum ("Failed to release IOHIDDeviceInterface.", result);
+		pDevice->interface = NULL;
+	}	
+	return result;
+}
+
+/* extracts actual specific element information from each element CF dictionary entry */
+
+static void HIDGetElementInfo (CFTypeRef refElement, recElement *pElement)
+{
+	long number;
+	CFTypeRef refType;
+
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementCookieKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->cookie = (IOHIDElementCookie) number;
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementMinKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->minReport = pElement->min = number;
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementMaxKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->maxReport = pElement->max = number;
+/*
+	TODO: maybe should handle the following stuff somehow?
+
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMinKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->scaledMin = number;
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementScaledMaxKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->scaledMax = number;
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementSizeKey));
+	if (refType && CFNumberGetValue (refType, kCFNumberLongType, &number))
+		pElement->size = number;
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsRelativeKey));
+	if (refType)
+		pElement->relative = CFBooleanGetValue (refType);
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsWrappingKey));
+	if (refType)
+		pElement->wrapping = CFBooleanGetValue (refType);
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementIsNonLinearKey));
+	if (refType)
+		pElement->nonLinear = CFBooleanGetValue (refType);
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasPreferedStateKey));
+	if (refType)
+		pElement->preferredState = CFBooleanGetValue (refType);
+	refType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementHasNullStateKey));
+	if (refType)
+		pElement->nullState = CFBooleanGetValue (refType);
+*/
+}			
+
+/* examines CF dictionary vlaue in device element hierarchy to determine if it is element of interest or a collection of more elements
+ * if element of interest allocate storage, add to list and retrieve element specific info
+ * if collection then pass on to deconstruction collection into additional individual elements
+ */
+
+static void HIDAddElement (CFTypeRef refElement, recDevice* pDevice)
+{
+	recElement* element = NULL;
+	recElement** headElement = NULL;
+	long elementType, usagePage, usage;
+	CFTypeRef refElementType = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementTypeKey));
+	CFTypeRef refUsagePage = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUsagePageKey));
+	CFTypeRef refUsage = CFDictionaryGetValue (refElement, CFSTR(kIOHIDElementUsageKey));
+
+
+	if ((refElementType) && (CFNumberGetValue (refElementType, kCFNumberLongType, &elementType)))
+	{
+		/* look at types of interest */
+		if ((elementType == kIOHIDElementTypeInput_Misc) || (elementType == kIOHIDElementTypeInput_Button) ||
+			(elementType == kIOHIDElementTypeInput_Axis))
+		{
+			if (refUsagePage && CFNumberGetValue (refUsagePage, kCFNumberLongType, &usagePage) &&
+				refUsage && CFNumberGetValue (refUsage, kCFNumberLongType, &usage))
+			{
+				switch (usagePage) /* only interested in kHIDPage_GenericDesktop and kHIDPage_Button */
+				{
+					case kHIDPage_GenericDesktop:
+						{
+							switch (usage) /* look at usage to determine function */
+							{
+								case kHIDUsage_GD_X:
+								case kHIDUsage_GD_Y:
+								case kHIDUsage_GD_Z:
+								case kHIDUsage_GD_Rx:
+								case kHIDUsage_GD_Ry:
+								case kHIDUsage_GD_Rz:
+								case kHIDUsage_GD_Slider:
+								case kHIDUsage_GD_Dial:
+								case kHIDUsage_GD_Wheel:
+									element = (recElement *) NewPtrClear (sizeof (recElement));
+									if (element)
+									{
+										pDevice->axes++;
+										headElement = &(pDevice->firstAxis);
+									}
+								break;
+								case kHIDUsage_GD_Hatswitch:
+									element = (recElement *) NewPtrClear (sizeof (recElement));
+									if (element)
+									{
+										pDevice->hats++;
+										headElement = &(pDevice->firstHat);
+									}
+								break;
+							}							
+						}
+						break;
+					case kHIDPage_Button:
+						element = (recElement *) NewPtrClear (sizeof (recElement));
+						if (element)
+						{
+							pDevice->buttons++;
+							headElement = &(pDevice->firstButton);
+						}
+						break;
+					default:
+						break;
+				}
+			}
+		}
+		else if (kIOHIDElementTypeCollection == elementType)
+			HIDGetCollectionElements ((CFMutableDictionaryRef) refElement, pDevice);
+	}
+
+	if (element && headElement) /* add to list */
+	{
+		pDevice->elements++;
+		if (NULL == *headElement)
+			*headElement = element;
+		else
+		{
+			recElement *elementPrevious, *elementCurrent;
+			elementCurrent = *headElement;
+			while (elementCurrent)
+			{
+				elementPrevious = elementCurrent;
+				elementCurrent = elementPrevious->pNext;
+			}
+			elementPrevious->pNext = element;
+		}
+		element->pNext = NULL;
+		HIDGetElementInfo (refElement, element);
+	}
+}
+
+/* collects information from each array member in device element list (each array memeber = element) */
+
+static void HIDGetElementsCFArrayHandler (const void * value, void * parameter)
+{
+	if (CFGetTypeID (value) == CFDictionaryGetTypeID ())
+		HIDAddElement ((CFTypeRef) value, (recDevice *) parameter);
+}
+
+/* handles retrieval of element information from arrays of elements in device IO registry information */
+
+static void HIDGetElements (CFTypeRef refElementCurrent, recDevice *pDevice)
+{
+	CFTypeID type = CFGetTypeID (refElementCurrent);
+	if (type == CFArrayGetTypeID()) /* if element is an array */
+	{
+		CFRange range = {0, CFArrayGetCount (refElementCurrent)};
+		/* CountElementsCFArrayHandler called for each array member */
+		CFArrayApplyFunction (refElementCurrent, range, HIDGetElementsCFArrayHandler, pDevice);
+	}
+}			
+
+/* handles extracting element information from element collection CF types
+ * used from top level element decoding and hierarchy deconstruction to flatten device element list
+ */
+
+static void HIDGetCollectionElements (CFMutableDictionaryRef deviceProperties, recDevice *pDevice)
+{
+	CFTypeRef refElementTop = CFDictionaryGetValue (deviceProperties, CFSTR(kIOHIDElementKey));
+	if (refElementTop)
+		HIDGetElements (refElementTop, pDevice);
+}
+
+/* use top level element usage page and usage to discern device usage page and usage setting appropriate vlaues in device record */
+
+static void HIDTopLevelElementHandler (const void * value, void * parameter)
+{
+	CFTypeRef refCF = 0;
+	if (CFGetTypeID (value) != CFDictionaryGetTypeID ())
+		return;
+	refCF = CFDictionaryGetValue (value, CFSTR(kIOHIDElementUsagePageKey));
+	if (!CFNumberGetValue (refCF, kCFNumberLongType, &((recDevice *) parameter)->usagePage))
+		SDL_SetError ("CFNumberGetValue error retrieving pDevice->usagePage.");
+	refCF = CFDictionaryGetValue (value, CFSTR(kIOHIDElementUsageKey));
+	if (!CFNumberGetValue (refCF, kCFNumberLongType, &((recDevice *) parameter)->usage))
+		SDL_SetError ("CFNumberGetValue error retrieving pDevice->usage.");
+}
+
+/* extracts device info from CF dictionary records in IO registry */
+
+static void HIDGetDeviceInfo (io_object_t hidDevice, CFMutableDictionaryRef hidProperties, recDevice *pDevice)
+{
+	CFMutableDictionaryRef usbProperties = 0;
+	io_registry_entry_t parent1, parent2;
+	
+	/* Mac OS X currently is not mirroring all USB properties to HID page so need to look at USB device page also
+	 * get dictionary for usb properties: step up two levels and get CF dictionary for USB properties
+	 */
+	if ((KERN_SUCCESS == IORegistryEntryGetParentEntry (hidDevice, kIOServicePlane, &parent1)) &&
+		(KERN_SUCCESS == IORegistryEntryGetParentEntry (parent1, kIOServicePlane, &parent2)) &&
+		(KERN_SUCCESS == IORegistryEntryCreateCFProperties (parent2, &usbProperties, kCFAllocatorDefault, kNilOptions)))
+	{
+		if (usbProperties)
+		{
+			CFTypeRef refCF = 0;
+			/* get device info
+			 * try hid dictionary first, if fail then go to usb dictionary
+			 */
+			
+			
+			/* get product name */
+			refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDProductKey));
+			if (!refCF)
+				refCF = CFDictionaryGetValue (usbProperties, CFSTR("USB Product Name"));
+			if (refCF)
+			{
+				if (!CFStringGetCString (refCF, pDevice->product, 256, CFStringGetSystemEncoding ()))
+					SDL_SetError ("CFStringGetCString error retrieving pDevice->product.");
+			}
+			
+			/* get usage page and usage */
+			refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDPrimaryUsagePageKey));
+			if (refCF)
+			{
+				if (!CFNumberGetValue (refCF, kCFNumberLongType, &pDevice->usagePage))
+					SDL_SetError ("CFNumberGetValue error retrieving pDevice->usagePage.");
+				refCF = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDPrimaryUsageKey));
+				if (refCF)
+					if (!CFNumberGetValue (refCF, kCFNumberLongType, &pDevice->usage))
+						SDL_SetError ("CFNumberGetValue error retrieving pDevice->usage.");
+			}
+
+			if (NULL == refCF) /* get top level element HID usage page or usage */
+			{
+				/* use top level element instead */
+				CFTypeRef refCFTopElement = 0;
+				refCFTopElement = CFDictionaryGetValue (hidProperties, CFSTR(kIOHIDElementKey));
+				{
+					/* refCFTopElement points to an array of element dictionaries */
+					CFRange range = {0, CFArrayGetCount (refCFTopElement)};
+					CFArrayApplyFunction (refCFTopElement, range, HIDTopLevelElementHandler, pDevice);
+				}
+			}
+
+			CFRelease (usbProperties);
+		}
+		else
+			SDL_SetError ("IORegistryEntryCreateCFProperties failed to create usbProperties.");
+
+		if (kIOReturnSuccess != IOObjectRelease (parent2))
+			SDL_SetError ("IOObjectRelease error with parent2.");
+		if (kIOReturnSuccess != IOObjectRelease (parent1))
+			SDL_SetError ("IOObjectRelease error with parent1.");
+	}
+}
+
+
+static recDevice *HIDBuildDevice (io_object_t hidDevice)
+{
+	recDevice *pDevice = (recDevice *) NewPtrClear (sizeof (recDevice));
+	if (pDevice)
+	{
+		/* get dictionary for HID properties */
+		CFMutableDictionaryRef hidProperties = 0;
+		kern_return_t result = IORegistryEntryCreateCFProperties (hidDevice, &hidProperties, kCFAllocatorDefault, kNilOptions);
+		if ((result == KERN_SUCCESS) && hidProperties)
+		{
+			/* create device interface */
+			result = HIDCreateOpenDeviceInterface (hidDevice, pDevice);
+			if (kIOReturnSuccess == result)
+			{
+				HIDGetDeviceInfo (hidDevice, hidProperties, pDevice); /* hidDevice used to find parents in registry tree */
+				HIDGetCollectionElements (hidProperties, pDevice);
+			}
+			else
+			{
+				DisposePtr((Ptr)pDevice);
+				pDevice = NULL;
+			}
+			CFRelease (hidProperties);
+		}
+		else
+		{
+			DisposePtr((Ptr)pDevice);
+			pDevice = NULL;
+		}
+	}
+	return pDevice;
+}
+
+/* disposes of the element list associated with a device and the memory associated with the list
+ */
+
+static void HIDDisposeElementList (recElement **elementList)
+{
+	recElement *pElement = *elementList;
+	while (pElement)
+	{
+		recElement *pElementNext = pElement->pNext;
+		DisposePtr ((Ptr) pElement);
+		pElement = pElementNext;
+	}
+	*elementList = NULL;
+}
+
+/* disposes of a single device, closing and releaseing interface, freeing memory fro device and elements, setting device pointer to NULL
+ * all your device no longer belong to us... (i.e., you do not 'own' the device anymore)
+ */
+
+static recDevice *HIDDisposeDevice (recDevice **ppDevice)
+{
+	kern_return_t result = KERN_SUCCESS;
+	recDevice *pDeviceNext = NULL;
+	if (*ppDevice)
+	{
+		/* save next device prior to disposing of this device */
+		pDeviceNext = (*ppDevice)->pNext;
+		
+		/* free element lists */
+		HIDDisposeElementList (&(*ppDevice)->firstAxis);
+		HIDDisposeElementList (&(*ppDevice)->firstButton);
+		HIDDisposeElementList (&(*ppDevice)->firstHat);
+		
+		result = HIDCloseReleaseInterface (*ppDevice); /* function sanity checks interface value (now application does not own device) */
+		if (kIOReturnSuccess != result)
+			HIDReportErrorNum ("HIDCloseReleaseInterface failed when trying to dipose device.", result);
+		DisposePtr ((Ptr)*ppDevice);
+		*ppDevice = NULL;
+	}
+	return pDeviceNext;
+}
+
+
+/* Function to scan the system for joysticks.
+ * Joystick 0 should be the system default joystick.
+ * This function should return the number of available joysticks, or -1
+ * on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	IOReturn result = kIOReturnSuccess;
+	mach_port_t masterPort = 0;
+	io_iterator_t hidObjectIterator = 0;
+	CFMutableDictionaryRef hidMatchDictionary = NULL;
+	recDevice *device, *lastDevice;
+	io_object_t ioHIDDeviceObject = 0;
+	
+	SDL_numjoysticks = 0;
+	
+	if (gpDeviceList)
+	{
+		SDL_SetError("Joystick: Device list already inited.");
+		return -1;
+	}
+	
+	result = IOMasterPort (bootstrap_port, &masterPort);
+	if (kIOReturnSuccess != result)
+	{
+		SDL_SetError("Joystick: IOMasterPort error with bootstrap_port.");
+		return -1;
+	}
+
+	/* Set up a matching dictionary to search I/O Registry by class name for all HID class devices. */
+	hidMatchDictionary = IOServiceMatching (kIOHIDDeviceKey);
+	if (hidMatchDictionary)
+	{
+		/* Add key for device type (joystick, in this case) to refine the matching dictionary. */
+		
+		/* NOTE: we now perform this filtering later
+		UInt32 usagePage = kHIDPage_GenericDesktop;
+		UInt32 usage = kHIDUsage_GD_Joystick;
+		CFNumberRef refUsage = NULL, refUsagePage = NULL;
+
+		refUsage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &usage);
+		CFDictionarySetValue (hidMatchDictionary, CFSTR (kIOHIDPrimaryUsageKey), refUsage);
+		refUsagePage = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &usagePage);
+		CFDictionarySetValue (hidMatchDictionary, CFSTR (kIOHIDPrimaryUsagePageKey), refUsagePage);
+		*/
+	}
+	else
+	{
+		SDL_SetError("Joystick: Failed to get HID CFMutableDictionaryRef via IOServiceMatching.");
+		return -1;
+	}
+	
+	/*/ Now search I/O Registry for matching devices. */
+	result = IOServiceGetMatchingServices (masterPort, hidMatchDictionary, &hidObjectIterator);
+	/* Check for errors */
+	if (kIOReturnSuccess != result)
+	{
+		SDL_SetError("Joystick: Couldn't create a HID object iterator.");
+		return -1;
+	}
+	if (!hidObjectIterator) /* there are no joysticks */
+	{
+		gpDeviceList = NULL;
+		SDL_numjoysticks = 0;
+		return 0;
+	}
+	/* IOServiceGetMatchingServices consumes a reference to the dictionary, so we don't need to release the dictionary ref. */
+
+	/* build flat linked list of devices from device iterator */
+
+	gpDeviceList = lastDevice = NULL;
+	
+	while ((ioHIDDeviceObject = IOIteratorNext (hidObjectIterator)))
+	{
+		/* build a device record */
+		device = HIDBuildDevice (ioHIDDeviceObject);
+		if (!device)
+			continue;
+
+		/* dump device object, it is no longer needed */
+		result = IOObjectRelease (ioHIDDeviceObject);
+/*		if (KERN_SUCCESS != result)
+			HIDReportErrorNum ("IOObjectRelease error with ioHIDDeviceObject.", result);
+*/
+
+		/* Filter device list to non-keyboard/mouse stuff */ 
+		if ( (device->usagePage != kHIDPage_GenericDesktop) ||
+		     ((device->usage != kHIDUsage_GD_Joystick &&
+		      device->usage != kHIDUsage_GD_GamePad &&
+		      device->usage != kHIDUsage_GD_MultiAxisController)) ) {
+
+			/* release memory for the device */
+			HIDDisposeDevice (&device);
+			DisposePtr((Ptr)device);
+			continue;
+		}
+		
+		/* Add device to the end of the list */
+		if (lastDevice)
+			lastDevice->pNext = device;
+		else
+			gpDeviceList = device;
+		lastDevice = device;
+	}
+	result = IOObjectRelease (hidObjectIterator); /* release the iterator */
+
+	/* Count the total number of devices we found */
+	device = gpDeviceList;
+	while (device)
+	{
+		SDL_numjoysticks++;
+		device = device->pNext;
+	}
+	
+	return SDL_numjoysticks;
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	recDevice *device = gpDeviceList;
+	
+	for (; index > 0; index--)
+		device = device->pNext;
+
+	return device->product;
+}
+
+/* Function to open a joystick for use.
+ * The joystick to open is specified by the index field of the joystick.
+ * This should fill the nbuttons and naxes fields of the joystick structure.
+ * It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	recDevice *device = gpDeviceList;
+	int index;
+	
+	for (index = joystick->index; index > 0; index--)
+		device = device->pNext;
+
+	joystick->hwdata = device;
+	joystick->name = device->product;
+
+	joystick->naxes = device->axes;
+	joystick->nhats = device->hats;
+	joystick->nballs = 0;
+	joystick->nbuttons = device->buttons;
+
+	return 0;
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	recDevice *device = joystick->hwdata;
+	recElement *element;
+	SInt32 value, range;
+	int i;
+
+	if (device->removed)  /* device was unplugged; ignore it. */
+	{
+		if (device->uncentered)
+		{
+			device->uncentered = 0;
+
+			/* Tell the app that everything is centered/unpressed... */
+			for (i = 0; i < device->axes; i++)
+				SDL_PrivateJoystickAxis(joystick, i, 0);
+
+			for (i = 0; i < device->buttons; i++)
+				SDL_PrivateJoystickButton(joystick, i, 0);
+
+			for (i = 0; i < device->hats; i++)
+				SDL_PrivateJoystickHat(joystick, i, SDL_HAT_CENTERED);
+		}
+
+		return;
+	}
+
+	element = device->firstAxis;
+	i = 0;
+	while (element)
+	{
+		value = HIDScaledCalibratedValue(device, element, -32768, 32767);
+		if ( value != joystick->axes[i] )
+			SDL_PrivateJoystickAxis(joystick, i, value);
+		element = element->pNext;
+		++i;
+	}
+	
+	element = device->firstButton;
+	i = 0;
+	while (element)
+	{
+		value = HIDGetElementValue(device, element);
+        if (value > 1)  /* handle pressure-sensitive buttons */
+            value = 1;
+		if ( value != joystick->buttons[i] )
+			SDL_PrivateJoystickButton(joystick, i, value);
+		element = element->pNext;
+		++i;
+	}
+	    
+	element = device->firstHat;
+	i = 0;
+	while (element)
+	{
+		Uint8 pos = 0;
+
+		range = (element->max - element->min + 1);
+		value = HIDGetElementValue(device, element) - element->min;
+		if (range == 4) /* 4 position hatswitch - scale up value */
+			value *= 2;
+		else if (range != 8) /* Neither a 4 nor 8 positions - fall back to default position (centered) */
+			value = -1;
+		switch(value)
+		{
+			case 0:
+				pos = SDL_HAT_UP;
+				break;
+			case 1:
+				pos = SDL_HAT_RIGHTUP;
+				break;
+			case 2:
+				pos = SDL_HAT_RIGHT;
+				break;
+			case 3:
+				pos = SDL_HAT_RIGHTDOWN;
+				break;
+			case 4:
+				pos = SDL_HAT_DOWN;
+				break;
+			case 5:
+				pos = SDL_HAT_LEFTDOWN;
+				break;
+			case 6:
+				pos = SDL_HAT_LEFT;
+				break;
+			case 7:
+				pos = SDL_HAT_LEFTUP;
+				break;
+			default:
+				/* Every other value is mapped to center. We do that because some
+				 * joysticks use 8 and some 15 for this value, and apparently
+				 * there are even more variants out there - so we try to be generous.
+				 */
+				pos = SDL_HAT_CENTERED;
+				break;
+		}
+		if ( pos != joystick->hats[i] )
+			SDL_PrivateJoystickHat(joystick, i, pos);
+		element = element->pNext;
+		++i;
+	}
+	
+	return;
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	/* Should we do anything here? */
+	return;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+	while (NULL != gpDeviceList)
+		gpDeviceList = HIDDisposeDevice (&gpDeviceList);
+}
+
+#endif /* SDL_JOYSTICK_IOKIT */
diff -ruN SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick_c.h SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick_c.h
--- SDL-1.2.13/src/joystick/darwin/SDL_sysjoystick_c.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/darwin/SDL_sysjoystick_c.h	2017-12-18 15:12:14 +0000
@@ -0,0 +1,87 @@
+/*
+	SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Library General Public
+	License as published by the Free Software Foundation; either
+	version 2 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Library General Public License for more details.
+
+	You should have received a copy of the GNU Library General Public
+	License along with this library; if not, write to the Free
+	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+	Sam Lantinga
+	slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef SDL_JOYSTICK_IOKIT_H
+
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED == 1030
+#include "10.3.9-FIX/IOHIDLib.h"
+#else
+#include <IOKit/hid/IOHIDLib.h>
+#endif
+#include <IOKit/hid/IOHIDKeys.h>
+
+
+struct recElement
+{
+    IOHIDElementCookie cookie;  /* unique value which identifies element, will NOT change */
+    long min;                   /* reported min value possible */
+    long max;                   /* reported max value possible */
+#if 0
+    /* TODO: maybe should handle the following stuff somehow? */
+
+    long scaledMin;             /* reported scaled min value possible */
+    long scaledMax;             /* reported scaled max value possible */
+    long size;                  /* size in bits of data return from element */
+    Boolean relative;           /* are reports relative to last report (deltas) */
+    Boolean wrapping;           /* does element wrap around (one value higher than max is min) */
+    Boolean nonLinear;          /* are the values reported non-linear relative to element movement */
+    Boolean preferredState;     /* does element have a preferred state (such as a button) */
+    Boolean nullState;          /* does element have null state */
+#endif                          /* 0 */
+
+    /* runtime variables used for auto-calibration */
+    long minReport;             /* min returned value */
+    long maxReport;             /* max returned value */
+
+    struct recElement *pNext;   /* next element in list */
+};
+typedef struct recElement recElement;
+
+struct joystick_hwdata
+{
+    io_service_t ffservice;             /* Interface for force feedback, 0 = no ff */
+    IOHIDDeviceInterface **interface;   /* interface to device, NULL = no interface */
+
+    char product[256];          /* name of product */
+    long usage;                 /* usage page from IOUSBHID Parser.h which defines general usage */
+    long usagePage;             /* usage within above page from IOUSBHID Parser.h which defines specific usage */
+
+    long axes;                  /* number of axis (calculated, not reported by device) */
+    long buttons;               /* number of buttons (calculated, not reported by device) */
+    long hats;                  /* number of hat switches (calculated, not reported by device) */
+    long elements;              /* number of total elements (shouldbe total of above) (calculated, not reported by device) */
+
+    recElement *firstAxis;
+    recElement *firstButton;
+    recElement *firstHat;
+
+    int removed;
+    int uncentered;
+
+    struct joystick_hwdata *pNext;      /* next device */
+};
+typedef struct joystick_hwdata recDevice;
+
+
+#endif /* SDL_JOYSTICK_IOKIT_H */
diff -ruN SDL-1.2.13/src/joystick/linux/SDL_sysjoystick.c SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick.c
--- SDL-1.2.13/src/joystick/linux/SDL_sysjoystick.c	2007-12-31 04:47:54 +0000
+++ SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick.c	2017-12-20 15:08:59 +0000
@@ -31,13 +31,11 @@
 #include <sys/ioctl.h>
 #include <limits.h>		/* For the definition of PATH_MAX */
 #include <linux/joystick.h>
-#if SDL_INPUT_LINUXEV
-#include <linux/input.h>
-#endif
 
 #include "SDL_joystick.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
+#include "SDL_sysjoystick_c.h"
 
 /* Special joystick configurations */
 static struct {
@@ -268,31 +266,6 @@
 } SDL_joylist[MAX_JOYSTICKS];
 
 
-/* The private structure used to keep track of a joystick */
-struct joystick_hwdata {
-	int fd;
-	/* The current linux joystick driver maps hats to two axes */
-	struct hwdata_hat {
-		int axis[2];
-	} *hats;
-	/* The current linux joystick driver maps balls to two axes */
-	struct hwdata_ball {
-		int axis[2];
-	} *balls;
-
-	/* Support for the Linux 2.4 unified input interface */
-#if SDL_INPUT_LINUXEV
-	SDL_bool is_hid;
-	Uint8 key_map[KEY_MAX-BTN_MISC];
-	Uint8 abs_map[ABS_MAX];
-	struct axis_correct {
-		int used;
-		int coef[3];
-	} abs_correct[ABS_MAX];
-#endif
-};
-
-
 #ifndef NO_LOGICAL_JOYSTICKS
 
 static int CountLogicalJoysticks(int max)
@@ -778,6 +751,7 @@
 int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
 {
 	int fd;
+	char *fname;
 	SDL_logical_joydecl(int realindex);
 	SDL_logical_joydecl(SDL_Joystick *realjoy = NULL);
 
@@ -791,13 +765,16 @@
 			return(-1);
                                                                                 
 		fd = realjoy->hwdata->fd;
+		fname = realjoy->hwdata->fname;
 
 	} else {
 		fd = open(SDL_joylist[joystick->index].fname, O_RDONLY, 0);
+		fname = SDL_joylist[joystick->index].fname;
 	}
 	SDL_joylist[joystick->index].joy = joystick;
 #else
 	fd = open(SDL_joylist[joystick->index].fname, O_RDONLY, 0);
+	fname = SDL_joylist[joystick->index].fname;
 #endif
 
 	if ( fd < 0 ) {
@@ -814,6 +791,7 @@
 	}
 	SDL_memset(joystick->hwdata, 0, sizeof(*joystick->hwdata));
 	joystick->hwdata->fd = fd;
+	joystick->hwdata->fname = fname;
 
 	/* Set the joystick to non-blocking read mode */
 	fcntl(fd, F_SETFL, O_NONBLOCK);
diff -ruN SDL-1.2.13/src/joystick/linux/SDL_sysjoystick.c.bak SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick.c.bak
--- SDL-1.2.13/src/joystick/linux/SDL_sysjoystick.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick.c.bak	2007-12-30 18:47:54 +0000
@@ -0,0 +1,1198 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_LINUX
+
+/* This is the system specific header for the SDL joystick API */
+
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <limits.h>		/* For the definition of PATH_MAX */
+#include <linux/joystick.h>
+#if SDL_INPUT_LINUXEV
+#include <linux/input.h>
+#endif
+
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+/* Special joystick configurations */
+static struct {
+	const char *name;
+	int naxes;
+	int nhats;
+	int nballs;
+} special_joysticks[] = {
+	{ "MadCatz Panther XL", 3, 2, 1 }, /* We don't handle rudder (axis 8) */
+	{ "SideWinder Precision Pro", 4, 1, 0 },
+	{ "SideWinder 3D Pro", 4, 1, 0 },
+	{ "Microsoft SideWinder 3D Pro", 4, 1, 0 },
+	{ "Microsoft SideWinder Precision Pro", 4, 1, 0 },
+	{ "Microsoft SideWinder Dual Strike USB version 1.0", 2, 1, 0 },
+	{ "WingMan Interceptor", 3, 3, 0 },
+	{ "WingMan Extreme Digital 3D", 4, 1, 0 },
+	{ "Microsoft SideWinder Precision 2 Joystick", 4, 1, 0 },
+	{ "Logitech Inc. WingMan Extreme Digital 3D", 4, 1, 0 },
+	{ "Saitek Saitek X45", 6, 1, 0 }
+};
+
+#ifndef NO_LOGICAL_JOYSTICKS
+
+/*
+   Some USB HIDs show up as a single joystick even though they actually
+   control 2 or more joysticks.
+*/
+/*
+   This code handles the MP-8800 (Quad) and MP-8866 (Dual), which can
+   be identified by their transparent blue design. It's quite trivial
+   to add other joysticks with similar quirky behavior.
+   -id
+*/
+
+struct joystick_logical_mapping {
+        int njoy;
+        int nthing;
+};
+
+/*
+   {logical joy, logical axis},
+   {logical joy, logical hat},
+   {logical joy, logical ball},
+   {logical joy, logical button}
+*/
+
+static struct joystick_logical_mapping mp88xx_1_logical_axismap[] = {
+   {0,0},{0,1},{0,2},{0,3},{0,4},{0,5}
+};
+static struct joystick_logical_mapping mp88xx_1_logical_buttonmap[] = {
+   {0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},{0,9},{0,10},{0,11}
+};
+
+static struct joystick_logical_mapping mp88xx_2_logical_axismap[] = {
+   {0,0},{0,1},{0,2},{1,0},{1,1},{0,3},
+   {1,2},{1,3},{0,4},{0,5},{1,4},{1,5}
+};
+static struct joystick_logical_mapping mp88xx_2_logical_buttonmap[] = {
+   {0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},{0,9},{0,10},{0,11},
+   {1,0},{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{1,10},{1,11}
+};
+
+static struct joystick_logical_mapping mp88xx_3_logical_axismap[] = {
+   {0,0},{0,1},{0,2},{1,0},{1,1},{0,3},
+   {1,2},{1,3},{2,0},{2,1},{2,2},{2,3},
+   {0,4},{0,5},{1,4},{1,5},{2,4},{2,5}
+};
+static struct joystick_logical_mapping mp88xx_3_logical_buttonmap[] = {
+   {0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},{0,9},{0,10},{0,11},
+   {1,0},{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{1,10},{1,11},
+   {2,0},{2,1},{2,2},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{2,9},{2,10},{2,11}
+};
+
+static struct joystick_logical_mapping mp88xx_4_logical_axismap[] = {
+   {0,0},{0,1},{0,2},{1,0},{1,1},{0,3},
+   {1,2},{1,3},{2,0},{2,1},{2,2},{2,3},
+   {3,0},{3,1},{3,2},{3,3},{0,4},{0,5},
+   {1,4},{1,5},{2,4},{2,5},{3,4},{3,5}
+};
+static struct joystick_logical_mapping mp88xx_4_logical_buttonmap[] = {
+   {0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},{0,9},{0,10},{0,11},
+   {1,0},{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{1,10},{1,11},
+   {2,0},{2,1},{2,2},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{2,9},{2,10},{2,11},
+   {3,0},{3,1},{3,2},{3,3},{3,4},{3,5},{3,6},{3,7},{3,8},{3,9},{3,10},{3,11}
+};
+
+struct joystick_logical_layout {
+        int naxes;
+        int nhats;
+        int nballs;
+        int nbuttons;
+};
+
+static struct joystick_logical_layout mp88xx_1_logical_layout[] = {
+        {6, 0, 0, 12}
+};
+static struct joystick_logical_layout mp88xx_2_logical_layout[] = {
+        {6, 0, 0, 12},
+        {6, 0, 0, 12}
+};
+static struct joystick_logical_layout mp88xx_3_logical_layout[] = {
+        {6, 0, 0, 12},
+        {6, 0, 0, 12},
+        {6, 0, 0, 12}
+};
+static struct joystick_logical_layout mp88xx_4_logical_layout[] = {
+        {6, 0, 0, 12},
+        {6, 0, 0, 12},
+        {6, 0, 0, 12},
+        {6, 0, 0, 12}
+};
+
+/*
+   This array sets up a means of mapping a single physical joystick to
+   multiple logical joysticks. (djm)
+                                                                                
+   njoys
+        the number of logical joysticks
+                                                                                
+   layouts
+        an array of layout structures, one to describe each logical joystick
+                                                                                
+   axes, hats, balls, buttons
+        arrays that map a physical thingy to a logical thingy
+ */
+struct joystick_logicalmap {
+        const char *name;
+	int nbuttons;
+        int njoys;
+        struct joystick_logical_layout *layout;
+        struct joystick_logical_mapping *axismap;
+        struct joystick_logical_mapping *hatmap;
+        struct joystick_logical_mapping *ballmap;
+        struct joystick_logical_mapping *buttonmap;
+};
+
+static struct joystick_logicalmap joystick_logicalmap[] = {
+        {
+		"WiseGroup.,Ltd MP-8866 Dual USB Joypad",
+		12,
+		1,
+		mp88xx_1_logical_layout,
+        	mp88xx_1_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_1_logical_buttonmap
+	},
+        {
+		"WiseGroup.,Ltd MP-8866 Dual USB Joypad",
+		24,
+		2,
+		mp88xx_2_logical_layout,
+        	mp88xx_2_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_2_logical_buttonmap
+	},
+        {
+		"WiseGroup.,Ltd MP-8800 Quad USB Joypad",
+		12,
+		1,
+		mp88xx_1_logical_layout,
+        	mp88xx_1_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_1_logical_buttonmap
+	},
+        {
+		"WiseGroup.,Ltd MP-8800 Quad USB Joypad",
+		24,
+		2,
+		mp88xx_2_logical_layout,
+        	mp88xx_2_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_2_logical_buttonmap
+	},
+        {
+		"WiseGroup.,Ltd MP-8800 Quad USB Joypad",
+		36,
+		3,
+		mp88xx_3_logical_layout,
+        	mp88xx_3_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_3_logical_buttonmap
+	},
+        {
+		"WiseGroup.,Ltd MP-8800 Quad USB Joypad",
+		48,
+		4,
+		mp88xx_4_logical_layout,
+        	mp88xx_4_logical_axismap,
+		NULL,
+		NULL,
+        	mp88xx_4_logical_buttonmap
+	}
+};
+
+/* find the head of a linked list, given a point in it
+ */
+#define SDL_joylist_head(i, start)\
+        for(i = start; SDL_joylist[i].fname == NULL;) i = SDL_joylist[i].prev;
+
+#define SDL_logical_joydecl(d) d
+
+
+#else
+
+#define SDL_logical_joydecl(d)
+
+#endif /* USE_LOGICAL_JOYSTICKS */
+
+/* The maximum number of joysticks we'll detect */
+#define MAX_JOYSTICKS	32
+
+/* A list of available joysticks */
+static struct
+{
+        char* fname;
+#ifndef NO_LOGICAL_JOYSTICKS
+        SDL_Joystick* joy;
+        struct joystick_logicalmap* map;
+        int prev;
+        int next;
+        int logicalno;
+#endif /* USE_LOGICAL_JOYSTICKS */
+} SDL_joylist[MAX_JOYSTICKS];
+
+
+/* The private structure used to keep track of a joystick */
+struct joystick_hwdata {
+	int fd;
+	/* The current linux joystick driver maps hats to two axes */
+	struct hwdata_hat {
+		int axis[2];
+	} *hats;
+	/* The current linux joystick driver maps balls to two axes */
+	struct hwdata_ball {
+		int axis[2];
+	} *balls;
+
+	/* Support for the Linux 2.4 unified input interface */
+#if SDL_INPUT_LINUXEV
+	SDL_bool is_hid;
+	Uint8 key_map[KEY_MAX-BTN_MISC];
+	Uint8 abs_map[ABS_MAX];
+	struct axis_correct {
+		int used;
+		int coef[3];
+	} abs_correct[ABS_MAX];
+#endif
+};
+
+
+#ifndef NO_LOGICAL_JOYSTICKS
+
+static int CountLogicalJoysticks(int max)
+{
+   register int i, j, k, ret, prev;
+   const char* name;
+   int nbuttons, fd;
+   unsigned char n;
+
+   ret = 0;
+
+   for(i = 0; i < max; i++) {
+      name = SDL_SYS_JoystickName(i);
+	
+      fd = open(SDL_joylist[i].fname, O_RDONLY, 0);
+      if ( fd >= 0 ) {
+	 if ( ioctl(fd, JSIOCGBUTTONS, &n) < 0 ) {
+	    nbuttons = -1;
+	 } else {
+            nbuttons = n;
+	 }
+	 close(fd);
+      }
+      else {
+	 nbuttons=-1;
+      }
+
+      if (name) {
+         for(j = 0; j < SDL_arraysize(joystick_logicalmap); j++) {
+            if (!SDL_strcmp(name, joystick_logicalmap[j].name) && (nbuttons==-1 || nbuttons==joystick_logicalmap[j].nbuttons)) {
+               prev = i;
+               SDL_joylist[prev].map = &(joystick_logicalmap[j]);
+
+               for(k = 1; k < joystick_logicalmap[j].njoys; k++) {
+                  SDL_joylist[prev].next = max + ret;
+                  SDL_joylist[max+ret].prev = prev;
+		  
+                  prev = max + ret;
+                  SDL_joylist[prev].logicalno = k;
+                  SDL_joylist[prev].map = &(joystick_logicalmap[j]);
+                  ret++;
+               }
+
+               break;
+            }
+         }
+      }
+   }
+
+   return ret;
+}
+
+static void LogicalSuffix(int logicalno, char* namebuf, int len)
+{
+   register int slen;
+   const static char suffixs[] =
+      "01020304050607080910111213141516171819"
+      "20212223242526272829303132";
+   const char* suffix;
+   slen = SDL_strlen(namebuf);
+   suffix = NULL;
+
+   if (logicalno*2<sizeof(suffixs))
+      suffix = suffixs + (logicalno*2);
+
+   if (slen + 4 < len && suffix) {
+      namebuf[slen++] = ' ';
+      namebuf[slen++] = '#';
+      namebuf[slen++] = suffix[0];
+      namebuf[slen++] = suffix[1];
+      namebuf[slen++] = 0;
+   }
+}
+
+#endif /* USE_LOGICAL_JOYSTICKS */
+
+#if SDL_INPUT_LINUXEV
+#define test_bit(nr, addr) \
+	(((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+
+static int EV_IsJoystick(int fd)
+{
+	unsigned long evbit[40];
+	unsigned long keybit[40];
+	unsigned long absbit[40];
+
+	if ( (ioctl(fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0) ||
+	     (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0) ||
+	     (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit) < 0) ) {
+		return(0);
+	}
+	if (!(test_bit(EV_KEY, evbit) && test_bit(EV_ABS, evbit) &&
+	      test_bit(ABS_X, absbit) && test_bit(ABS_Y, absbit) &&
+	     (test_bit(BTN_TRIGGER, keybit) || test_bit(BTN_A, keybit) || test_bit(BTN_1, keybit)))) return 0;
+	return(1);
+}
+
+#endif /* SDL_INPUT_LINUXEV */
+
+/* Function to scan the system for joysticks */
+int SDL_SYS_JoystickInit(void)
+{
+	/* The base path of the joystick devices */
+	const char *joydev_pattern[] = {
+#if SDL_INPUT_LINUXEV
+		"/dev/input/event%d",
+#endif
+		"/dev/input/js%d",
+		"/dev/js%d"
+	};
+	int numjoysticks;
+	int i, j;
+	int fd;
+	char path[PATH_MAX];
+	dev_t dev_nums[MAX_JOYSTICKS];  /* major/minor device numbers */
+	struct stat sb;
+	int n, duplicate;
+
+	numjoysticks = 0;
+
+	/* First see if the user specified a joystick to use */
+	if ( SDL_getenv("SDL_JOYSTICK_DEVICE") != NULL ) {
+		SDL_strlcpy(path, SDL_getenv("SDL_JOYSTICK_DEVICE"), sizeof(path));
+		if ( stat(path, &sb) == 0 ) {
+			fd = open(path, O_RDONLY, 0);
+			if ( fd >= 0 ) {
+				/* Assume the user knows what they're doing. */
+				SDL_joylist[numjoysticks].fname = SDL_strdup(path);
+				if ( SDL_joylist[numjoysticks].fname ) {
+					dev_nums[numjoysticks] = sb.st_rdev;
+					++numjoysticks;
+				}
+				close(fd);
+			}
+		}
+	}
+
+	for ( i=0; i<SDL_arraysize(joydev_pattern); ++i ) {
+		for ( j=0; j < MAX_JOYSTICKS; ++j ) {
+			SDL_snprintf(path, SDL_arraysize(path), joydev_pattern[i], j);
+
+			/* rcg06302000 replaced access(F_OK) call with stat().
+			 * stat() will fail if the file doesn't exist, so it's
+			 * equivalent behaviour.
+			 */
+			if ( stat(path, &sb) == 0 ) {
+				/* Check to make sure it's not already in list.
+				 * This happens when we see a stick via symlink.
+				 */
+				duplicate = 0;
+				for (n=0; (n<numjoysticks) && !duplicate; ++n) {
+					if ( sb.st_rdev == dev_nums[n] ) {
+						duplicate = 1;
+					}
+				}
+				if (duplicate) {
+					continue;
+				}
+
+				fd = open(path, O_RDONLY, 0);
+				if ( fd < 0 ) {
+					continue;
+				}
+#if SDL_INPUT_LINUXEV
+#ifdef DEBUG_INPUT_EVENTS
+				printf("Checking %s\n", path);
+#endif
+				if ( (i == 0) && ! EV_IsJoystick(fd) ) {
+					close(fd);
+					continue;
+				}
+#endif
+				close(fd);
+
+				/* We're fine, add this joystick */
+				SDL_joylist[numjoysticks].fname = SDL_strdup(path);
+				if ( SDL_joylist[numjoysticks].fname ) {
+					dev_nums[numjoysticks] = sb.st_rdev;
+					++numjoysticks;
+				}
+			}
+		}
+
+#if SDL_INPUT_LINUXEV
+		/* This is a special case...
+		   If the event devices are valid then the joystick devices
+		   will be duplicates but without extra information about their
+		   hats or balls. Unfortunately, the event devices can't
+		   currently be calibrated, so it's a win-lose situation.
+		   So : /dev/input/eventX = /dev/input/jsY = /dev/jsY
+		*/
+		if ( (i == 0) && (numjoysticks > 0) )
+			break;
+#endif
+	}
+#ifndef NO_LOGICAL_JOYSTICKS
+	numjoysticks += CountLogicalJoysticks(numjoysticks);
+#endif
+
+	return(numjoysticks);
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	int fd;
+	static char namebuf[128];
+	char *name;
+	SDL_logical_joydecl(int oindex = index);
+
+#ifndef NO_LOGICAL_JOYSTICKS
+	SDL_joylist_head(index, index);
+#endif
+	name = NULL;
+	fd = open(SDL_joylist[index].fname, O_RDONLY, 0);
+	if ( fd >= 0 ) {
+		if ( 
+#if SDL_INPUT_LINUXEV
+		     (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) &&
+#endif
+		     (ioctl(fd, JSIOCGNAME(sizeof(namebuf)), namebuf) <= 0) ) {
+			name = SDL_joylist[index].fname;
+		} else {
+			name = namebuf;
+		}
+		close(fd);
+
+
+#ifndef NO_LOGICAL_JOYSTICKS
+		if (SDL_joylist[oindex].prev || SDL_joylist[oindex].next || index!=oindex)
+		{
+       		   LogicalSuffix(SDL_joylist[oindex].logicalno, namebuf, 128);
+		}
+#endif
+	}
+	return name;
+}
+
+static int allocate_hatdata(SDL_Joystick *joystick)
+{
+	int i;
+
+	joystick->hwdata->hats = (struct hwdata_hat *)SDL_malloc(
+		joystick->nhats * sizeof(struct hwdata_hat));
+	if ( joystick->hwdata->hats == NULL ) {
+		return(-1);
+	}
+	for ( i=0; i<joystick->nhats; ++i ) {
+		joystick->hwdata->hats[i].axis[0] = 1;
+		joystick->hwdata->hats[i].axis[1] = 1;
+	}
+	return(0);
+}
+
+static int allocate_balldata(SDL_Joystick *joystick)
+{
+	int i;
+
+	joystick->hwdata->balls = (struct hwdata_ball *)SDL_malloc(
+		joystick->nballs * sizeof(struct hwdata_ball));
+	if ( joystick->hwdata->balls == NULL ) {
+		return(-1);
+	}
+	for ( i=0; i<joystick->nballs; ++i ) {
+		joystick->hwdata->balls[i].axis[0] = 0;
+		joystick->hwdata->balls[i].axis[1] = 0;
+	}
+	return(0);
+}
+
+static SDL_bool JS_ConfigJoystick(SDL_Joystick *joystick, int fd)
+{
+	SDL_bool handled;
+	unsigned char n;
+	int old_axes, tmp_naxes, tmp_nhats, tmp_nballs;
+	const char *name;
+	char *env, env_name[128];
+	int i;
+
+	handled = SDL_FALSE;
+
+	/* Default joystick device settings */
+	if ( ioctl(fd, JSIOCGAXES, &n) < 0 ) {
+		joystick->naxes = 2;
+	} else {
+		joystick->naxes = n;
+	}
+	if ( ioctl(fd, JSIOCGBUTTONS, &n) < 0 ) {
+		joystick->nbuttons = 2;
+	} else {
+		joystick->nbuttons = n;
+	}
+
+	name = SDL_SYS_JoystickName(joystick->index);
+	old_axes = joystick->naxes;
+
+	/* Generic analog joystick support */
+	if ( SDL_strstr(name, "Analog") == name && SDL_strstr(name, "-hat") ) {
+		if ( SDL_sscanf(name,"Analog %d-axis %*d-button %d-hat",
+			&tmp_naxes, &tmp_nhats) == 2 ) {
+
+			joystick->naxes = tmp_naxes;
+			joystick->nhats = tmp_nhats;
+
+			handled = SDL_TRUE;
+		}
+	}
+
+	/* Special joystick support */
+	for ( i=0; i < SDL_arraysize(special_joysticks); ++i ) {
+		if ( SDL_strcmp(name, special_joysticks[i].name) == 0 ) {
+
+			joystick->naxes = special_joysticks[i].naxes;
+			joystick->nhats = special_joysticks[i].nhats;
+			joystick->nballs = special_joysticks[i].nballs;
+
+			handled = SDL_TRUE;
+			break;
+		}
+	}
+
+	/* User environment joystick support */
+	if ( (env = SDL_getenv("SDL_LINUX_JOYSTICK")) ) {
+		*env_name = '\0';
+		if ( *env == '\'' && SDL_sscanf(env, "'%[^']s'", env_name) == 1 )
+			env += SDL_strlen(env_name)+2;
+		else if ( SDL_sscanf(env, "%s", env_name) == 1 )
+			env += SDL_strlen(env_name);
+
+		if ( SDL_strcmp(name, env_name) == 0 ) {
+
+			if ( SDL_sscanf(env, "%d %d %d", &tmp_naxes, &tmp_nhats,
+				&tmp_nballs) == 3 ) {
+
+				joystick->naxes = tmp_naxes;
+				joystick->nhats = tmp_nhats;
+				joystick->nballs = tmp_nballs;
+
+				handled = SDL_TRUE;
+			}
+		}
+	}
+
+	/* Remap hats and balls */
+	if (handled) {
+		if ( joystick->nhats > 0 ) {
+			if ( allocate_hatdata(joystick) < 0 ) {
+				joystick->nhats = 0;
+			}
+		}
+		if ( joystick->nballs > 0 ) {
+			if ( allocate_balldata(joystick) < 0 ) {
+				joystick->nballs = 0;
+			}
+		}
+	}
+
+	return(handled);
+}
+
+#if SDL_INPUT_LINUXEV
+
+static SDL_bool EV_ConfigJoystick(SDL_Joystick *joystick, int fd)
+{
+	int i, t;
+	unsigned long keybit[40];
+	unsigned long absbit[40];
+	unsigned long relbit[40];
+
+	/* See if this device uses the new unified event API */
+	if ( (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) >= 0) &&
+	     (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit) >= 0) &&
+	     (ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relbit)), relbit) >= 0) ) {
+		joystick->hwdata->is_hid = SDL_TRUE;
+
+		/* Get the number of buttons, axes, and other thingamajigs */
+		for ( i=BTN_JOYSTICK; i < KEY_MAX; ++i ) {
+			if ( test_bit(i, keybit) ) {
+#ifdef DEBUG_INPUT_EVENTS
+				printf("Joystick has button: 0x%x\n", i);
+#endif
+				joystick->hwdata->key_map[i-BTN_MISC] =
+						joystick->nbuttons;
+				++joystick->nbuttons;
+			}
+		}
+		for ( i=BTN_MISC; i < BTN_JOYSTICK; ++i ) {
+			if ( test_bit(i, keybit) ) {
+#ifdef DEBUG_INPUT_EVENTS
+				printf("Joystick has button: 0x%x\n", i);
+#endif
+				joystick->hwdata->key_map[i-BTN_MISC] =
+						joystick->nbuttons;
+				++joystick->nbuttons;
+			}
+		}
+		for ( i=0; i<ABS_MAX; ++i ) {
+			/* Skip hats */
+			if ( i == ABS_HAT0X ) {
+				i = ABS_HAT3Y;
+				continue;
+			}
+			if ( test_bit(i, absbit) ) {
+				int values[5];
+
+				if ( ioctl(fd, EVIOCGABS(i), values) < 0 )
+					continue;
+#ifdef DEBUG_INPUT_EVENTS
+				printf("Joystick has absolute axis: %x\n", i);
+				printf("Values = { %d, %d, %d, %d, %d }\n",
+					values[0], values[1],
+					values[2], values[3], values[4]);
+#endif /* DEBUG_INPUT_EVENTS */
+				joystick->hwdata->abs_map[i] = joystick->naxes;
+				if ( values[1] == values[2] ) {
+				    joystick->hwdata->abs_correct[i].used = 0;
+				} else {
+				    joystick->hwdata->abs_correct[i].used = 1;
+				    joystick->hwdata->abs_correct[i].coef[0] =
+					(values[2] + values[1]) / 2 - values[4];
+				    joystick->hwdata->abs_correct[i].coef[1] =
+					(values[2] + values[1]) / 2 + values[4];
+				    t = ((values[2] - values[1]) / 2 - 2 * values[4]);
+				    if ( t != 0 ) {
+					joystick->hwdata->abs_correct[i].coef[2] = (1 << 29) / t;
+				    } else {
+					joystick->hwdata->abs_correct[i].coef[2] = 0;
+				    }
+				}
+				++joystick->naxes;
+			}
+		}
+		for ( i=ABS_HAT0X; i <= ABS_HAT3Y; i += 2 ) {
+			if ( test_bit(i, absbit) || test_bit(i+1, absbit) ) {
+#ifdef DEBUG_INPUT_EVENTS
+				printf("Joystick has hat %d\n",(i-ABS_HAT0X)/2);
+#endif
+				++joystick->nhats;
+			}
+		}
+		if ( test_bit(REL_X, relbit) || test_bit(REL_Y, relbit) ) {
+			++joystick->nballs;
+		}
+
+		/* Allocate data to keep track of these thingamajigs */
+		if ( joystick->nhats > 0 ) {
+			if ( allocate_hatdata(joystick) < 0 ) {
+				joystick->nhats = 0;
+			}
+		}
+		if ( joystick->nballs > 0 ) {
+			if ( allocate_balldata(joystick) < 0 ) {
+				joystick->nballs = 0;
+			}
+		}
+	}
+	return(joystick->hwdata->is_hid);
+}
+
+#endif /* SDL_INPUT_LINUXEV */
+
+#ifndef NO_LOGICAL_JOYSTICKS
+static void ConfigLogicalJoystick(SDL_Joystick *joystick)
+{
+        struct joystick_logical_layout* layout;
+                                                                                
+        layout = SDL_joylist[joystick->index].map->layout +
+                SDL_joylist[joystick->index].logicalno;
+                                                                                
+        joystick->nbuttons = layout->nbuttons;
+        joystick->nhats = layout->nhats;
+        joystick->naxes = layout->naxes;
+        joystick->nballs = layout->nballs;
+}
+#endif
+
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	int fd;
+	SDL_logical_joydecl(int realindex);
+	SDL_logical_joydecl(SDL_Joystick *realjoy = NULL);
+
+	/* Open the joystick and set the joystick file descriptor */
+#ifndef NO_LOGICAL_JOYSTICKS
+	if (SDL_joylist[joystick->index].fname == NULL) {
+		SDL_joylist_head(realindex, joystick->index);
+		realjoy = SDL_JoystickOpen(realindex);
+
+		if (realjoy == NULL)
+			return(-1);
+                                                                                
+		fd = realjoy->hwdata->fd;
+
+	} else {
+		fd = open(SDL_joylist[joystick->index].fname, O_RDONLY, 0);
+	}
+	SDL_joylist[joystick->index].joy = joystick;
+#else
+	fd = open(SDL_joylist[joystick->index].fname, O_RDONLY, 0);
+#endif
+
+	if ( fd < 0 ) {
+		SDL_SetError("Unable to open %s\n",
+		             SDL_joylist[joystick->index]);
+		return(-1);
+	}
+	joystick->hwdata = (struct joystick_hwdata *)
+	                   SDL_malloc(sizeof(*joystick->hwdata));
+	if ( joystick->hwdata == NULL ) {
+		SDL_OutOfMemory();
+		close(fd);
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(*joystick->hwdata));
+	joystick->hwdata->fd = fd;
+
+	/* Set the joystick to non-blocking read mode */
+	fcntl(fd, F_SETFL, O_NONBLOCK);
+
+	/* Get the number of buttons and axes on the joystick */
+#ifndef NO_LOGICAL_JOYSTICKS
+	if (realjoy)
+		ConfigLogicalJoystick(joystick);
+	else
+#endif
+#if SDL_INPUT_LINUXEV
+	if ( ! EV_ConfigJoystick(joystick, fd) )
+#endif
+		JS_ConfigJoystick(joystick, fd);
+
+	return(0);
+}
+
+#ifndef NO_LOGICAL_JOYSTICKS
+
+static SDL_Joystick* FindLogicalJoystick(
+   SDL_Joystick *joystick, struct joystick_logical_mapping* v)
+{
+        SDL_Joystick *logicaljoy;
+        register int i;
+
+        i = joystick->index;
+        logicaljoy = NULL;
+
+        /* get the fake joystick that will receive the event
+         */
+        for(;;) {
+
+           if (SDL_joylist[i].logicalno == v->njoy) {
+              logicaljoy = SDL_joylist[i].joy;
+              break;
+           }
+
+           if (SDL_joylist[i].next == 0)
+              break;
+
+           i = SDL_joylist[i].next;
+
+        }
+
+        return logicaljoy;
+}
+
+static int LogicalJoystickButton(
+   SDL_Joystick *joystick, Uint8 button, Uint8 state){
+        struct joystick_logical_mapping* buttons;
+        SDL_Joystick *logicaljoy = NULL;
+
+        /* if there's no map then this is just a regular joystick
+         */
+        if (SDL_joylist[joystick->index].map == NULL)
+           return 0;
+
+        /* get the logical joystick that will receive the event
+         */
+        buttons = SDL_joylist[joystick->index].map->buttonmap+button;
+        logicaljoy = FindLogicalJoystick(joystick, buttons);
+
+        if (logicaljoy == NULL)
+           return 1;
+
+        SDL_PrivateJoystickButton(logicaljoy, buttons->nthing, state);
+
+        return 1;
+}
+
+static int LogicalJoystickAxis(
+	SDL_Joystick *joystick, Uint8 axis, Sint16 value)
+{
+        struct joystick_logical_mapping* axes;
+        SDL_Joystick *logicaljoy = NULL;
+
+        /* if there's no map then this is just a regular joystick
+         */
+        if (SDL_joylist[joystick->index].map == NULL)
+           return 0;
+
+        /* get the logical joystick that will receive the event
+         */
+        axes = SDL_joylist[joystick->index].map->axismap+axis;
+        logicaljoy = FindLogicalJoystick(joystick, axes);
+
+        if (logicaljoy == NULL)
+           return 1;
+
+        SDL_PrivateJoystickAxis(logicaljoy, axes->nthing, value);
+
+        return 1;
+}
+#endif /* USE_LOGICAL_JOYSTICKS */
+
+static __inline__
+void HandleHat(SDL_Joystick *stick, Uint8 hat, int axis, int value)
+{
+	struct hwdata_hat *the_hat;
+	const Uint8 position_map[3][3] = {
+		{ SDL_HAT_LEFTUP, SDL_HAT_UP, SDL_HAT_RIGHTUP },
+		{ SDL_HAT_LEFT, SDL_HAT_CENTERED, SDL_HAT_RIGHT },
+		{ SDL_HAT_LEFTDOWN, SDL_HAT_DOWN, SDL_HAT_RIGHTDOWN }
+	};
+	SDL_logical_joydecl(SDL_Joystick *logicaljoy = NULL);
+	SDL_logical_joydecl(struct joystick_logical_mapping* hats = NULL);
+
+	the_hat = &stick->hwdata->hats[hat];
+	if ( value < 0 ) {
+		value = 0;
+	} else
+	if ( value == 0 ) {
+		value = 1;
+	} else
+	if ( value > 0 ) {
+		value = 2;
+	}
+	if ( value != the_hat->axis[axis] ) {
+		the_hat->axis[axis] = value;
+
+#ifndef NO_LOGICAL_JOYSTICKS
+		/* if there's no map then this is just a regular joystick
+		*/
+		if (SDL_joylist[stick->index].map != NULL) {
+
+			/* get the fake joystick that will receive the event
+			*/
+			hats = SDL_joylist[stick->index].map->hatmap+hat;
+			logicaljoy = FindLogicalJoystick(stick, hats);
+		}
+
+		if (logicaljoy) {
+			stick = logicaljoy;
+			hat = hats->nthing;
+		}
+#endif /* USE_LOGICAL_JOYSTICKS */
+
+		SDL_PrivateJoystickHat(stick, hat,
+			position_map[the_hat->axis[1]][the_hat->axis[0]]);
+	}
+}
+
+static __inline__
+void HandleBall(SDL_Joystick *stick, Uint8 ball, int axis, int value)
+{
+	stick->hwdata->balls[ball].axis[axis] += value;
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+static __inline__ void JS_HandleEvents(SDL_Joystick *joystick)
+{
+	struct js_event events[32];
+	int i, len;
+	Uint8 other_axis;
+
+#ifndef NO_LOGICAL_JOYSTICKS
+	if (SDL_joylist[joystick->index].fname == NULL) {
+		SDL_joylist_head(i, joystick->index);
+		JS_HandleEvents(SDL_joylist[i].joy);
+		return;
+	}
+#endif
+
+	while ((len=read(joystick->hwdata->fd, events, (sizeof events))) > 0) {
+		len /= sizeof(events[0]);
+		for ( i=0; i<len; ++i ) {
+			switch (events[i].type & ~JS_EVENT_INIT) {
+			    case JS_EVENT_AXIS:
+				if ( events[i].number < joystick->naxes ) {
+#ifndef NO_LOGICAL_JOYSTICKS
+					if (!LogicalJoystickAxis(joystick,
+				           events[i].number, events[i].value))
+#endif
+					SDL_PrivateJoystickAxis(joystick,
+				           events[i].number, events[i].value);
+					break;
+				}
+				events[i].number -= joystick->naxes;
+				other_axis = (events[i].number / 2);
+				if ( other_axis < joystick->nhats ) {
+					HandleHat(joystick, other_axis,
+						events[i].number%2,
+						events[i].value);
+					break;
+				}
+				events[i].number -= joystick->nhats*2;
+				other_axis = (events[i].number / 2);
+				if ( other_axis < joystick->nballs ) {
+					HandleBall(joystick, other_axis,
+						events[i].number%2,
+						events[i].value);
+					break;
+				}
+				break;
+			    case JS_EVENT_BUTTON:
+#ifndef NO_LOGICAL_JOYSTICKS
+				if (!LogicalJoystickButton(joystick,
+				           events[i].number, events[i].value))
+#endif
+				SDL_PrivateJoystickButton(joystick,
+				           events[i].number, events[i].value);
+				break;
+			    default:
+				/* ?? */
+				break;
+			}
+		}
+	}
+}
+#if SDL_INPUT_LINUXEV
+static __inline__ int EV_AxisCorrect(SDL_Joystick *joystick, int which, int value)
+{
+	struct axis_correct *correct;
+
+	correct = &joystick->hwdata->abs_correct[which];
+	if ( correct->used ) {
+		if ( value > correct->coef[0] ) {
+			if ( value < correct->coef[1] ) {
+				return 0;
+			}
+			value -= correct->coef[1];
+		} else {
+			value -= correct->coef[0];
+		}
+		value *= correct->coef[2];
+		value >>= 14;
+	}
+
+	/* Clamp and return */
+	if ( value < -32768 ) return -32768;
+	if ( value >  32767 ) return  32767;
+
+	return value;
+}
+
+static __inline__ void EV_HandleEvents(SDL_Joystick *joystick)
+{
+	struct input_event events[32];
+	int i, len;
+	int code;
+
+#ifndef NO_LOGICAL_JOYSTICKS
+	if (SDL_joylist[joystick->index].fname == NULL) {
+		SDL_joylist_head(i, joystick->index);
+		return EV_HandleEvents(SDL_joylist[i].joy);
+	}
+#endif
+
+	while ((len=read(joystick->hwdata->fd, events, (sizeof events))) > 0) {
+		len /= sizeof(events[0]);
+		for ( i=0; i<len; ++i ) {
+			code = events[i].code;
+			switch (events[i].type) {
+			    case EV_KEY:
+				if ( code >= BTN_MISC ) {
+					code -= BTN_MISC;
+#ifndef NO_LOGICAL_JOYSTICKS
+					if (!LogicalJoystickButton(joystick,
+				           joystick->hwdata->key_map[code],
+					   events[i].value))
+#endif
+					SDL_PrivateJoystickButton(joystick,
+				           joystick->hwdata->key_map[code],
+					   events[i].value);
+				}
+				break;
+			    case EV_ABS:
+				switch (code) {
+				    case ABS_HAT0X:
+				    case ABS_HAT0Y:
+				    case ABS_HAT1X:
+				    case ABS_HAT1Y:
+				    case ABS_HAT2X:
+				    case ABS_HAT2Y:
+				    case ABS_HAT3X:
+				    case ABS_HAT3Y:
+					code -= ABS_HAT0X;
+					HandleHat(joystick, code/2, code%2,
+							events[i].value);
+					break;
+				    default:
+					events[i].value = EV_AxisCorrect(joystick, code, events[i].value);
+#ifndef NO_LOGICAL_JOYSTICKS
+					if (!LogicalJoystickAxis(joystick,
+				           joystick->hwdata->abs_map[code],
+					   events[i].value))
+#endif
+					SDL_PrivateJoystickAxis(joystick,
+				           joystick->hwdata->abs_map[code],
+					   events[i].value);
+					break;
+				}
+				break;
+			    case EV_REL:
+				switch (code) {
+				    case REL_X:
+				    case REL_Y:
+					code -= REL_X;
+					HandleBall(joystick, code/2, code%2,
+							events[i].value);
+					break;
+				    default:
+					break;
+				}
+				break;
+			    default:
+				break;
+			}
+		}
+	}
+}
+#endif /* SDL_INPUT_LINUXEV */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	int i;
+	
+#if SDL_INPUT_LINUXEV
+	if ( joystick->hwdata->is_hid )
+		EV_HandleEvents(joystick);
+	else
+#endif
+		JS_HandleEvents(joystick);
+
+	/* Deliver ball motion updates */
+	for ( i=0; i<joystick->nballs; ++i ) {
+		int xrel, yrel;
+
+		xrel = joystick->hwdata->balls[i].axis[0];
+		yrel = joystick->hwdata->balls[i].axis[1];
+		if ( xrel || yrel ) {
+			joystick->hwdata->balls[i].axis[0] = 0;
+			joystick->hwdata->balls[i].axis[1] = 0;
+			SDL_PrivateJoystickBall(joystick, (Uint8)i, xrel, yrel);
+		}
+	}
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+#ifndef NO_LOGICAL_JOYSTICKS
+	register int i;
+	if (SDL_joylist[joystick->index].fname == NULL) {
+		SDL_joylist_head(i, joystick->index);
+		SDL_JoystickClose(SDL_joylist[i].joy);
+	}
+#endif
+
+	if ( joystick->hwdata ) {
+#ifndef NO_LOGICAL_JOYSTICKS
+		if (SDL_joylist[joystick->index].fname != NULL)
+#endif
+		close(joystick->hwdata->fd);
+		if ( joystick->hwdata->hats ) {
+			SDL_free(joystick->hwdata->hats);
+		}
+		if ( joystick->hwdata->balls ) {
+			SDL_free(joystick->hwdata->balls);
+		}
+		SDL_free(joystick->hwdata);
+		joystick->hwdata = NULL;
+	}
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+	int i;
+
+	for ( i=0; SDL_joylist[i].fname; ++i ) {
+		SDL_free(SDL_joylist[i].fname);
+	}
+	SDL_joylist[0].fname = NULL;
+}
+
+#endif /* SDL_JOYSTICK_LINUX */
diff -ruN SDL-1.2.13/src/joystick/linux/SDL_sysjoystick_c.h SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick_c.h
--- SDL-1.2.13/src/joystick/linux/SDL_sysjoystick_c.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/linux/SDL_sysjoystick_c.h	2017-12-18 15:12:28 +0000
@@ -0,0 +1,55 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+
+#if SDL_INPUT_LINUXEV
+#include <linux/input.h>
+#endif
+
+/* The private structure used to keep track of a joystick */
+struct joystick_hwdata
+{
+   int fd;
+   char *fname; /* Used in haptic subsystem */
+
+   /* The current linux joystick driver maps hats to two axes */
+   struct hwdata_hat
+   {   
+      int axis[2];
+   } *hats;
+   /* The current linux joystick driver maps balls to two axes */
+   struct hwdata_ball
+   {   
+      int axis[2];
+   } *balls;
+
+   /* Support for the Linux 2.4 unified input interface */
+#if SDL_INPUT_LINUXEV
+   SDL_bool is_hid;
+   Uint8 key_map[KEY_MAX - BTN_MISC];
+   Uint8 abs_map[ABS_MAX];
+   struct axis_correct
+   {
+      int used;
+      int coef[3];
+   } abs_correct[ABS_MAX];
+#endif
+};
\ No newline at end of file
diff -ruN SDL-1.2.13/src/joystick/win32/SDL_dxjoystick_c.h SDL-1.2.13_OOx64/src/joystick/win32/SDL_dxjoystick_c.h
--- SDL-1.2.13/src/joystick/win32/SDL_dxjoystick_c.h	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/joystick/win32/SDL_dxjoystick_c.h	2017-12-20 12:47:06 +0000
@@ -0,0 +1,81 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef SDL_JOYSTICK_DINPUT_H
+
+/* DirectInput joystick driver; written by Glenn Maynard, based on Andrei de
+ * A. Formiga's WINMM driver. 
+ *
+ * Hats and sliders are completely untested; the app I'm writing this for mostly
+ * doesn't use them and I don't own any joysticks with them. 
+ *
+ * We don't bother to use event notification here.  It doesn't seem to work
+ * with polled devices, and it's fine to call IDirectInputDevice2_GetDeviceData and
+ * let it return 0 events. */
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+#define DIRECTINPUT_VERSION 0x0700 /* Need version 7 for force feedback. */
+#include <dinput.h>
+#ifdef _MSC_VER
+    /* Used for the c_dfDIJoystick2 symbol (no imports are used) */
+#   pragma comment (lib, "dinput.lib")
+#endif
+#include <dxerr8.h>
+#ifdef _MSC_VER
+#   pragma comment (lib, "dxerr8.lib")
+#endif
+
+
+#define MAX_INPUTS	256     /* each joystick can have up to 256 inputs */
+
+
+/* local types */
+typedef enum Type
+{ BUTTON, AXIS, HAT } Type;
+
+typedef struct input_t
+{
+    /* DirectInput offset for this input type: */
+    DWORD ofs;
+
+    /* Button, axis or hat: */
+    Type type;
+
+    /* SDL input offset: */
+    Uint8 num;
+} input_t;
+
+/* The private structure used to keep track of a joystick */
+struct joystick_hwdata
+{
+    LPDIRECTINPUTDEVICE2 InputDevice;
+    DIDEVCAPS Capabilities;
+    int buffered;
+
+    input_t Inputs[MAX_INPUTS];
+    int NumInputs;
+};
+
+#endif /* SDL_JOYSTICK_DINPUT_H */
diff -ruN SDL-1.2.13/src/linux/SDL_syshaptic.c SDL-1.2.13_OOx64/src/linux/SDL_syshaptic.c
--- SDL-1.2.13/src/linux/SDL_syshaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/linux/SDL_syshaptic.c	2017-12-18 15:09:16 +0000
@@ -0,0 +1,961 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_LINUX
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/linux/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <unistd.h> /* close */
+#include <linux/input.h> /* Force feedback linux stuff. */
+#include <fcntl.h> /* O_RDWR */
+#include <limits.h> /* INT_MAX */
+#include <errno.h> /* errno, strerror */
+#include <math.h> /* atan2 */
+#include <sys/stat.h> /* stat */
+
+/* Just in case. */
+#ifndef M_PI
+#  define M_PI     3.14159265358979323846
+#endif
+
+
+#define MAX_HAPTICS  32 /* It's doubtful someone has more then 32 evdev */
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char *fname; /* Dev path name (like /dev/input/event1) */
+   SDL_Haptic *haptic; /* Assosciated haptic. */
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   int fd; /* File descriptor of the device. */
+   char *fname; /* Points to the name in SDL_hapticlist. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   struct ff_effect effect; /* The linux kernel effect structure. */
+};
+
+
+
+#define test_bit(nr, addr) \
+   (((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+#define EV_TEST(ev,f) \
+   if (test_bit((ev), features)) ret |= (f);
+/*
+ * Test whether a device has haptic properties.
+ * Returns available properties or 0 if there are none.
+ */
+static int
+EV_IsHaptic(int fd)
+{
+   unsigned int ret;
+   unsigned long features[1 + FF_MAX/sizeof(unsigned long)];
+
+   /* Ask device for what it has. */
+   ret = 0;
+   if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(features)), features) < 0) {
+      SDL_SetError("Haptic: Unable to get device's features: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Convert supported features to SDL_HAPTIC platform-neutral features. */
+   EV_TEST(FF_CONSTANT,   SDL_HAPTIC_CONSTANT);
+   EV_TEST(FF_SINE,       SDL_HAPTIC_SINE);
+   EV_TEST(FF_SQUARE,     SDL_HAPTIC_SQUARE);
+   EV_TEST(FF_TRIANGLE,   SDL_HAPTIC_TRIANGLE);
+   EV_TEST(FF_SAW_UP,     SDL_HAPTIC_SAWTOOTHUP);
+   EV_TEST(FF_SAW_DOWN,   SDL_HAPTIC_SAWTOOTHDOWN);
+   EV_TEST(FF_RAMP,       SDL_HAPTIC_RAMP);
+   EV_TEST(FF_SPRING,     SDL_HAPTIC_SPRING);
+   EV_TEST(FF_FRICTION,   SDL_HAPTIC_FRICTION);
+   EV_TEST(FF_DAMPER,     SDL_HAPTIC_DAMPER);
+   EV_TEST(FF_INERTIA,    SDL_HAPTIC_INERTIA);
+   EV_TEST(FF_CUSTOM,     SDL_HAPTIC_CUSTOM);
+   EV_TEST(FF_GAIN,       SDL_HAPTIC_GAIN);
+   EV_TEST(FF_AUTOCENTER, SDL_HAPTIC_AUTOCENTER);
+
+   /* Return what it supports. */
+   return ret;
+}
+
+
+/*
+ * Tests whether a device is a mouse or not.
+ */
+static int
+EV_IsMouse(int fd)
+{
+   unsigned long argp[40];
+
+   /* Ask for supported features. */
+   if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(argp)), argp) < 0) {
+      return -1;
+   }
+
+   /* Currently we only test for BTN_MOUSE which can give fake positives. */
+   if (test_bit(BTN_MOUSE,argp) != 0) {
+      return 1;
+   }
+
+   return 0;
+}
+
+/*
+ * Initializes the haptic subsystem by finding available devices.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   const char joydev_pattern[] = "/dev/input/event%d";
+   dev_t dev_nums[MAX_HAPTICS];
+   char path[PATH_MAX];
+   struct stat sb;
+   int fd;
+   int i, j, k;
+   int duplicate;
+   int numhaptics;
+
+   numhaptics = 0;
+
+   /* 
+    * Limit amount of checks to MAX_HAPTICS since we may or may not have
+    * permission to some or all devices.
+    */
+   i = 0;
+   for (j = 0; j < MAX_HAPTICS; ++j) {
+
+      snprintf(path, PATH_MAX, joydev_pattern, i++);
+
+      /* check to see if file exists */
+      if (stat(path,&sb) != 0)
+         break;
+
+      /* check for duplicates */
+      duplicate = 0;
+      for (k = 0; (k < numhaptics) && !duplicate; ++k) {
+         if (sb.st_rdev == dev_nums[k]) {
+            duplicate = 1;
+         }                                                     
+      }                                                         
+      if (duplicate) {
+         continue;
+      }
+
+      /* try to open */
+      fd = open(path, O_RDWR, 0);
+      if (fd < 0) continue;
+
+#ifdef DEBUG_INPUT_EVENTS
+      printf("Checking %s\n", path);
+#endif          
+
+      /* see if it works */
+      if (EV_IsHaptic(fd) > 0) {
+         SDL_hapticlist[numhaptics].fname = SDL_strdup(path);
+         SDL_hapticlist[numhaptics].haptic = NULL;
+         dev_nums[numhaptics] = sb.st_rdev;
+         ++numhaptics;
+      }
+      close(fd);
+   }
+
+   return numhaptics;
+}
+
+
+/*
+ * Gets the name from a file descriptor.
+ */
+static const char *
+SDL_SYS_HapticNameFromFD(int fd)
+{
+   static char namebuf[128];
+
+   /* We use the evdev name ioctl. */
+   if (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) {
+      return NULL;
+   }
+
+   return namebuf;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   int fd;
+   const char *name;
+
+   /* Open the haptic device. */
+   name = NULL;
+   fd = open(SDL_hapticlist[index].fname, O_RDONLY, 0);
+
+   if (fd >= 0) {
+
+      name = SDL_SYS_HapticNameFromFD(fd);
+      if (name==NULL) {
+         /* No name found, return device character device */
+         name = SDL_hapticlist[index].fname;
+      }
+   }
+   close(fd);
+
+   return name;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromFD(SDL_Haptic * haptic, int fd)
+{
+   const char *name;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+   /* Set the data. */
+   haptic->hwdata->fd = fd;
+   haptic->supported = EV_IsHaptic(fd);
+   haptic->naxes = 2; /* Hardcoded for now, not sure if it's possible to find out. */
+
+   /* Set the effects */
+   if (ioctl(fd, EVIOCGEFFECTS, &haptic->neffects) < 0) {
+      SDL_SetError("Haptic: Unable to query device memory: %s", strerror(errno));
+      goto open_err;
+   }
+   haptic->nplaying = haptic->neffects; /* Linux makes no distinction. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+
+   return 0;
+
+   /* Error handling */
+open_err:
+   close(fd);
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   int fd;
+   int ret;
+
+   /* Open the character device */
+   fd = open(SDL_hapticlist[haptic->index].fname, O_RDWR, 0);
+   if (fd < 0) {
+      SDL_SetError("Haptic: Unable to open %s: %s",
+            SDL_hapticlist[haptic->index], strerror(errno));
+      return -1;
+   }
+
+   /* Try to create the haptic. */
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   /* Set the fname. */
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int fd;
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+
+      /* Open the device. */
+      fd = open(SDL_hapticlist[i].fname, O_RDWR, 0);
+      if (fd < 0) {
+         SDL_SetError("Haptic: Unable to open %s: %s",
+               SDL_hapticlist[i], strerror(errno));
+         return -1;
+      }
+
+      /* Is it a mouse? */
+      if (EV_IsMouse(fd)) {
+         close(fd);
+         return i;
+      }
+
+      close(fd);
+   }
+   
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return EV_IsHaptic(joystick->hwdata->fd);
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   /* We are assuming linux is using evdev which should trump the old
+    * joystick methods. */
+   if (SDL_strcmp(joystick->hwdata->fname,haptic->hwdata->fname)==0) {
+      return 1;
+   }
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   int i;
+   int fd;
+   int ret;
+
+   /* Find the joystick in the haptic list. */
+   for (i=0; i<MAX_HAPTICS; i++) {
+      if (SDL_hapticlist[i].fname != NULL) {
+         if (SDL_strcmp(SDL_hapticlist[i].fname, joystick->hwdata->fname)==0) {
+            haptic->index = i;
+         }
+      }
+   }
+
+   fd = open(joystick->hwdata->fname, O_RDWR, 0);
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      close(haptic->hwdata->fd);
+
+      /* Free */
+      SDL_free(haptic->hwdata);                                           
+      haptic->hwdata = NULL;  
+   }
+
+   /* Clear the rest. */
+   SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; SDL_hapticlist[i].fname != NULL; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      SDL_free(SDL_hapticlist[i].fname);
+   }
+   SDL_hapticlist[0].fname = NULL;
+}
+
+
+/*
+ * Converts an SDL button to a ff_trigger button.
+ */
+static Uint16
+SDL_SYS_ToButton( Uint16 button )
+{
+   Uint16 ff_button;
+
+   ff_button = 0;
+
+   /*
+    * Not sure what the proper syntax is because this actually isn't implemented
+    * in the current kernel from what I've seen (2.6.26).
+    */
+   if (button != 0) {
+      ff_button = BTN_GAMEPAD + button - 1;
+   }
+
+   return ff_button;
+}
+
+
+/*
+ * Returns the ff_effect usable direction from a SDL_HapticDirection.
+ */
+static Uint16
+SDL_SYS_ToDirection( SDL_HapticDirection * dir )
+{
+   Uint32 tmp;
+   float f; /* Ideally we'd use fixed point math instead of floats... */
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         /* Linux directions start from south.
+         		(and range from 0 to 0xFFFF)
+	 			   Quoting include/linux/input.h, line 926:
+	 			   Direction of the effect is encoded as follows:
+	 					0 deg -> 0x0000 (down)
+	 					90 deg -> 0x4000 (left)
+	 					180 deg -> 0x8000 (up)
+	 					270 deg -> 0xC000 (right)
+	 				*/
+         tmp = (((18000 + dir->dir[0]) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_CARTESIAN:
+         f = atan2(dir->dir[1], dir->dir[0]);
+		 /* 
+		   atan2 takes the parameters: Y-axis-value and X-axis-value (in that order)
+		    - Y-axis-value is the second coordinate (from center to SOUTH)
+		    - X-axis-value is the first coordinate (from center to EAST)
+		   	 We add 36000, because atan2 also returns negative values. Then we practically
+			 have the first spherical value. Therefore we proceed as in case
+			 SDL_HAPTIC_SPHERICAL and add another 9000 to get the polar value.
+		   --> add 45000 in total
+		   --> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+		 tmp = (((int) (f * 18000. / M_PI)) + 45000) % 36000;
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_SPHERICAL:
+		 /*
+			We convert to polar, because that's the only supported direction on Linux.
+			The first value of a spherical direction is practically the same as a
+			Polar direction, except that we have to add 90 degrees. It is the angle
+			from EAST {1,0} towards SOUTH {0,1}.
+			--> add 9000
+			--> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+         tmp = ((dir->dir[0]) + 9000) % 36000;    /* Convert to polars */
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      default:
+         SDL_SetError("Haptic: Unsupported direction type.");
+         return (Uint16)-1;
+   }
+
+   return 0;
+}
+
+
+#define  CLAMP(x)    (((x) > 32767) ? 32767 : x)
+/*
+ * Initializes the linux effect struct from a haptic_effect.
+ * Values above 32767 (for unsigned) are unspecified so we must clamp.
+ */
+static int
+SDL_SYS_ToFFEffect( struct ff_effect * dest, SDL_HapticEffect * src )
+{
+   Uint32 tmp;
+   SDL_HapticConstant *constant;
+   SDL_HapticPeriodic *periodic;
+   SDL_HapticCondition *condition;
+   SDL_HapticRamp *ramp;
+
+   /* Clear up */
+   SDL_memset(dest, 0, sizeof(struct ff_effect));
+
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         constant = &src->constant;
+
+         /* Header */
+         dest->type = FF_CONSTANT;
+         dest->direction = SDL_SYS_ToDirection(&constant->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
+               0 : CLAMP(constant->length);
+         dest->replay.delay = CLAMP(constant->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(constant->button);
+         dest->trigger.interval = CLAMP(constant->interval);
+
+         /* Constant */
+         dest->u.constant.level = constant->level;
+
+         /* Envelope */
+         dest->u.constant.envelope.attack_length = CLAMP(constant->attack_length);
+         dest->u.constant.envelope.attack_level = CLAMP(constant->attack_level);
+         dest->u.constant.envelope.fade_length = CLAMP(constant->fade_length);
+         dest->u.constant.envelope.fade_level = CLAMP(constant->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         periodic = &src->periodic;
+
+         /* Header */
+         dest->type = FF_PERIODIC;
+         dest->direction = SDL_SYS_ToDirection(&periodic->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+         
+         /* Replay */
+         dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(periodic->length);
+         dest->replay.delay = CLAMP(periodic->delay);
+         
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(periodic->button);
+         dest->trigger.interval = CLAMP(periodic->interval);
+         
+         /* Periodic */
+         if (periodic->type == SDL_HAPTIC_SINE)
+            dest->u.periodic.waveform = FF_SINE;
+         else if (periodic->type == SDL_HAPTIC_SQUARE)
+            dest->u.periodic.waveform = FF_SQUARE;
+         else if (periodic->type == SDL_HAPTIC_TRIANGLE)       
+            dest->u.periodic.waveform = FF_TRIANGLE;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)       
+            dest->u.periodic.waveform = FF_SAW_UP;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)       
+            dest->u.periodic.waveform = FF_SAW_DOWN;
+         dest->u.periodic.period = CLAMP(periodic->period);
+         dest->u.periodic.magnitude = periodic->magnitude;
+         dest->u.periodic.offset = periodic->offset;
+         /* Phase is calculated based of offset from period and then clamped. */
+         tmp = ((periodic->phase % 36000) * dest->u.periodic.period) / 36000;
+         dest->u.periodic.phase = CLAMP(tmp);
+         
+         /* Envelope */
+         dest->u.periodic.envelope.attack_length = CLAMP(periodic->attack_length);
+         dest->u.periodic.envelope.attack_level = CLAMP(periodic->attack_level);
+         dest->u.periodic.envelope.fade_length = CLAMP(periodic->fade_length);
+         dest->u.periodic.envelope.fade_level = CLAMP(periodic->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         condition = &src->condition;
+
+         /* Header */
+         if (condition->type == SDL_HAPTIC_SPRING)
+            dest->type = FF_SPRING;
+         else if (condition->type == SDL_HAPTIC_DAMPER)
+            dest->type = FF_DAMPER;
+         else if (condition->type == SDL_HAPTIC_INERTIA)
+            dest->type = FF_INERTIA;
+         else if (condition->type == SDL_HAPTIC_FRICTION)
+            dest->type = FF_FRICTION;
+         dest->direction = 0; /* Handled by the condition-specifics. */
+
+         /* Replay */
+         dest->replay.length = (condition->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(condition->length);
+         dest->replay.delay = CLAMP(condition->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(condition->button);
+         dest->trigger.interval = CLAMP(condition->interval);
+
+         /* Condition */
+         /* X axis */
+         dest->u.condition[0].right_saturation = CLAMP(condition->right_sat[0]);
+         dest->u.condition[0].left_saturation = CLAMP(condition->left_sat[0]);
+         dest->u.condition[0].right_coeff = condition->right_coeff[0];
+         dest->u.condition[0].left_coeff = condition->left_coeff[0];
+         dest->u.condition[0].deadband = CLAMP(condition->deadband[0]);
+         dest->u.condition[0].center = condition->center[0];
+         /* Y axis */
+         dest->u.condition[1].right_saturation = CLAMP(condition->right_sat[1]);
+         dest->u.condition[1].left_saturation = CLAMP(condition->left_sat[1]);
+         dest->u.condition[1].right_coeff = condition->right_coeff[1];
+         dest->u.condition[1].left_coeff = condition->left_coeff[1];  
+         dest->u.condition[1].deadband = CLAMP(condition->deadband[1]);
+         dest->u.condition[1].center = condition->center[1];
+
+         /*
+          * There is no envelope in the linux force feedback api for conditions.
+          */
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         ramp = &src->ramp;
+
+         /* Header */
+         dest->type = FF_RAMP;
+         dest->direction = SDL_SYS_ToDirection(&ramp->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(ramp->length);
+         dest->replay.delay = CLAMP(ramp->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(ramp->button);
+         dest->trigger.interval = CLAMP(ramp->interval);
+
+         /* Ramp */
+         dest->u.ramp.start_level = ramp->start;
+         dest->u.ramp.end_level = ramp->end;
+
+         /* Envelope */
+         dest->u.ramp.envelope.attack_length = CLAMP(ramp->attack_length);
+         dest->u.ramp.envelope.attack_level = CLAMP(ramp->attack_level);
+         dest->u.ramp.envelope.fade_length = CLAMP(ramp->fade_length);
+         dest->u.ramp.envelope.fade_level = CLAMP(ramp->fade_level);
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   struct ff_effect * linux_effect;
+
+   /* Allocate the hardware effect */
+   effect->hweffect = (struct haptic_hweffect *) 
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+
+   /* Prepare the ff_effect */
+   linux_effect = &effect->hweffect->effect;
+   if (SDL_SYS_ToFFEffect( linux_effect, base ) != 0) {
+      goto new_effect_err;
+   }
+   linux_effect->id = -1; /* Have the kernel give it an id */
+
+   /* Upload the effect */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, linux_effect) < 0) {
+      SDL_SetError("Haptic: Error uploading effect to the device: %s", strerror(errno));
+      goto new_effect_err;
+   }
+
+   return 0;
+
+new_effect_err:
+   free(effect->hweffect);
+   effect->hweffect = NULL;
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ *
+ * Note: Dynamically updating the direction can in some cases force
+ * the effect to restart and run once.
+ */
+int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   struct ff_effect linux_effect;
+
+   /* Create the new effect */
+   if (SDL_SYS_ToFFEffect( &linux_effect, data ) != 0) {
+      return -1;
+   }
+   linux_effect.id = effect->hweffect->effect.id;
+
+   /* See if it can be uploaded. */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, &linux_effect) < 0) {
+      SDL_SetError("Haptic: Error updating the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Copy the new effect into memory. */
+   SDL_memcpy( &effect->hweffect->effect, &linux_effect, sizeof(struct ff_effect) );
+
+   return effect->hweffect->effect.id;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   struct input_event run;
+
+   /* Prepare to run the effect */
+   run.type = EV_FF;
+   run.code = effect->hweffect->effect.id;
+   /* We don't actually have infinity here, so we just do INT_MAX which is pretty damn close. */
+   run.value = (iterations > INT_MAX) ? INT_MAX : iterations;
+
+   if (write(haptic->hwdata->fd, (const void*) &run, sizeof(run)) < 0) {
+      SDL_SetError("Haptic: Unable to run the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   struct input_event stop;
+
+   stop.type = EV_FF;
+   stop.code = effect->hweffect->effect.id;
+   stop.value = 0;
+
+   if (write(haptic->hwdata->fd, (const void*) &stop, sizeof(stop)) < 0) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   if (ioctl(haptic->hwdata->fd, EVIOCRMFF, effect->hweffect->effect.id) < 0) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s",
+            strerror(errno));
+   }
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+#if 0  /* Not supported atm. */
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.type = EV_FF_STATUS;
+   ie.code = effect->hweffect->effect.id;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error getting device status.");
+      return -1;
+   }
+
+   return 0;
+#endif
+
+   return -1;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_GAIN;
+   ie.value = (0xFFFFUL * gain) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting gain: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_AUTOCENTER;
+   ie.value = (0xFFFFUL * autocenter) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting autocenter: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Pausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Unpausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   int i, ret;
+
+   /* Linux does not support this natively so we have to loop. */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect != NULL) {
+         ret = SDL_SYS_HapticStopEffect(haptic, &haptic->effects[i]);
+         if (ret < 0) {
+            SDL_SetError("Haptic: Error while trying to stop all playing effects.");
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_LINUX */
\ No newline at end of file
diff -ruN SDL-1.2.13/src/linux/SDL_syshaptic.c.bak SDL-1.2.13_OOx64/src/linux/SDL_syshaptic.c.bak
--- SDL-1.2.13/src/linux/SDL_syshaptic.c.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/linux/SDL_syshaptic.c.bak	2017-12-18 13:30:26 +0000
@@ -0,0 +1,961 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 2008 Edgar Simo
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_HAPTIC_LINUX
+
+#include "SDL_haptic.h"
+#include "../SDL_syshaptic.h"
+#include "SDL_joystick.h"
+#include "../../joystick/SDL_sysjoystick.h" /* For the real SDL_Joystick */
+#include "../../joystick/linux/SDL_sysjoystick_c.h" /* For joystick hwdata */ 
+
+#include <unistd.h> /* close */
+#include <linux/input.h> /* Force feedback linux stuff. */
+#include <fcntl.h> /* O_RDWR */
+#include <limits.h> /* INT_MAX */
+#include <errno.h> /* errno, strerror */
+#include <math.h> /* atan2 */
+#include <sys/stat.h> /* stat */
+
+/* Just in case. */
+#ifndef M_PI
+#  define M_PI     3.14159265358979323846
+#endif
+
+
+#define MAX_HAPTICS  32 /* It's doubtful someone has more then 32 evdev */
+
+
+/*
+ * List of available haptic devices.
+ */
+static struct
+{
+   char *fname; /* Dev path name (like /dev/input/event1) */
+   SDL_Haptic *haptic; /* Assosciated haptic. */
+} SDL_hapticlist[MAX_HAPTICS];
+
+
+/*
+ * Haptic system hardware data.
+ */
+struct haptic_hwdata
+{
+   int fd; /* File descriptor of the device. */
+   char *fname; /* Points to the name in SDL_hapticlist. */
+};
+
+
+/*
+ * Haptic system effect data.
+ */
+struct haptic_hweffect
+{
+   struct ff_effect effect; /* The linux kernel effect structure. */
+};
+
+
+
+#define test_bit(nr, addr) \
+   (((1UL << ((nr) & 31)) & (((const unsigned int *) addr)[(nr) >> 5])) != 0)
+#define EV_TEST(ev,f) \
+   if (test_bit((ev), features)) ret |= (f);
+/*
+ * Test whether a device has haptic properties.
+ * Returns available properties or 0 if there are none.
+ */
+static int
+EV_IsHaptic(int fd)
+{
+   unsigned int ret;
+   unsigned long features[1 + FF_MAX/sizeof(unsigned long)];
+
+   /* Ask device for what it has. */
+   ret = 0;
+   if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(features)), features) < 0) {
+      SDL_SetError("Haptic: Unable to get device's features: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Convert supported features to SDL_HAPTIC platform-neutral features. */
+   EV_TEST(FF_CONSTANT,   SDL_HAPTIC_CONSTANT);
+   EV_TEST(FF_SINE,       SDL_HAPTIC_SINE);
+   EV_TEST(FF_SQUARE,     SDL_HAPTIC_SQUARE);
+   EV_TEST(FF_TRIANGLE,   SDL_HAPTIC_TRIANGLE);
+   EV_TEST(FF_SAW_UP,     SDL_HAPTIC_SAWTOOTHUP);
+   EV_TEST(FF_SAW_DOWN,   SDL_HAPTIC_SAWTOOTHDOWN);
+   EV_TEST(FF_RAMP,       SDL_HAPTIC_RAMP);
+   EV_TEST(FF_SPRING,     SDL_HAPTIC_SPRING);
+   EV_TEST(FF_FRICTION,   SDL_HAPTIC_FRICTION);
+   EV_TEST(FF_DAMPER,     SDL_HAPTIC_DAMPER);
+   EV_TEST(FF_INERTIA,    SDL_HAPTIC_INERTIA);
+   EV_TEST(FF_CUSTOM,     SDL_HAPTIC_CUSTOM);
+   EV_TEST(FF_GAIN,       SDL_HAPTIC_GAIN);
+   EV_TEST(FF_AUTOCENTER, SDL_HAPTIC_AUTOCENTER);
+
+   /* Return what it supports. */
+   return ret;
+}
+
+
+/*
+ * Tests whether a device is a mouse or not.
+ */
+static int
+EV_IsMouse(int fd)
+{
+   unsigned long argp[40];
+
+   /* Ask for supported features. */
+   if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(argp)), argp) < 0) {
+      return -1;
+   }
+
+   /* Currently we only test for BTN_MOUSE which can give fake positives. */
+   if (test_bit(BTN_MOUSE,argp) != 0) {
+      return 1;
+   }
+
+   return 0;
+}
+
+/*
+ * Initializes the haptic subsystem by finding available devices.
+ */
+int
+SDL_SYS_HapticInit(void)
+{
+   const char joydev_pattern[] = "/dev/input/event%d";
+   dev_t dev_nums[MAX_HAPTICS];
+   char path[PATH_MAX];
+   struct stat sb;
+   int fd;
+   int i, j, k;
+   int duplicate;
+   int numhaptics;
+
+   numhaptics = 0;
+
+   /* 
+    * Limit amount of checks to MAX_HAPTICS since we may or may not have
+    * permission to some or all devices.
+    */
+   i = 0;
+   for (j = 0; j < MAX_HAPTICS; ++j) {
+
+      snprintf(path, PATH_MAX, joydev_pattern, i++);
+
+      /* check to see if file exists */
+      if (stat(path,&sb) != 0)
+         break;
+
+      /* check for duplicates */
+      duplicate = 0;
+      for (k = 0; (k < numhaptics) && !duplicate; ++k) {
+         if (sb.st_rdev == dev_nums[k]) {
+            duplicate = 1;
+         }                                                     
+      }                                                         
+      if (duplicate) {
+         continue;
+      }
+
+      /* try to open */
+      fd = open(path, O_RDWR, 0);
+      if (fd < 0) continue;
+
+#ifdef DEBUG_INPUT_EVENTS
+      printf("Checking %s\n", path);
+#endif          
+
+      /* see if it works */
+      if (EV_IsHaptic(fd) > 0) {
+         SDL_hapticlist[numhaptics].fname = SDL_strdup(path);
+         SDL_hapticlist[numhaptics].haptic = NULL;
+         dev_nums[numhaptics] = sb.st_rdev;
+         ++numhaptics;
+      }
+      close(fd);
+   }
+
+   return numhaptics;
+}
+
+
+/*
+ * Gets the name from a file descriptor.
+ */
+static const char *
+SDL_SYS_HapticNameFromFD(int fd)
+{
+   static char namebuf[128];
+
+   /* We use the evdev name ioctl. */
+   if (ioctl(fd, EVIOCGNAME(sizeof(namebuf)), namebuf) <= 0) {
+      return NULL;
+   }
+
+   return namebuf;
+}
+
+
+/*
+ * Return the name of a haptic device, does not need to be opened.
+ */
+const char *
+SDL_SYS_HapticName(int index)
+{
+   int fd;
+   const char *name;
+
+   /* Open the haptic device. */
+   name = NULL;
+   fd = open(SDL_hapticlist[index].fname, O_RDONLY, 0);
+
+   if (fd >= 0) {
+
+      name = SDL_SYS_HapticNameFromFD(fd);
+      if (name==NULL) {
+         /* No name found, return device character device */
+         name = SDL_hapticlist[index].fname;
+      }
+   }
+   close(fd);
+
+   return name;
+}
+
+
+/*
+ * Opens the haptic device from the file descriptor.
+ */
+static int
+SDL_SYS_HapticOpenFromFD(SDL_Haptic * haptic, int fd)
+{
+   const char *name;
+
+   /* Allocate the hwdata */
+   haptic->hwdata = (struct haptic_hwdata *)
+         SDL_malloc(sizeof(*haptic->hwdata));
+   if (haptic->hwdata == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   SDL_memset(haptic->hwdata, 0, sizeof(*haptic->hwdata));
+
+   /* Set the data. */
+   haptic->hwdata->fd = fd;
+   haptic->supported = EV_IsHaptic(fd);
+   haptic->naxes = 2; /* Hardcoded for now, not sure if it's possible to find out. */
+
+   /* Set the effects */
+   if (ioctl(fd, EVIOCGEFFECTS, &haptic->neffects) < 0) {
+      SDL_SetError("Haptic: Unable to query device memory: %s", strerror(errno));
+      goto open_err;
+   }
+   haptic->nplaying = haptic->neffects; /* Linux makes no distinction. */
+   haptic->effects = (struct haptic_effect *)
+         SDL_malloc(sizeof(struct haptic_effect) * haptic->neffects);
+   if (haptic->effects == NULL) {
+      SDL_OutOfMemory();
+      goto open_err;
+   }
+   /* Clear the memory */
+   SDL_memset(haptic->effects, 0,
+         sizeof(struct haptic_effect) * haptic->neffects);
+
+   return 0;
+
+   /* Error handling */
+open_err:
+   close(fd);
+   if (haptic->hwdata != NULL) {
+      free(haptic->hwdata);
+      haptic->hwdata = NULL;
+   }
+   return -1;
+}
+
+
+/*
+ * Opens a haptic device for usage.
+ */
+int
+SDL_SYS_HapticOpen(SDL_Haptic * haptic)
+{
+   int fd;
+   int ret;
+
+   /* Open the character device */
+   fd = open(SDL_hapticlist[haptic->index].fname, O_RDWR, 0);
+   if (fd < 0) {
+      SDL_SetError("Haptic: Unable to open %s: %s",
+            SDL_hapticlist[haptic->index], strerror(errno));
+      return -1;
+   }
+
+   /* Try to create the haptic. */
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   /* Set the fname. */
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Opens a haptic device from first mouse it finds for usage.
+ */
+int
+SDL_SYS_HapticMouse(void)
+{
+   int fd;
+   int i;
+
+   for (i=0; i<SDL_numhaptics; i++) {
+
+      /* Open the device. */
+      fd = open(SDL_hapticlist[i].fname, O_RDWR, 0);
+      if (fd < 0) {
+         SDL_SetError("Haptic: Unable to open %s: %s",
+               SDL_hapticlist[i], strerror(errno));
+         return -1;
+      }
+
+      /* Is it a mouse? */
+      if (EV_IsMouse(fd)) {
+         close(fd);
+         return i;
+      }
+
+      close(fd);
+   }
+   
+   return -1;
+}
+
+
+/*
+ * Checks to see if a joystick has haptic features.
+ */
+int
+SDL_SYS_JoystickIsHaptic(SDL_Joystick * joystick)
+{
+   return EV_IsHaptic(joystick->hwdata->fd);
+}
+
+
+/*
+ * Checks to see if the haptic device and joystick and in reality the same.
+ */
+int
+SDL_SYS_JoystickSameHaptic(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   /* We are assuming linux is using evdev which should trump the old
+    * joystick methods. */
+   if (SDL_strcmp(joystick->hwdata->fname,haptic->hwdata->fname)==0) {
+      return 1;
+   }
+   return 0;
+}
+
+
+/*
+ * Opens a SDL_Haptic from a SDL_Joystick.
+ */
+int
+SDL_SYS_HapticOpenFromJoystick(SDL_Haptic * haptic, SDL_Joystick * joystick)
+{
+   int i;
+   int fd;
+   int ret;
+
+   /* Find the joystick in the haptic list. */
+   for (i=0; i<MAX_HAPTICS; i++) {
+      if (SDL_hapticlist[i].fname != NULL) {
+         if (SDL_strcmp(SDL_hapticlist[i].fname, joystick->hwdata->fname)==0) {
+            haptic->index = i;
+         }
+      }
+   }
+
+   fd = open(joystick->hwdata->fname, O_RDWR, 0);
+   ret =  SDL_SYS_HapticOpenFromFD(haptic,fd); /* Already closes on error. */
+   if (ret < 0) {
+      return -1;
+   }
+
+   haptic->hwdata->fname = SDL_hapticlist[haptic->index].fname;
+   return 0;
+}
+
+
+/*
+ * Closes the haptic device.
+ */
+void
+SDL_SYS_HapticClose(SDL_Haptic * haptic)
+{
+   if (haptic->hwdata) {
+
+      /* Free effects. */
+      SDL_free(haptic->effects);
+      haptic->effects = NULL;
+      haptic->neffects = 0;
+
+      /* Clean up */
+      close(haptic->hwdata->fd);
+
+      /* Free */
+      SDL_free(haptic->hwdata);                                           
+      haptic->hwdata = NULL;  
+   }
+
+   /* Clear the rest. */
+   SDL_memset(haptic, 0, sizeof(SDL_Haptic));
+}
+
+
+/* 
+ * Clean up after system specific haptic stuff
+ */
+void
+SDL_SYS_HapticQuit(void)
+{
+   int i;
+
+   for (i=0; SDL_hapticlist[i].fname != NULL; i++) {
+      /* Opened and not closed haptics are leaked, this is on purpose.
+       * Close your haptic devices after usage. */
+
+      SDL_free(SDL_hapticlist[i].fname);
+   }
+   SDL_hapticlist[0].fname = NULL;
+}
+
+
+/*
+ * Converts an SDL button to a ff_trigger button.
+ */
+static Uint16
+SDL_SYS_ToButton( Uint16 button )
+{
+   Uint16 ff_button;
+
+   ff_button = 0;
+
+   /*
+    * Not sure what the proper syntax is because this actually isn't implemented
+    * in the current kernel from what I've seen (2.6.26).
+    */
+   if (button != 0) {
+      ff_button = BTN_GAMEPAD + button - 1;
+   }
+
+   return ff_button;
+}
+
+
+/*
+ * Returns the ff_effect usable direction from a SDL_HapticDirection.
+ */
+static Uint16
+SDL_SYS_ToDirection( SDL_HapticDirection * dir )
+{
+   Uint32 tmp;
+   float f; /* Ideally we'd use fixed point math instead of floats... */
+
+   switch (dir->type) {
+      case SDL_HAPTIC_POLAR:
+         /* Linux directions start from south.
+         		(and range from 0 to 0xFFFF)
+	 			   Quoting include/linux/input.h, line 926:
+	 			   Direction of the effect is encoded as follows:
+	 					0 deg -> 0x0000 (down)
+	 					90 deg -> 0x4000 (left)
+	 					180 deg -> 0x8000 (up)
+	 					270 deg -> 0xC000 (right)
+	 				*/
+         tmp = (((18000 + dir->dir[0]) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_CARTESIAN:
+         f = atan2(dir->dir[1], dir->dir[0]);
+		 /* 
+		   atan2 takes the parameters: Y-axis-value and X-axis-value (in that order)
+		    - Y-axis-value is the second coordinate (from center to SOUTH)
+		    - X-axis-value is the first coordinate (from center to EAST)
+		   	 We add 36000, because atan2 also returns negative values. Then we practically
+			 have the first spherical value. Therefore we proceed as in case
+			 SDL_HAPTIC_SPHERICAL and add another 9000 to get the polar value.
+		   --> add 45000 in total
+		   --> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+		 tmp = (((int) (f * 18000. / M_PI)) + 45000) % 36000;
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      case SDL_HAPTIC_SPHERICAL:
+		 /*
+			We convert to polar, because that's the only supported direction on Linux.
+			The first value of a spherical direction is practically the same as a
+			Polar direction, except that we have to add 90 degrees. It is the angle
+			from EAST {1,0} towards SOUTH {0,1}.
+			--> add 9000
+			--> finally add 18000 and convert to [0,0xFFFF] as in case SDL_HAPTIC_POLAR.
+		 */
+         tmp = ((dir->dir[0]) + 9000) % 36000;    /* Convert to polars */
+         tmp = (((18000 + tmp) % 36000) * 0xFFFF) / 36000; // convert to range [0,0xFFFF]
+         return (Uint16) tmp;
+
+      default:
+         SDL_SetError("Haptic: Unsupported direction type.");
+         return (Uint16)-1;
+   }
+
+   return 0;
+}
+
+
+#define  CLAMP(x)    (((x) > 32767) ? 32767 : x)
+/*
+ * Initializes the linux effect struct from a haptic_effect.
+ * Values above 32767 (for unsigned) are unspecified so we must clamp.
+ */
+static int
+SDL_SYS_ToFFEffect( struct ff_effect * dest, SDL_HapticEffect * src )
+{
+   Uint32 tmp;
+   SDL_HapticConstant *constant;
+   SDL_HapticPeriodic *periodic;
+   SDL_HapticCondition *condition;
+   SDL_HapticRamp *ramp;
+
+   /* Clear up */
+   SDL_memset(dest, 0, sizeof(struct ff_effect));
+
+   switch (src->type) {
+      case SDL_HAPTIC_CONSTANT:
+         constant = &src->constant;
+
+         /* Header */
+         dest->type = FF_CONSTANT;
+         dest->direction = SDL_SYS_ToDirection(&constant->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (constant->length == SDL_HAPTIC_INFINITY) ?
+               0 : CLAMP(constant->length);
+         dest->replay.delay = CLAMP(constant->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(constant->button);
+         dest->trigger.interval = CLAMP(constant->interval);
+
+         /* Constant */
+         dest->u.constant.level = constant->level;
+
+         /* Envelope */
+         dest->u.constant.envelope.attack_length = CLAMP(constant->attack_length);
+         dest->u.constant.envelope.attack_level = CLAMP(constant->attack_level);
+         dest->u.constant.envelope.fade_length = CLAMP(constant->fade_length);
+         dest->u.constant.envelope.fade_level = CLAMP(constant->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SINE:
+      case SDL_HAPTIC_SQUARE:
+      case SDL_HAPTIC_TRIANGLE:
+      case SDL_HAPTIC_SAWTOOTHUP:
+      case SDL_HAPTIC_SAWTOOTHDOWN:
+         periodic = &src->periodic;
+
+         /* Header */
+         dest->type = FF_PERIODIC;
+         dest->direction = SDL_SYS_ToDirection(&periodic->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+         
+         /* Replay */
+         dest->replay.length = (periodic->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(periodic->length);
+         dest->replay.delay = CLAMP(periodic->delay);
+         
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(periodic->button);
+         dest->trigger.interval = CLAMP(periodic->interval);
+         
+         /* Periodic */
+         if (periodic->type == SDL_HAPTIC_SINE)
+            dest->u.periodic.waveform = FF_SINE;
+         else if (periodic->type == SDL_HAPTIC_SQUARE)
+            dest->u.periodic.waveform = FF_SQUARE;
+         else if (periodic->type == SDL_HAPTIC_TRIANGLE)       
+            dest->u.periodic.waveform = FF_TRIANGLE;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHUP)       
+            dest->u.periodic.waveform = FF_SAW_UP;
+         else if (periodic->type == SDL_HAPTIC_SAWTOOTHDOWN)       
+            dest->u.periodic.waveform = FF_SAW_DOWN;
+         dest->u.periodic.period = CLAMP(periodic->period);
+         dest->u.periodic.magnitude = periodic->magnitude;
+         dest->u.periodic.offset = periodic->offset;
+         /* Phase is calculated based of offset from period and then clamped. */
+         tmp = ((periodic->phase % 36000) * dest->u.periodic.period) / 36000;
+         dest->u.periodic.phase = CLAMP(tmp);
+         
+         /* Envelope */
+         dest->u.periodic.envelope.attack_length = CLAMP(periodic->attack_length);
+         dest->u.periodic.envelope.attack_level = CLAMP(periodic->attack_level);
+         dest->u.periodic.envelope.fade_length = CLAMP(periodic->fade_length);
+         dest->u.periodic.envelope.fade_level = CLAMP(periodic->fade_level);
+
+         break;
+
+      case SDL_HAPTIC_SPRING:
+      case SDL_HAPTIC_DAMPER:
+      case SDL_HAPTIC_INERTIA:
+      case SDL_HAPTIC_FRICTION:
+         condition = &src->condition;
+
+         /* Header */
+         if (condition->type == SDL_HAPTIC_SPRING)
+            dest->type = FF_SPRING;
+         else if (condition->type == SDL_HAPTIC_DAMPER)
+            dest->type = FF_DAMPER;
+         else if (condition->type == SDL_HAPTIC_INERTIA)
+            dest->type = FF_INERTIA;
+         else if (condition->type == SDL_HAPTIC_FRICTION)
+            dest->type = FF_FRICTION;
+         dest->direction = 0; /* Handled by the condition-specifics. */
+
+         /* Replay */
+         dest->replay.length = (condition->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(condition->length);
+         dest->replay.delay = CLAMP(condition->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(condition->button);
+         dest->trigger.interval = CLAMP(condition->interval);
+
+         /* Condition */
+         /* X axis */
+         dest->u.condition[0].right_saturation = CLAMP(condition->right_sat[0]);
+         dest->u.condition[0].left_saturation = CLAMP(condition->left_sat[0]);
+         dest->u.condition[0].right_coeff = condition->right_coeff[0];
+         dest->u.condition[0].left_coeff = condition->left_coeff[0];
+         dest->u.condition[0].deadband = CLAMP(condition->deadband[0]);
+         dest->u.condition[0].center = condition->center[0];
+         /* Y axis */
+         dest->u.condition[1].right_saturation = CLAMP(condition->right_sat[1]);
+         dest->u.condition[1].left_saturation = CLAMP(condition->left_sat[1]);
+         dest->u.condition[1].right_coeff = condition->right_coeff[1];
+         dest->u.condition[1].left_coeff = condition->left_coeff[1];  
+         dest->u.condition[1].deadband = CLAMP(condition->deadband[1]);
+         dest->u.condition[1].center = condition->center[1];
+
+         /*
+          * There is no envelope in the linux force feedback api for conditions.
+          */
+
+         break;
+
+      case SDL_HAPTIC_RAMP:
+         ramp = &src->ramp;
+
+         /* Header */
+         dest->type = FF_RAMP;
+         dest->direction = SDL_SYS_ToDirection(&ramp->direction);
+         if (dest->direction == (Uint16)-1) return -1;
+
+         /* Replay */
+         dest->replay.length = (ramp->length == SDL_HAPTIC_INFINITY) ? 
+               0 : CLAMP(ramp->length);
+         dest->replay.delay = CLAMP(ramp->delay);
+
+         /* Trigger */
+         dest->trigger.button = SDL_SYS_ToButton(ramp->button);
+         dest->trigger.interval = CLAMP(ramp->interval);
+
+         /* Ramp */
+         dest->u.ramp.start_level = ramp->start;
+         dest->u.ramp.end_level = ramp->end;
+
+         /* Envelope */
+         dest->u.ramp.envelope.attack_length = CLAMP(ramp->attack_length);
+         dest->u.ramp.envelope.attack_level = CLAMP(ramp->attack_level);
+         dest->u.ramp.envelope.fade_length = CLAMP(ramp->fade_length);
+         dest->u.ramp.envelope.fade_level = CLAMP(ramp->fade_level);
+
+         break;
+
+
+      default:
+         SDL_SetError("Haptic: Unknown effect type.");
+         return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Creates a new haptic effect.
+ */
+int
+SDL_SYS_HapticNewEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+      SDL_HapticEffect * base)
+{
+   struct ff_effect * linux_effect;
+
+   /* Allocate the hardware effect */
+   effect->hweffect = (struct haptic_hweffect *) 
+         SDL_malloc(sizeof(struct haptic_hweffect));
+   if (effect->hweffect == NULL) {
+      SDL_OutOfMemory();
+      return -1;
+   }
+
+   /* Prepare the ff_effect */
+   linux_effect = &effect->hweffect->effect;
+   if (SDL_SYS_ToFFEffect( linux_effect, base ) != 0) {
+      goto new_effect_err;
+   }
+   linux_effect->id = -1; /* Have the kernel give it an id */
+
+   /* Upload the effect */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, linux_effect) < 0) {
+      SDL_SetError("Haptic: Error uploading effect to the device: %s", strerror(errno));
+      goto new_effect_err;
+   }
+
+   return 0;
+
+new_effect_err:
+   free(effect->hweffect);
+   effect->hweffect = NULL;
+   return -1;
+}
+
+
+/*
+ * Updates an effect.
+ *
+ * Note: Dynamically updating the direction can in some cases force
+ * the effect to restart and run once.
+ */
+int SDL_SYS_HapticUpdateEffect(SDL_Haptic * haptic,
+      struct haptic_effect * effect, SDL_HapticEffect * data)
+{
+   struct ff_effect linux_effect;
+
+   /* Create the new effect */
+   if (SDL_SYS_ToFFEffect( &linux_effect, data ) != 0) {
+      return -1;
+   }
+   linux_effect.id = effect->hweffect->effect.id;
+
+   /* See if it can be uploaded. */
+   if (ioctl(haptic->hwdata->fd, EVIOCSFF, &linux_effect) < 0) {
+      SDL_SetError("Haptic: Error updating the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   /* Copy the new effect into memory. */
+   SDL_memcpy( &effect->hweffect->effect, &linux_effect, sizeof(struct ff_effect) );
+
+   return effect->hweffect->effect.id;
+}
+
+
+/*
+ * Runs an effect.
+ */
+int
+SDL_SYS_HapticRunEffect(SDL_Haptic * haptic, struct haptic_effect * effect,
+                        Uint32 iterations)
+{
+   struct input_event run;
+
+   /* Prepare to run the effect */
+   run.type = EV_FF;
+   run.code = effect->hweffect->effect.id;
+   /* We don't actually have infinity here, so we just do INT_MAX which is pretty damn close. */
+   run.value = (iterations > INT_MAX) ? INT_MAX : iterations;
+
+   if (write(haptic->hwdata->fd, (const void*) &run, sizeof(run)) < 0) {
+      SDL_SetError("Haptic: Unable to run the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Stops an effect.
+ */
+int
+SDL_SYS_HapticStopEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   struct input_event stop;
+
+   stop.type = EV_FF;
+   stop.code = effect->hweffect->effect.id;
+   stop.value = 0;
+
+   if (write(haptic->hwdata->fd, (const void*) &stop, sizeof(stop)) < 0) {
+      SDL_SetError("Haptic: Unable to stop the effect: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Frees the effect.
+ */
+void
+SDL_SYS_HapticDestroyEffect(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+   if (ioctl(haptic->hwdata->fd, EVIOCRMFF, effect->hweffect->effect.id) < 0) {
+      SDL_SetError("Haptic: Error removing the effect from the device: %s",
+            strerror(errno));
+   }
+   SDL_free(effect->hweffect);
+   effect->hweffect = NULL;
+}
+
+
+/*
+ * Gets the status of a haptic effect.
+ */
+int
+SDL_SYS_HapticGetEffectStatus(SDL_Haptic * haptic, struct haptic_effect * effect)
+{
+#if 0  /* Not supported atm. */
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.type = EV_FF_STATUS;
+   ie.code = effect->hweffect->effect.id;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error getting device status.");
+      return -1;
+   }
+
+   return 0;
+#endif
+
+   return -1;
+}
+
+
+/*
+ * Sets the gain.
+ */
+int
+SDL_SYS_HapticSetGain(SDL_Haptic * haptic, int gain)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_GAIN;
+   ie.value = (0xFFFFUL * gain) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting gain: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Sets the autocentering.
+ */
+int
+SDL_SYS_HapticSetAutocenter(SDL_Haptic * haptic, int autocenter)
+{
+   struct input_event ie;
+
+   ie.type = EV_FF;
+   ie.code = FF_AUTOCENTER;
+   ie.value = (0xFFFFUL * autocenter) / 100;
+
+   if (write(haptic->hwdata->fd, &ie, sizeof(ie)) < 0) {
+      SDL_SetError("Haptic: Error setting autocenter: %s", strerror(errno));
+      return -1;
+   }
+
+   return 0;
+}
+
+
+/*
+ * Pausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticPause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Unpausing is not supported atm by linux.
+ */
+int
+SDL_SYS_HapticUnpause(SDL_Haptic * haptic)
+{
+   return -1;
+}
+
+
+/*
+ * Stops all the currently playing effects.
+ */
+int
+SDL_SYS_HapticStopAll(SDL_Haptic * haptic)
+{
+   int i, ret;
+
+   /* Linux does not support this natively so we have to loop. */
+   for (i=0; i<haptic->neffects; i++) {
+      if (haptic->effects[i].hweffect != NULL) {
+         ret = SDL_SYS_HapticStopEffect(haptic, &haptic->effects[i]);
+         if (ret < 0) {
+            SDL_SetError("Haptic: Error while trying to stop all playing effects.");
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+
+#endif /* SDL_HAPTIC_LINUX */
diff -ruN SDL-1.2.13/src/video/wincommon/SDL_sysevents.c SDL-1.2.13_OOx64/src/video/wincommon/SDL_sysevents.c
--- SDL-1.2.13/src/video/wincommon/SDL_sysevents.c	2007-12-31 04:48:02 +0000
+++ SDL-1.2.13_OOx64/src/video/wincommon/SDL_sysevents.c	2018-04-23 16:30:07 +0000
@@ -307,14 +307,14 @@
 			state |= KMOD_RCTRL;
 			kstate[SDLK_RCTRL] = SDL_PRESSED;
 		}
-		if ( keyboard[VK_LMENU] & 0x80) {
+		/*if ( keyboard[VK_LMENU] & 0x80) {
 			state |= KMOD_LALT;
 			kstate[SDLK_LALT] = SDL_PRESSED;
 		}
 		if ( keyboard[VK_RMENU] & 0x80) {
 			state |= KMOD_RALT;
 			kstate[SDLK_RALT] = SDL_PRESSED;
-		}
+		}*/
 		if ( keyboard[VK_NUMLOCK] & 0x01) {
 			state |= KMOD_NUM;
 			kstate[SDLK_NUMLOCK] = SDL_PRESSED;
@@ -557,7 +557,7 @@
 #endif
 				}
 				posted = SDL_PrivateMouseButton(
-							state, button, x, y);
+							state, button, x, y, 0);
 
 				/*
 				 * MSDN says:
@@ -579,7 +579,7 @@
 #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
 		case WM_MOUSEWHEEL: 
 			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
-				int move = (short)HIWORD(wParam);
+				short move = GET_WHEEL_DELTA_WPARAM(wParam);
 				if ( move ) {
 					Uint8 button;
 					if ( move > 0 )
@@ -587,9 +587,9 @@
 					else
 						button = SDL_BUTTON_WHEELDOWN;
 					posted = SDL_PrivateMouseButton(
-						SDL_PRESSED, button, 0, 0);
+						SDL_PRESSED, button, 0, 0, move);
 					posted |= SDL_PrivateMouseButton(
-						SDL_RELEASED, button, 0, 0);
+						SDL_RELEASED, button, 0, 0, move);
 				}
 			}
 			return(0);
diff -ruN SDL-1.2.13/src/video/windib/SDL_dibvideo.c SDL-1.2.13_OOx64/src/video/windib/SDL_dibvideo.c
--- SDL-1.2.13/src/video/windib/SDL_dibvideo.c	2007-12-31 04:48:05 +0000
+++ SDL-1.2.13_OOx64/src/video/windib/SDL_dibvideo.c	2012-04-23 09:26:00 +0000
@@ -764,8 +764,12 @@
 		if ( screen_pal && (flags & (SDL_FULLSCREEN|SDL_HWPALETTE)) ) {
 			grab_palette = TRUE;
 		}
-		/* BitBlt() maps colors for us */
-		video->flags |= SDL_HWPALETTE;
+		
+		if ( screen_pal )
+		{
+			/* BitBlt() maps colors for us */
+			video->flags |= SDL_HWPALETTE;
+		}
 	}
 #ifndef _WIN32_WCE
 	/* Resize the window */
diff -ruN SDL-1.2.13/src/video/windib/SDL_dibvideo.c.original SDL-1.2.13_OOx64/src/video/windib/SDL_dibvideo.c.original
--- SDL-1.2.13/src/video/windib/SDL_dibvideo.c.original	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/src/video/windib/SDL_dibvideo.c.original	2007-12-30 17:48:06 +0000
@@ -0,0 +1,1247 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+/* Not yet in the mingw32 cross-compile headers */
+#ifndef CDS_FULLSCREEN
+#define CDS_FULLSCREEN	4
+#endif
+
+#include "SDL_syswm.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include "SDL_dibvideo.h"
+#include "../wincommon/SDL_syswm_c.h"
+#include "../wincommon/SDL_sysmouse_c.h"
+#include "SDL_dibevents_c.h"
+#include "../wincommon/SDL_wingl_c.h"
+
+#ifdef _WIN32_WCE
+#define NO_GETDIBITS
+#define NO_GAMMA_SUPPORT
+  #if _WIN32_WCE < 420
+    #define NO_CHANGEDISPLAYSETTINGS
+  #else
+    #define ChangeDisplaySettings(lpDevMode, dwFlags) ChangeDisplaySettingsEx(NULL, (lpDevMode), 0, (dwFlags), 0)
+  #endif
+#endif
+#ifndef WS_MAXIMIZE
+#define WS_MAXIMIZE	0
+#endif
+#ifndef WS_THICKFRAME
+#define WS_THICKFRAME	0
+#endif
+#ifndef SWP_NOCOPYBITS
+#define SWP_NOCOPYBITS	0
+#endif
+#ifndef PC_NOCOLLAPSE
+#define PC_NOCOLLAPSE	0
+#endif
+
+#ifdef _WIN32_WCE
+// defined and used in SDL_sysevents.c
+extern HINSTANCE aygshell;
+#endif
+
+/* Initialization/Query functions */
+static int DIB_VideoInit(_THIS, SDL_PixelFormat *vformat);
+static SDL_Rect **DIB_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
+SDL_Surface *DIB_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
+static int DIB_SetColors(_THIS, int firstcolor, int ncolors,
+			 SDL_Color *colors);
+static void DIB_CheckGamma(_THIS);
+void DIB_SwapGamma(_THIS);
+void DIB_QuitGamma(_THIS);
+int DIB_SetGammaRamp(_THIS, Uint16 *ramp);
+int DIB_GetGammaRamp(_THIS, Uint16 *ramp);
+static void DIB_VideoQuit(_THIS);
+
+/* Hardware surface functions */
+static int DIB_AllocHWSurface(_THIS, SDL_Surface *surface);
+static int DIB_LockHWSurface(_THIS, SDL_Surface *surface);
+static void DIB_UnlockHWSurface(_THIS, SDL_Surface *surface);
+static void DIB_FreeHWSurface(_THIS, SDL_Surface *surface);
+
+/* Windows message handling functions */
+static void DIB_GrabStaticColors(HWND window);
+static void DIB_ReleaseStaticColors(HWND window);
+static void DIB_Activate(_THIS, BOOL active, BOOL minimized);
+static void DIB_RealizePalette(_THIS);
+static void DIB_PaletteChanged(_THIS, HWND window);
+static void DIB_WinPAINT(_THIS, HDC hdc);
+
+/* helper fn */
+static int DIB_SussScreenDepth();
+
+/* DIB driver bootstrap functions */
+
+static int DIB_Available(void)
+{
+	return(1);
+}
+
+static void DIB_DeleteDevice(SDL_VideoDevice *device)
+{
+	if ( device ) {
+		if ( device->hidden ) {
+			SDL_free(device->hidden);
+		}
+		if ( device->gl_data ) {
+			SDL_free(device->gl_data);
+		}
+		SDL_free(device);
+	}
+}
+
+static SDL_VideoDevice *DIB_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+				SDL_malloc((sizeof *device->hidden));
+		device->gl_data = (struct SDL_PrivateGLData *)
+				SDL_malloc((sizeof *device->gl_data));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ||
+		                 (device->gl_data == NULL) ) {
+		SDL_OutOfMemory();
+		DIB_DeleteDevice(device);
+		return(NULL);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+	SDL_memset(device->gl_data, 0, (sizeof *device->gl_data));
+
+	/* Set the function pointers */
+	device->VideoInit = DIB_VideoInit;
+	device->ListModes = DIB_ListModes;
+	device->SetVideoMode = DIB_SetVideoMode;
+	device->UpdateMouse = WIN_UpdateMouse;
+	device->SetColors = DIB_SetColors;
+	device->UpdateRects = NULL;
+	device->VideoQuit = DIB_VideoQuit;
+	device->AllocHWSurface = DIB_AllocHWSurface;
+	device->CheckHWBlit = NULL;
+	device->FillHWRect = NULL;
+	device->SetHWColorKey = NULL;
+	device->SetHWAlpha = NULL;
+	device->LockHWSurface = DIB_LockHWSurface;
+	device->UnlockHWSurface = DIB_UnlockHWSurface;
+	device->FlipHWSurface = NULL;
+	device->FreeHWSurface = DIB_FreeHWSurface;
+	device->SetGammaRamp = DIB_SetGammaRamp;
+	device->GetGammaRamp = DIB_GetGammaRamp;
+#if SDL_VIDEO_OPENGL
+	device->GL_LoadLibrary = WIN_GL_LoadLibrary;
+	device->GL_GetProcAddress = WIN_GL_GetProcAddress;
+	device->GL_GetAttribute = WIN_GL_GetAttribute;
+	device->GL_MakeCurrent = WIN_GL_MakeCurrent;
+	device->GL_SwapBuffers = WIN_GL_SwapBuffers;
+#endif
+	device->SetCaption = WIN_SetWMCaption;
+	device->SetIcon = WIN_SetWMIcon;
+	device->IconifyWindow = WIN_IconifyWindow;
+	device->GrabInput = WIN_GrabInput;
+	device->GetWMInfo = WIN_GetWMInfo;
+	device->FreeWMCursor = WIN_FreeWMCursor;
+	device->CreateWMCursor = WIN_CreateWMCursor;
+	device->ShowWMCursor = WIN_ShowWMCursor;
+	device->WarpWMCursor = WIN_WarpWMCursor;
+	device->CheckMouseMode = WIN_CheckMouseMode;
+	device->InitOSKeymap = DIB_InitOSKeymap;
+	device->PumpEvents = DIB_PumpEvents;
+
+	/* Set up the windows message handling functions */
+	WIN_Activate = DIB_Activate;
+	WIN_RealizePalette = DIB_RealizePalette;
+	WIN_PaletteChanged = DIB_PaletteChanged;
+	WIN_WinPAINT = DIB_WinPAINT;
+	HandleMessage = DIB_HandleMessage;
+
+	device->free = DIB_DeleteDevice;
+
+	/* We're finally ready */
+	return device;
+}
+
+VideoBootStrap WINDIB_bootstrap = {
+	"windib", "Win95/98/NT/2000/CE GDI",
+	DIB_Available, DIB_CreateDevice
+};
+
+static int cmpmodes(const void *va, const void *vb)
+{
+    SDL_Rect *a = *(SDL_Rect **)va;
+    SDL_Rect *b = *(SDL_Rect **)vb;
+    if ( a->w == b->w )
+        return b->h - a->h;
+    else
+        return b->w - a->w;
+}
+
+static int DIB_AddMode(_THIS, int bpp, int w, int h)
+{
+	SDL_Rect *mode;
+	int i, index;
+	int next_mode;
+
+	/* Check to see if we already have this mode */
+	if ( bpp < 8 || bpp > 32 ) {  /* Not supported */
+		return(0);
+	}
+	index = ((bpp+7)/8)-1;
+	for ( i=0; i<SDL_nummodes[index]; ++i ) {
+		mode = SDL_modelist[index][i];
+		if ( (mode->w == w) && (mode->h == h) ) {
+			return(0);
+		}
+	}
+
+	/* Set up the new video mode rectangle */
+	mode = (SDL_Rect *)SDL_malloc(sizeof *mode);
+	if ( mode == NULL ) {
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	mode->x = 0;
+	mode->y = 0;
+	mode->w = w;
+	mode->h = h;
+
+	/* Allocate the new list of modes, and fill in the new mode */
+	next_mode = SDL_nummodes[index];
+	SDL_modelist[index] = (SDL_Rect **)
+	       SDL_realloc(SDL_modelist[index], (1+next_mode+1)*sizeof(SDL_Rect *));
+	if ( SDL_modelist[index] == NULL ) {
+		SDL_OutOfMemory();
+		SDL_nummodes[index] = 0;
+		SDL_free(mode);
+		return(-1);
+	}
+	SDL_modelist[index][next_mode] = mode;
+	SDL_modelist[index][next_mode+1] = NULL;
+	SDL_nummodes[index]++;
+
+	return(0);
+}
+
+static void DIB_CreatePalette(_THIS, int bpp)
+{
+/*	RJR: March 28, 2000
+	moved palette creation here from "DIB_VideoInit" */
+
+	LOGPALETTE *palette;
+	HDC hdc;
+	int ncolors;
+
+	ncolors = (1 << bpp);
+	palette = (LOGPALETTE *)SDL_malloc(sizeof(*palette)+
+				ncolors*sizeof(PALETTEENTRY));
+	palette->palVersion = 0x300;
+	palette->palNumEntries = ncolors;
+	hdc = GetDC(SDL_Window);
+	GetSystemPaletteEntries(hdc, 0, ncolors, palette->palPalEntry);
+	ReleaseDC(SDL_Window, hdc);
+	screen_pal = CreatePalette(palette);
+	screen_logpal = palette;
+}
+
+int DIB_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	const char *env = NULL;
+#ifndef NO_CHANGEDISPLAYSETTINGS
+	int i;
+	DEVMODE settings;
+#endif
+
+	/* Create the window */
+	if ( DIB_CreateWindow(this) < 0 ) {
+		return(-1);
+	}
+
+#if !SDL_AUDIO_DISABLED
+	DX5_SoundFocus(SDL_Window);
+#endif
+
+	/* Determine the screen depth */
+	vformat->BitsPerPixel = DIB_SussScreenDepth();
+	switch (vformat->BitsPerPixel) {
+		case 15:
+			vformat->Rmask = 0x00007c00;
+			vformat->Gmask = 0x000003e0;
+			vformat->Bmask = 0x0000001f;
+			vformat->BitsPerPixel = 16;
+			break;
+		case 16:
+			vformat->Rmask = 0x0000f800;
+			vformat->Gmask = 0x000007e0;
+			vformat->Bmask = 0x0000001f;
+			break;
+		case 24:
+		case 32:
+			/* GDI defined as 8-8-8 */
+			vformat->Rmask = 0x00ff0000;
+			vformat->Gmask = 0x0000ff00;
+			vformat->Bmask = 0x000000ff;
+			break;
+		default:
+			break;
+	}
+
+	/* See if gamma is supported on this screen */
+	DIB_CheckGamma(this);
+
+#ifndef NO_CHANGEDISPLAYSETTINGS
+
+	settings.dmSize = sizeof(DEVMODE);
+	settings.dmDriverExtra = 0;
+#ifdef _WIN32_WCE
+	settings.dmFields = DM_DISPLAYQUERYORIENTATION;
+	this->hidden->supportRotation = ChangeDisplaySettingsEx(NULL, &settings, NULL, CDS_TEST, NULL) == DISP_CHANGE_SUCCESSFUL;
+#endif
+	/* Query for the desktop resolution */
+	EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &SDL_desktop_mode);
+	this->info.current_w = SDL_desktop_mode.dmPelsWidth;
+	this->info.current_h = SDL_desktop_mode.dmPelsHeight;
+
+	/* Query for the list of available video modes */
+	for ( i=0; EnumDisplaySettings(NULL, i, &settings); ++i ) {
+		DIB_AddMode(this, settings.dmBitsPerPel,
+			settings.dmPelsWidth, settings.dmPelsHeight);
+#ifdef _WIN32_WCE		
+		if( this->hidden->supportRotation )
+			DIB_AddMode(this, settings.dmBitsPerPel,
+				settings.dmPelsHeight, settings.dmPelsWidth);
+#endif
+	}
+	/* Sort the mode lists */
+	for ( i=0; i<NUM_MODELISTS; ++i ) {
+		if ( SDL_nummodes[i] > 0 ) {
+			SDL_qsort(SDL_modelist[i], SDL_nummodes[i], sizeof *SDL_modelist[i], cmpmodes);
+		}
+	}
+#else
+	// WinCE and fullscreen mode:
+	// We use only vformat->BitsPerPixel that allow SDL to
+	// emulate other bpp (8, 32) and use triple buffer, 
+	// because SDL surface conversion is much faster than the WinCE one.
+	// Although it should be tested on devices with graphics accelerator.
+
+	DIB_AddMode(this, vformat->BitsPerPixel,
+			GetDeviceCaps(GetDC(NULL), HORZRES), 
+			GetDeviceCaps(GetDC(NULL), VERTRES));
+
+#endif /* !NO_CHANGEDISPLAYSETTINGS */
+
+	/* Grab an identity palette if we are in a palettized mode */
+	if ( vformat->BitsPerPixel <= 8 ) {
+	/*	RJR: March 28, 2000
+		moved palette creation to "DIB_CreatePalette" */
+		DIB_CreatePalette(this, vformat->BitsPerPixel);
+	}
+
+	/* Fill in some window manager capabilities */
+	this->info.wm_available = 1;
+
+#ifdef _WIN32_WCE
+	this->hidden->origRotation = -1;
+#endif
+
+	/* Allow environment override of screensaver disable. */
+	env = SDL_getenv("SDL_VIDEO_ALLOW_SCREENSAVER");
+	this->hidden->allow_screensaver = ( (env && SDL_atoi(env)) ? 1 : 0 );
+
+	/* We're done! */
+	return(0);
+}
+
+/* We support any format at any dimension */
+SDL_Rect **DIB_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	if ( (flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
+		return(SDL_modelist[((format->BitsPerPixel+7)/8)-1]);
+	} else {
+		return((SDL_Rect **)-1);
+	}
+}
+
+
+/*
+  Helper fn to work out which screen depth windows is currently using.
+  15 bit mode is considered 555 format, 16 bit is 565.
+  returns 0 for unknown mode.
+  (Derived from code in sept 1999 Windows Developer Journal
+  http://www.wdj.com/code/archive.html)
+*/
+static int DIB_SussScreenDepth()
+{
+#ifdef NO_GETDIBITS
+	int depth;
+	HDC hdc;
+
+	hdc = GetDC(SDL_Window);
+	depth = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
+	ReleaseDC(SDL_Window, hdc);
+	return(depth);
+#else
+    int depth;
+    int dib_size;
+    LPBITMAPINFOHEADER dib_hdr;
+    HDC hdc;
+    HBITMAP hbm;
+
+    /* Allocate enough space for a DIB header plus palette (for
+     * 8-bit modes) or bitfields (for 16- and 32-bit modes)
+     */
+    dib_size = sizeof(BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD);
+    dib_hdr = (LPBITMAPINFOHEADER) SDL_malloc(dib_size);
+    SDL_memset(dib_hdr, 0, dib_size);
+    dib_hdr->biSize = sizeof(BITMAPINFOHEADER);
+    
+    /* Get a device-dependent bitmap that's compatible with the
+       screen.
+     */
+    hdc = GetDC(NULL);
+    hbm = CreateCompatibleBitmap( hdc, 1, 1 );
+
+    /* Convert the DDB to a DIB.  We need to call GetDIBits twice:
+     * the first call just fills in the BITMAPINFOHEADER; the 
+     * second fills in the bitfields or palette.
+     */
+    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO) dib_hdr, DIB_RGB_COLORS);
+    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO) dib_hdr, DIB_RGB_COLORS);
+    DeleteObject(hbm);
+    ReleaseDC(NULL, hdc);
+
+    depth = 0;
+    switch( dib_hdr->biBitCount )
+    {
+    case 8:     depth = 8; break;
+    case 24:    depth = 24; break;
+    case 32:    depth = 32; break;
+    case 16:
+        if( dib_hdr->biCompression == BI_BITFIELDS ) {
+            /* check the red mask */
+            switch( ((DWORD*)((char*)dib_hdr + dib_hdr->biSize))[0] ) {
+                case 0xf800: depth = 16; break;   /* 565 */
+                case 0x7c00: depth = 15; break;   /* 555 */
+            }
+        }
+    }
+    SDL_free(dib_hdr);
+    return depth;
+#endif /* NO_GETDIBITS */
+}
+
+
+/* Various screen update functions available */
+static void DIB_NormalUpdate(_THIS, int numrects, SDL_Rect *rects);
+
+SDL_Surface *DIB_SetVideoMode(_THIS, SDL_Surface *current,
+				int width, int height, int bpp, Uint32 flags)
+{
+	SDL_Surface *video;
+	int prev_w, prev_h;
+	Uint32 prev_flags;
+	DWORD style;
+	const DWORD directstyle =
+			(WS_POPUP);
+	const DWORD windowstyle = 
+			(WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX);
+	const DWORD resizestyle =
+			(WS_THICKFRAME|WS_MAXIMIZEBOX);
+	int binfo_size;
+	BITMAPINFO *binfo;
+	HDC hdc;
+	RECT bounds;
+	int x, y;
+	Uint32 Rmask, Gmask, Bmask;
+
+	prev_flags = current->flags;
+
+	/* Clean up any GL context that may be hanging around */
+	if ( current->flags & SDL_OPENGL ) {
+		WIN_GL_ShutDown(this);
+	}
+	SDL_resizing = 1;
+
+	/* Recalculate the bitmasks if necessary */
+	if ( bpp == current->format->BitsPerPixel ) {
+		video = current;
+	} else {
+		switch (bpp) {
+			case 15:
+			case 16:
+				if ( DIB_SussScreenDepth() == 15 ) {
+					/* 5-5-5 */
+					Rmask = 0x00007c00;
+					Gmask = 0x000003e0;
+					Bmask = 0x0000001f;
+				} else {
+					/* 5-6-5 */
+					Rmask = 0x0000f800;
+					Gmask = 0x000007e0;
+					Bmask = 0x0000001f;
+				}
+				break;
+			case 24:
+			case 32:
+				/* GDI defined as 8-8-8 */
+				Rmask = 0x00ff0000;
+				Gmask = 0x0000ff00;
+				Bmask = 0x000000ff;
+				break;
+			default:
+				Rmask = 0x00000000;
+				Gmask = 0x00000000;
+				Bmask = 0x00000000;
+				break;
+		}
+		video = SDL_CreateRGBSurface(SDL_SWSURFACE,
+					0, 0, bpp, Rmask, Gmask, Bmask, 0);
+		if ( video == NULL ) {
+			SDL_OutOfMemory();
+			return(NULL);
+		}
+	}
+
+	/* Fill in part of the video surface */
+	prev_w = video->w;
+	prev_h = video->h;
+	video->flags = 0;	/* Clear flags */
+	video->w = width;
+	video->h = height;
+	video->pitch = SDL_CalculatePitch(video);
+
+	/* Small fix for WinCE/Win32 - when activating window
+	   SDL_VideoSurface is equal to zero, so activating code
+	   is not called properly for fullscreen windows because
+	   macros WINDIB_FULLSCREEN uses SDL_VideoSurface
+	*/
+	SDL_VideoSurface = video;
+
+#if defined(_WIN32_WCE)
+	if ( flags & SDL_FULLSCREEN )
+		video->flags |= SDL_FULLSCREEN;
+#endif
+
+#ifndef NO_CHANGEDISPLAYSETTINGS
+	/* Set fullscreen mode if appropriate */
+	if ( (flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
+		DEVMODE settings;
+		BOOL changed;
+
+		SDL_memset(&settings, 0, sizeof(DEVMODE));
+		settings.dmSize = sizeof(DEVMODE);
+
+#ifdef _WIN32_WCE
+		// try to rotate screen to fit requested resolution
+		if( this->hidden->supportRotation )
+		{
+			DWORD rotation;
+
+			// ask current mode
+			settings.dmFields = DM_DISPLAYORIENTATION;
+			ChangeDisplaySettingsEx(NULL, &settings, NULL, CDS_TEST, NULL);
+			rotation = settings.dmDisplayOrientation;
+
+			if( (width > GetDeviceCaps(GetDC(NULL), HORZRES))
+				&& (height < GetDeviceCaps(GetDC(NULL), VERTRES)))
+			{
+				switch( rotation )
+				{
+				case DMDO_0:
+					settings.dmDisplayOrientation = DMDO_90;
+					break;
+				case DMDO_270:
+					settings.dmDisplayOrientation = DMDO_180;
+					break;
+				}
+				if( settings.dmDisplayOrientation != rotation )
+				{
+					// go to landscape
+					this->hidden->origRotation = rotation;
+					ChangeDisplaySettingsEx(NULL,&settings,NULL,CDS_RESET,NULL);
+				}
+			}
+			if( (width < GetDeviceCaps(GetDC(NULL), HORZRES))
+				&& (height > GetDeviceCaps(GetDC(NULL), VERTRES)))
+			{
+				switch( rotation )
+				{
+				case DMDO_90:
+					settings.dmDisplayOrientation = DMDO_0;
+					break;
+				case DMDO_180:
+					settings.dmDisplayOrientation = DMDO_270;
+					break;
+				}
+				if( settings.dmDisplayOrientation != rotation )
+				{
+					// go to portrait
+					this->hidden->origRotation = rotation;
+					ChangeDisplaySettingsEx(NULL,&settings,NULL,CDS_RESET,NULL);
+				}
+			}
+
+		}
+#endif
+
+#ifndef _WIN32_WCE
+		settings.dmBitsPerPel = video->format->BitsPerPixel;
+		settings.dmPelsWidth = width;
+		settings.dmPelsHeight = height;
+		settings.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;
+		if ( width <= (int)SDL_desktop_mode.dmPelsWidth &&
+		     height <= (int)SDL_desktop_mode.dmPelsHeight ) {
+			settings.dmDisplayFrequency = SDL_desktop_mode.dmDisplayFrequency;
+			settings.dmFields |= DM_DISPLAYFREQUENCY;
+		}
+		changed = (ChangeDisplaySettings(&settings, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL);
+		if ( ! changed && (settings.dmFields & DM_DISPLAYFREQUENCY) ) {
+			settings.dmFields &= ~DM_DISPLAYFREQUENCY;
+			changed = (ChangeDisplaySettings(&settings, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL);
+		}
+#else
+		changed = 1;
+#endif
+		if ( changed ) {
+			video->flags |= SDL_FULLSCREEN;
+			SDL_fullscreen_mode = settings;
+		}
+
+	}
+#endif /* !NO_CHANGEDISPLAYSETTINGS */
+
+	/* Reset the palette and create a new one if necessary */
+	if ( grab_palette ) {
+		DIB_ReleaseStaticColors(SDL_Window);
+		grab_palette = FALSE;
+	}
+	if ( screen_pal != NULL ) {
+	/*	RJR: March 28, 2000
+		delete identity palette if switching from a palettized mode */
+		DeleteObject(screen_pal);
+		screen_pal = NULL;
+	}
+	if ( screen_logpal != NULL ) {
+		SDL_free(screen_logpal);
+		screen_logpal = NULL;
+	}
+
+	if ( bpp <= 8 )
+	{
+	/*	RJR: March 28, 2000
+		create identity palette switching to a palettized mode */
+		DIB_CreatePalette(this, bpp);
+	}
+
+	style = GetWindowLong(SDL_Window, GWL_STYLE);
+	style &= ~(resizestyle|WS_MAXIMIZE);
+	if ( (video->flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
+		style &= ~windowstyle;
+		style |= directstyle;
+	} else {
+#ifndef NO_CHANGEDISPLAYSETTINGS
+		if ( (prev_flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
+			ChangeDisplaySettings(NULL, 0);
+		}
+#endif
+		if ( flags & SDL_NOFRAME ) {
+			style &= ~windowstyle;
+			style |= directstyle;
+			video->flags |= SDL_NOFRAME;
+		} else {
+			style &= ~directstyle;
+			style |= windowstyle;
+			if ( flags & SDL_RESIZABLE ) {
+				style |= resizestyle;
+				video->flags |= SDL_RESIZABLE;
+			}
+		}
+#if WS_MAXIMIZE
+		if (IsZoomed(SDL_Window)) style |= WS_MAXIMIZE;
+#endif
+	}
+
+	/* DJM: Don't piss of anyone who has setup his own window */
+	if ( !SDL_windowid )
+		SetWindowLong(SDL_Window, GWL_STYLE, style);
+
+	/* Delete the old bitmap if necessary */
+	if ( screen_bmp != NULL ) {
+		DeleteObject(screen_bmp);
+	}
+	if ( ! (flags & SDL_OPENGL) ) {
+		BOOL is16bitmode = (video->format->BytesPerPixel == 2);
+
+		/* Suss out the bitmap info header */
+		binfo_size = sizeof(*binfo);
+		if( is16bitmode ) {
+			/* 16bit modes, palette area used for rgb bitmasks */
+			binfo_size += 3*sizeof(DWORD);
+		} else if ( video->format->palette ) {
+			binfo_size += video->format->palette->ncolors *
+							sizeof(RGBQUAD);
+		}
+		binfo = (BITMAPINFO *)SDL_malloc(binfo_size);
+		if ( ! binfo ) {
+			if ( video != current ) {
+				SDL_FreeSurface(video);
+			}
+			SDL_OutOfMemory();
+			return(NULL);
+		}
+
+		binfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+		binfo->bmiHeader.biWidth = video->w;
+		binfo->bmiHeader.biHeight = -video->h;	/* -ve for topdown bitmap */
+		binfo->bmiHeader.biPlanes = 1;
+		binfo->bmiHeader.biSizeImage = video->h * video->pitch;
+		binfo->bmiHeader.biXPelsPerMeter = 0;
+		binfo->bmiHeader.biYPelsPerMeter = 0;
+		binfo->bmiHeader.biClrUsed = 0;
+		binfo->bmiHeader.biClrImportant = 0;
+		binfo->bmiHeader.biBitCount = video->format->BitsPerPixel;
+
+		if ( is16bitmode ) {
+			/* BI_BITFIELDS tells CreateDIBSection about the rgb masks in the palette */
+			binfo->bmiHeader.biCompression = BI_BITFIELDS;
+			((Uint32*)binfo->bmiColors)[0] = video->format->Rmask;
+			((Uint32*)binfo->bmiColors)[1] = video->format->Gmask;
+			((Uint32*)binfo->bmiColors)[2] = video->format->Bmask;
+		} else {
+			binfo->bmiHeader.biCompression = BI_RGB;	/* BI_BITFIELDS for 565 vs 555 */
+			if ( video->format->palette ) {
+				SDL_memset(binfo->bmiColors, 0,
+					video->format->palette->ncolors*sizeof(RGBQUAD));
+			}
+		}
+
+		/* Create the offscreen bitmap buffer */
+		hdc = GetDC(SDL_Window);
+		screen_bmp = CreateDIBSection(hdc, binfo, DIB_RGB_COLORS,
+					(void **)(&video->pixels), NULL, 0);
+		ReleaseDC(SDL_Window, hdc);
+		SDL_free(binfo);
+		if ( screen_bmp == NULL ) {
+			if ( video != current ) {
+				SDL_FreeSurface(video);
+			}
+			SDL_SetError("Couldn't create DIB section");
+			return(NULL);
+		}
+		this->UpdateRects = DIB_NormalUpdate;
+
+		/* Set video surface flags */
+		if ( screen_pal && (flags & (SDL_FULLSCREEN|SDL_HWPALETTE)) ) {
+			grab_palette = TRUE;
+		}
+		/* BitBlt() maps colors for us */
+		video->flags |= SDL_HWPALETTE;
+	}
+#ifndef _WIN32_WCE
+	/* Resize the window */
+	if ( !SDL_windowid && !IsZoomed(SDL_Window) ) {
+#else
+	if ( !SDL_windowid ) {
+#endif
+		HWND top;
+		UINT swp_flags;
+		const char *window = NULL;
+		const char *center = NULL;
+
+		if ( video->w != prev_w || video->h != prev_h ) {
+			window = SDL_getenv("SDL_VIDEO_WINDOW_POS");
+			center = SDL_getenv("SDL_VIDEO_CENTERED");
+			if ( window ) {
+				if ( SDL_sscanf(window, "%d,%d", &x, &y) == 2 ) {
+					SDL_windowX = x;
+					SDL_windowY = y;
+				}
+				if ( SDL_strcmp(window, "center") == 0 ) {
+					center = window;
+				}
+			}
+		}
+		swp_flags = (SWP_NOCOPYBITS | SWP_SHOWWINDOW);
+
+		bounds.left = SDL_windowX;
+		bounds.top = SDL_windowY;
+		bounds.right = SDL_windowX+video->w;
+		bounds.bottom = SDL_windowY+video->h;
+#ifndef _WIN32_WCE
+		AdjustWindowRectEx(&bounds, GetWindowLong(SDL_Window, GWL_STYLE), (GetMenu(SDL_Window) != NULL), 0);
+#else
+		// The bMenu parameter must be FALSE; menu bars are not supported
+		AdjustWindowRectEx(&bounds, GetWindowLong(SDL_Window, GWL_STYLE), 0, 0);
+#endif
+		width = bounds.right-bounds.left;
+		height = bounds.bottom-bounds.top;
+		if ( (flags & SDL_FULLSCREEN) ) {
+			x = (GetSystemMetrics(SM_CXSCREEN)-width)/2;
+			y = (GetSystemMetrics(SM_CYSCREEN)-height)/2;
+		} else if ( center ) {
+			x = (GetSystemMetrics(SM_CXSCREEN)-width)/2;
+			y = (GetSystemMetrics(SM_CYSCREEN)-height)/2;
+		} else if ( SDL_windowX || SDL_windowY || window ) {
+			x = bounds.left;
+			y = bounds.top;
+		} else {
+			x = y = -1;
+			swp_flags |= SWP_NOMOVE;
+		}
+		if ( flags & SDL_FULLSCREEN ) {
+			top = HWND_TOPMOST;
+		} else {
+			top = HWND_NOTOPMOST;
+		}
+		SetWindowPos(SDL_Window, top, x, y, width, height, swp_flags);
+		if ( !(flags & SDL_FULLSCREEN) ) {
+			SDL_windowX = SDL_bounds.left;
+			SDL_windowY = SDL_bounds.top;
+		}
+		SetForegroundWindow(SDL_Window);
+	}
+	SDL_resizing = 0;
+
+	/* Set up for OpenGL */
+	if ( flags & SDL_OPENGL ) {
+		if ( WIN_GL_SetupWindow(this) < 0 ) {
+			return(NULL);
+		}
+		video->flags |= SDL_OPENGL;
+	}
+
+	/* JC 14 Mar 2006
+		Flush the message loop or this can cause big problems later
+		Especially if the user decides to use dialog boxes or assert()!
+	*/
+	WIN_FlushMessageQueue();
+
+	/* We're live! */
+	return(video);
+}
+
+/* We don't actually allow hardware surfaces in the DIB driver */
+static int DIB_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+static void DIB_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+static int DIB_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+static void DIB_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static void DIB_NormalUpdate(_THIS, int numrects, SDL_Rect *rects)
+{
+	HDC hdc, mdc;
+	int i;
+
+	hdc = GetDC(SDL_Window);
+	if ( screen_pal ) {
+		SelectPalette(hdc, screen_pal, FALSE);
+	}
+	mdc = CreateCompatibleDC(hdc);
+	SelectObject(mdc, screen_bmp);
+	for ( i=0; i<numrects; ++i ) {
+		BitBlt(hdc, rects[i].x, rects[i].y, rects[i].w, rects[i].h,
+					mdc, rects[i].x, rects[i].y, SRCCOPY);
+	}
+	DeleteDC(mdc);
+	ReleaseDC(SDL_Window, hdc);
+}
+
+static int FindPaletteIndex(LOGPALETTE *pal, BYTE r, BYTE g, BYTE b)
+{
+	PALETTEENTRY *entry;
+	int i;
+	int nentries = pal->palNumEntries;
+
+	for ( i = 0; i < nentries; ++i ) {
+		entry = &pal->palPalEntry[i];
+		if ( entry->peRed == r && entry->peGreen == g && entry->peBlue == b ) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+static BOOL CheckPaletteEntry(LOGPALETTE *pal, int index, BYTE r, BYTE g, BYTE b)
+{
+	PALETTEENTRY *entry;
+	BOOL moved = 0;
+
+	entry = &pal->palPalEntry[index];
+	if ( entry->peRed != r || entry->peGreen != g || entry->peBlue != b ) {
+		int found = FindPaletteIndex(pal, r, g, b);
+		if ( found >= 0 ) {
+			pal->palPalEntry[found] = *entry;
+		}
+		entry->peRed = r;
+		entry->peGreen = g;
+		entry->peBlue = b;
+		moved = 1;
+	}
+	entry->peFlags = 0;
+
+	return moved;
+}
+
+int DIB_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
+{
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+	HDC hdc, mdc;
+	RGBQUAD *pal;
+#else
+	HDC hdc;
+#endif
+	int i;
+	int moved_entries = 0;
+
+	/* Update the display palette */
+	hdc = GetDC(SDL_Window);
+	if ( screen_pal ) {
+		PALETTEENTRY *entry;
+
+		for ( i=0; i<ncolors; ++i ) {
+			entry = &screen_logpal->palPalEntry[firstcolor+i];
+			entry->peRed   = colors[i].r;
+			entry->peGreen = colors[i].g;
+			entry->peBlue  = colors[i].b;
+			entry->peFlags = PC_NOCOLLAPSE;
+		}
+#ifdef SYSPAL_NOSTATIC
+		/* Check to make sure black and white are in position */
+		if ( GetSystemPaletteUse(hdc) != SYSPAL_NOSTATIC256 ) {
+			moved_entries += CheckPaletteEntry(screen_logpal, 0, 0x00, 0x00, 0x00);
+			moved_entries += CheckPaletteEntry(screen_logpal, screen_logpal->palNumEntries-1, 0xff, 0xff, 0xff);
+		}
+		/* FIXME:
+		   If we don't have full access to the palette, what we
+		   really want to do is find the 236 most diverse colors
+		   in the desired palette, set those entries (10-245) and
+		   then map everything into the new system palette.
+		 */
+#endif
+
+#ifndef _WIN32_WCE
+		/* Copy the entries into the system palette */
+		UnrealizeObject(screen_pal);
+#endif
+		SetPaletteEntries(screen_pal, 0, screen_logpal->palNumEntries, screen_logpal->palPalEntry);
+		SelectPalette(hdc, screen_pal, FALSE);
+		RealizePalette(hdc);
+	}
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+	/* Copy palette colors into DIB palette */
+	pal = SDL_stack_alloc(RGBQUAD, ncolors);
+	for ( i=0; i<ncolors; ++i ) {
+		pal[i].rgbRed = colors[i].r;
+		pal[i].rgbGreen = colors[i].g;
+		pal[i].rgbBlue = colors[i].b;
+		pal[i].rgbReserved = 0;
+	}
+
+	/* Set the DIB palette and update the display */
+	mdc = CreateCompatibleDC(hdc);
+	SelectObject(mdc, screen_bmp);
+	SetDIBColorTable(mdc, firstcolor, ncolors, pal);
+	if ( moved_entries || !grab_palette ) {
+		BitBlt(hdc, 0, 0, this->screen->w, this->screen->h,
+		       mdc, 0, 0, SRCCOPY);
+	}
+	DeleteDC(mdc);
+	SDL_stack_free(pal);
+#endif
+	ReleaseDC(SDL_Window, hdc);
+	return(1);
+}
+
+
+static void DIB_CheckGamma(_THIS)
+{
+#ifndef NO_GAMMA_SUPPORT
+	HDC hdc;
+	WORD ramp[3*256];
+
+	/* If we fail to get gamma, disable gamma control */
+	hdc = GetDC(SDL_Window);
+	if ( ! GetDeviceGammaRamp(hdc, ramp) ) {
+		this->GetGammaRamp = NULL;
+		this->SetGammaRamp = NULL;
+	}
+	ReleaseDC(SDL_Window, hdc);
+#endif /* !NO_GAMMA_SUPPORT */
+}
+void DIB_SwapGamma(_THIS)
+{
+#ifndef NO_GAMMA_SUPPORT
+	HDC hdc;
+
+	if ( gamma_saved ) {
+		hdc = GetDC(SDL_Window);
+		if ( SDL_GetAppState() & SDL_APPINPUTFOCUS ) {
+			/* About to leave active state, restore gamma */
+			SetDeviceGammaRamp(hdc, gamma_saved);
+		} else {
+			/* About to enter active state, set game gamma */
+			GetDeviceGammaRamp(hdc, gamma_saved);
+			SetDeviceGammaRamp(hdc, this->gamma);
+		}
+		ReleaseDC(SDL_Window, hdc);
+	}
+#endif /* !NO_GAMMA_SUPPORT */
+}
+void DIB_QuitGamma(_THIS)
+{
+#ifndef NO_GAMMA_SUPPORT
+	if ( gamma_saved ) {
+		/* Restore the original gamma if necessary */
+		if ( SDL_GetAppState() & SDL_APPINPUTFOCUS ) {
+			HDC hdc;
+
+			hdc = GetDC(SDL_Window);
+			SetDeviceGammaRamp(hdc, gamma_saved);
+			ReleaseDC(SDL_Window, hdc);
+		}
+
+		/* Free the saved gamma memory */
+		SDL_free(gamma_saved);
+		gamma_saved = 0;
+	}
+#endif /* !NO_GAMMA_SUPPORT */
+}
+
+int DIB_SetGammaRamp(_THIS, Uint16 *ramp)
+{
+#ifdef NO_GAMMA_SUPPORT
+	SDL_SetError("SDL compiled without gamma ramp support");
+	return -1;
+#else
+	HDC hdc;
+	BOOL succeeded;
+
+	/* Set the ramp for the display */
+	if ( ! gamma_saved ) {
+		gamma_saved = (WORD *)SDL_malloc(3*256*sizeof(*gamma_saved));
+		if ( ! gamma_saved ) {
+			SDL_OutOfMemory();
+			return -1;
+		}
+		hdc = GetDC(SDL_Window);
+		GetDeviceGammaRamp(hdc, gamma_saved);
+		ReleaseDC(SDL_Window, hdc);
+	}
+	if ( SDL_GetAppState() & SDL_APPINPUTFOCUS ) {
+		hdc = GetDC(SDL_Window);
+		succeeded = SetDeviceGammaRamp(hdc, ramp);
+		ReleaseDC(SDL_Window, hdc);
+	} else {
+		succeeded = TRUE;
+	}
+	return succeeded ? 0 : -1;
+#endif /* !NO_GAMMA_SUPPORT */
+}
+
+int DIB_GetGammaRamp(_THIS, Uint16 *ramp)
+{
+#ifdef NO_GAMMA_SUPPORT
+	SDL_SetError("SDL compiled without gamma ramp support");
+	return -1;
+#else
+	HDC hdc;
+	BOOL succeeded;
+
+	/* Get the ramp from the display */
+	hdc = GetDC(SDL_Window);
+	succeeded = GetDeviceGammaRamp(hdc, ramp);
+	ReleaseDC(SDL_Window, hdc);
+	return succeeded ? 0 : -1;
+#endif /* !NO_GAMMA_SUPPORT */
+}
+
+void DIB_VideoQuit(_THIS)
+{
+	int i, j;
+
+	/* Destroy the window and everything associated with it */
+	if ( SDL_Window ) {
+		/* Delete the screen bitmap (also frees screen->pixels) */
+		if ( this->screen ) {
+			if ( grab_palette ) {
+				DIB_ReleaseStaticColors(SDL_Window);
+			}
+#ifndef NO_CHANGEDISPLAYSETTINGS
+			if ( this->screen->flags & SDL_FULLSCREEN ) {
+				ChangeDisplaySettings(NULL, 0);
+				ShowWindow(SDL_Window, SW_HIDE);
+			}
+#endif
+			if ( this->screen->flags & SDL_OPENGL ) {
+				WIN_GL_ShutDown(this);
+			}
+			this->screen->pixels = NULL;
+		}
+		if ( screen_pal != NULL ) {
+			DeleteObject(screen_pal);
+			screen_pal = NULL;
+		}
+		if ( screen_logpal != NULL ) {
+			SDL_free(screen_logpal);
+			screen_logpal = NULL;
+		}
+		if ( screen_bmp ) {
+			DeleteObject(screen_bmp);
+			screen_bmp = NULL;
+		}
+		if ( screen_icn ) {
+			DestroyIcon(screen_icn);
+			screen_icn = NULL;
+		}
+		DIB_QuitGamma(this);
+		DIB_DestroyWindow(this);
+
+		SDL_Window = NULL;
+
+#if defined(_WIN32_WCE)
+
+// Unload wince aygshell library to prevent leak
+		if( aygshell ) 
+		{
+			FreeLibrary(aygshell);
+			aygshell = NULL;
+		}
+#endif
+	}
+
+	for ( i=0; i < SDL_arraysize(SDL_modelist); ++i ) {
+		if ( !SDL_modelist[i] ) {
+			continue;
+		}
+		for ( j=0; SDL_modelist[i][j]; ++j ) {
+			SDL_free(SDL_modelist[i][j]);
+		}
+		SDL_free(SDL_modelist[i]);
+		SDL_modelist[i] = NULL;
+		SDL_nummodes[i] = 0;
+	}
+}
+
+/* Exported for the windows message loop only */
+static void DIB_GrabStaticColors(HWND window)
+{
+#ifdef SYSPAL_NOSTATIC
+	HDC hdc;
+
+	hdc = GetDC(window);
+	SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC256);
+	if ( GetSystemPaletteUse(hdc) != SYSPAL_NOSTATIC256 ) {
+		SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
+	}
+	ReleaseDC(window, hdc);
+#endif
+}
+static void DIB_ReleaseStaticColors(HWND window)
+{
+#ifdef SYSPAL_NOSTATIC
+	HDC hdc;
+
+	hdc = GetDC(window);
+	SetSystemPaletteUse(hdc, SYSPAL_STATIC);
+	ReleaseDC(window, hdc);
+#endif
+}
+static void DIB_Activate(_THIS, BOOL active, BOOL minimized)
+{
+	if ( grab_palette ) {
+		if ( !active ) {
+			DIB_ReleaseStaticColors(SDL_Window);
+			DIB_RealizePalette(this);
+		} else if ( !minimized ) {
+			DIB_GrabStaticColors(SDL_Window);
+			DIB_RealizePalette(this);
+		}
+	}
+}
+static void DIB_RealizePalette(_THIS)
+{
+	if ( screen_pal != NULL ) {
+		HDC hdc;
+
+		hdc = GetDC(SDL_Window);
+#ifndef _WIN32_WCE
+		UnrealizeObject(screen_pal);
+#endif
+		SelectPalette(hdc, screen_pal, FALSE);
+		if ( RealizePalette(hdc) ) {
+			InvalidateRect(SDL_Window, NULL, FALSE);
+		}
+		ReleaseDC(SDL_Window, hdc);
+	}
+}
+static void DIB_PaletteChanged(_THIS, HWND window)
+{
+	if ( window != SDL_Window ) {
+		DIB_RealizePalette(this);
+	}
+}
+
+/* Exported for the windows message loop only */
+static void DIB_WinPAINT(_THIS, HDC hdc)
+{
+	HDC mdc;
+
+	if ( screen_pal ) {
+		SelectPalette(hdc, screen_pal, FALSE);
+	}
+	mdc = CreateCompatibleDC(hdc);
+	SelectObject(mdc, screen_bmp);
+	BitBlt(hdc, 0, 0, SDL_VideoSurface->w, SDL_VideoSurface->h,
+							mdc, 0, 0, SRCCOPY);
+	DeleteDC(mdc);
+}
+
+/* Stub in case DirectX isn't available */
+#if !SDL_AUDIO_DRIVER_DSOUND
+void DX5_SoundFocus(HWND hwnd)
+{
+	return;
+}
+#endif
diff -ruN SDL-1.2.13/src/video/windx5/SDL_dx5events.c SDL-1.2.13_OOx64/src/video/windx5/SDL_dx5events.c
--- SDL-1.2.13/src/video/windx5/SDL_dx5events.c	2007-12-31 04:48:13 +0000
+++ SDL-1.2.13_OOx64/src/video/windx5/SDL_dx5events.c	2018-04-23 16:36:03 +0000
@@ -370,7 +370,7 @@
 					if ( button == 3 ) button = 1;
 				}
 				posted = SDL_PrivateMouseButton(state, button,
-									0, 0);
+									0, 0, 0);
 			}
 			old_state >>= 1;
 			new_state >>= 1;
@@ -416,14 +416,15 @@
 					yrel = 0;
 				}
 				timestamp = 0;
-				if((int)ptrbuf[i].dwData > 0)
+				int move = (int)ptrbuf[i].dwData;
+				if(move > 0)
 					button = SDL_BUTTON_WHEELUP;
 				else
 					button = SDL_BUTTON_WHEELDOWN;
 				posted = SDL_PrivateMouseButton(
-						SDL_PRESSED, button, 0, 0);
+						SDL_PRESSED, button, 0, 0, move);
 				posted |= SDL_PrivateMouseButton(
-						SDL_RELEASED, button, 0, 0);
+						SDL_RELEASED, button, 0, 0, move);
 				break;
 			case DIMOFS_BUTTON0:
 			case DIMOFS_BUTTON1:
@@ -466,7 +467,7 @@
 					if ( button == 3 ) button = 1;
 				}
 				posted = SDL_PrivateMouseButton(state, button,
-									0, 0);
+									0, 0, 0);
 				break;
 		}
 	}
diff -ruN SDL-1.2.13/test/Makefile SDL-1.2.13_OOx64/test/Makefile
--- SDL-1.2.13/test/Makefile	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/Makefile	2017-12-19 14:05:50 +0000
@@ -0,0 +1,120 @@
+# Makefile to build the SDL tests
+
+srcdir  = .
+
+CC      = gcc
+EXE	= .exe
+CFLAGS  = -g -O2 -I/mingw/../devlibs/include -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -DHAVE_OPENGL
+LIBS	=  -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL.dll -mconsole
+
+TARGETS = testhaptic$(EXE) checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
+
+all: $(TARGETS)
+
+testhaptic$(EXE): $(srcdir)/testhaptic.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+checkkeys$(EXE): $(srcdir)/checkkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+graywin$(EXE): $(srcdir)/graywin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+loopwave$(EXE): $(srcdir)/loopwave.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testalpha$(EXE): $(srcdir)/testalpha.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testbitmap$(EXE): $(srcdir)/testbitmap.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testblitspeed$(EXE): $(srcdir)/testblitspeed.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcdrom$(EXE): $(srcdir)/testcdrom.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcursor$(EXE): $(srcdir)/testcursor.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testdyngl$(EXE): $(srcdir)/testdyngl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testerror$(EXE): $(srcdir)/testerror.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testfile$(EXE): $(srcdir)/testfile.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testgamma$(EXE): $(srcdir)/testgamma.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testgl$(EXE): $(srcdir)/testgl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)  -lopengl32 
+
+testhread$(EXE): $(srcdir)/testhread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testiconv$(EXE): $(srcdir)/testiconv.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testjoystick$(EXE): $(srcdir)/testjoystick.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testkeys$(EXE): $(srcdir)/testkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testlock$(EXE): $(srcdir)/testlock.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay2$(EXE): $(srcdir)/testoverlay2.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay$(EXE): $(srcdir)/testoverlay.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testpalette$(EXE): $(srcdir)/testpalette.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testplatform$(EXE): $(srcdir)/testplatform.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsem$(EXE): $(srcdir)/testsem.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsprite$(EXE): $(srcdir)/testsprite.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testtimer$(EXE): $(srcdir)/testtimer.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testver$(EXE): $(srcdir)/testver.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testvidinfo$(EXE): $(srcdir)/testvidinfo.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwin$(EXE): $(srcdir)/testwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwm$(EXE): $(srcdir)/testwm.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+threadwin$(EXE): $(srcdir)/threadwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+torturethread$(EXE): $(srcdir)/torturethread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testloadso$(EXE): $(srcdir)/testloadso.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+
+clean:
+	rm -f $(TARGETS)
+
+distclean: clean
+	rm -f Makefile
+	rm -f config.status config.cache config.log
+	rm -rf $(srcdir)/autom4te*
diff -ruN SDL-1.2.13/test/Makefile.bak SDL-1.2.13_OOx64/test/Makefile.bak
--- SDL-1.2.13/test/Makefile.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/Makefile.bak	2013-10-03 19:02:00 +0000
@@ -0,0 +1,117 @@
+# Makefile to build the SDL tests
+
+srcdir  = .
+
+CC      = gcc
+EXE	= .exe
+CFLAGS  = -g -O2 -I/mingw/../devlibs/include -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -DHAVE_OPENGL
+LIBS	=  -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows
+
+TARGETS = checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
+
+all: $(TARGETS)
+
+checkkeys$(EXE): $(srcdir)/checkkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+graywin$(EXE): $(srcdir)/graywin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+loopwave$(EXE): $(srcdir)/loopwave.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testalpha$(EXE): $(srcdir)/testalpha.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testbitmap$(EXE): $(srcdir)/testbitmap.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testblitspeed$(EXE): $(srcdir)/testblitspeed.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcdrom$(EXE): $(srcdir)/testcdrom.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcursor$(EXE): $(srcdir)/testcursor.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testdyngl$(EXE): $(srcdir)/testdyngl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testerror$(EXE): $(srcdir)/testerror.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testfile$(EXE): $(srcdir)/testfile.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testgamma$(EXE): $(srcdir)/testgamma.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testgl$(EXE): $(srcdir)/testgl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)  -lopengl32 
+
+testhread$(EXE): $(srcdir)/testhread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testiconv$(EXE): $(srcdir)/testiconv.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testjoystick$(EXE): $(srcdir)/testjoystick.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testkeys$(EXE): $(srcdir)/testkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testlock$(EXE): $(srcdir)/testlock.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay2$(EXE): $(srcdir)/testoverlay2.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay$(EXE): $(srcdir)/testoverlay.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testpalette$(EXE): $(srcdir)/testpalette.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testplatform$(EXE): $(srcdir)/testplatform.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsem$(EXE): $(srcdir)/testsem.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsprite$(EXE): $(srcdir)/testsprite.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) 
+
+testtimer$(EXE): $(srcdir)/testtimer.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testver$(EXE): $(srcdir)/testver.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testvidinfo$(EXE): $(srcdir)/testvidinfo.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwin$(EXE): $(srcdir)/testwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwm$(EXE): $(srcdir)/testwm.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+threadwin$(EXE): $(srcdir)/threadwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+torturethread$(EXE): $(srcdir)/torturethread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testloadso$(EXE): $(srcdir)/testloadso.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+
+clean:
+	rm -f $(TARGETS)
+
+distclean: clean
+	rm -f Makefile
+	rm -f config.status config.cache config.log
+	rm -rf $(srcdir)/autom4te*
diff -ruN SDL-1.2.13/test/Makefile.in SDL-1.2.13_OOx64/test/Makefile.in
--- SDL-1.2.13/test/Makefile.in	2007-12-31 04:48:35 +0000
+++ SDL-1.2.13_OOx64/test/Makefile.in	2017-12-20 15:14:18 +0000
@@ -7,10 +7,13 @@
 CFLAGS  = @CFLAGS@
 LIBS	= @LIBS@
 
-TARGETS = checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
+TARGETS = testhaptic$(EXE) checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
 
 all: $(TARGETS)
 
+testhaptic$(EXE): $(srcdir)/testhaptic.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
 checkkeys$(EXE): $(srcdir)/checkkeys.c
 	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
 
diff -ruN SDL-1.2.13/test/Makefile.in.bak SDL-1.2.13_OOx64/test/Makefile.in.bak
--- SDL-1.2.13/test/Makefile.in.bak	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/Makefile.in.bak	2007-12-30 18:48:36 +0000
@@ -0,0 +1,117 @@
+# Makefile to build the SDL tests
+
+srcdir  = @srcdir@
+
+CC      = @CC@
+EXE	= @EXE@
+CFLAGS  = @CFLAGS@
+LIBS	= @LIBS@
+
+TARGETS = checkkeys$(EXE) graywin$(EXE) loopwave$(EXE) testalpha$(EXE) testbitmap$(EXE) testblitspeed$(EXE) testcdrom$(EXE) testcursor$(EXE) testdyngl$(EXE) testerror$(EXE) testfile$(EXE) testgamma$(EXE) testgl$(EXE) testhread$(EXE) testiconv$(EXE) testjoystick$(EXE) testkeys$(EXE) testlock$(EXE) testoverlay2$(EXE) testoverlay$(EXE) testpalette$(EXE) testplatform$(EXE) testsem$(EXE) testsprite$(EXE) testtimer$(EXE) testver$(EXE) testvidinfo$(EXE) testwin$(EXE) testwm$(EXE) threadwin$(EXE) torturethread$(EXE) testloadso$(EXE)
+
+all: $(TARGETS)
+
+checkkeys$(EXE): $(srcdir)/checkkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+graywin$(EXE): $(srcdir)/graywin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+loopwave$(EXE): $(srcdir)/loopwave.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testalpha$(EXE): $(srcdir)/testalpha.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) @MATHLIB@
+
+testbitmap$(EXE): $(srcdir)/testbitmap.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testblitspeed$(EXE): $(srcdir)/testblitspeed.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcdrom$(EXE): $(srcdir)/testcdrom.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testcursor$(EXE): $(srcdir)/testcursor.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testdyngl$(EXE): $(srcdir)/testdyngl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testerror$(EXE): $(srcdir)/testerror.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testfile$(EXE): $(srcdir)/testfile.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testgamma$(EXE): $(srcdir)/testgamma.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) @MATHLIB@
+
+testgl$(EXE): $(srcdir)/testgl.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) @GLLIB@ @MATHLIB@
+
+testhread$(EXE): $(srcdir)/testhread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testiconv$(EXE): $(srcdir)/testiconv.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testjoystick$(EXE): $(srcdir)/testjoystick.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testkeys$(EXE): $(srcdir)/testkeys.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testlock$(EXE): $(srcdir)/testlock.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay2$(EXE): $(srcdir)/testoverlay2.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testoverlay$(EXE): $(srcdir)/testoverlay.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testpalette$(EXE): $(srcdir)/testpalette.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) @MATHLIB@
+
+testplatform$(EXE): $(srcdir)/testplatform.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsem$(EXE): $(srcdir)/testsem.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testsprite$(EXE): $(srcdir)/testsprite.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS) @MATHLIB@
+
+testtimer$(EXE): $(srcdir)/testtimer.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testver$(EXE): $(srcdir)/testver.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testvidinfo$(EXE): $(srcdir)/testvidinfo.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwin$(EXE): $(srcdir)/testwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testwm$(EXE): $(srcdir)/testwm.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+threadwin$(EXE): $(srcdir)/threadwin.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+torturethread$(EXE): $(srcdir)/torturethread.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+testloadso$(EXE): $(srcdir)/testloadso.c
+	$(CC) -o $@ $? $(CFLAGS) $(LIBS)
+
+
+clean:
+	rm -f $(TARGETS)
+
+distclean: clean
+	rm -f Makefile
+	rm -f config.status config.cache config.log
+	rm -rf $(srcdir)/autom4te*
Files SDL-1.2.13/test/SDL.dll and SDL-1.2.13_OOx64/test/SDL.dll differ
diff -ruN SDL-1.2.13/test/config.log SDL-1.2.13_OOx64/test/config.log
--- SDL-1.2.13/test/config.log	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/config.log	2013-10-03 19:00:42 +0000
@@ -0,0 +1,344 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  $ ./configure 
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = BHIG4NYZN1
+uname -m = i686
+uname -r = 1.0.11(0.46/3/2)
+uname -s = MINGW32_NT-6.1
+uname -v = 2009-07-11 17:46
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = unknown
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: .
+PATH: /usr/local/bin
+PATH: /mingw/bin
+PATH: /bin
+PATH: /mingw/../devlibs/bin
+PATH: /c/Program Files (x86)/CA/SC/CAWIN/
+PATH: /c/windows/system32
+PATH: /c/windows
+PATH: /c/windows/System32/Wbem
+PATH: /c/windows/System32/WindowsPowerShell/v1.0/
+PATH: /c/Program Files/Dell/Dell Data Protection/Access/Advanced/Wave/Gemalto/Access Client/v5/
+PATH: /c/Program Files (x86)/Security Innovation/SI TSS/bin/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/DLLShared/
+PATH: /c/Program Files (x86)/Common Files/Roxio Shared/OEM/12.0/DLLShared/
+PATH: /c/Program Files (x86)/Roxio/OEM/AudioCore/
+PATH: /c/PROGRA~2/CA/SC/CAM/bin
+PATH: /c/Program Files (x86)/CA/SC/Csam/SockAdapter/bin
+PATH: /c/Program Files (x86)/CA/SC/CBB/
+PATH: /c/Program Files (x86)/CA/DSM/bin
+PATH: /svn/bin
+PATH: /nsis
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:1710: checking build system type
+configure:1728: result: i686-pc-mingw32
+configure:1750: checking host system type
+configure:1765: result: i686-pc-mingw32
+configure:1837: checking for gcc
+configure:1853: found /mingw/bin/gcc
+configure:1864: result: gcc
+configure:2102: checking for C compiler version
+configure:2109: gcc --version >&5
+gcc.exe (tdm64-1) 4.8.1
+Copyright (C) 2013 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:2112: $? = 0
+configure:2119: gcc -v >&5
+Using built-in specs.
+COLLECT_GCC=C:\DevelopmentEnvironment\gcc\Msys_x2\1.0\mingw\bin\gcc.exe
+COLLECT_LTO_WRAPPER=c:/developmentenvironment/gcc/msys_x2/1.0/mingw/bin/../libexec/gcc/x86_64-w64-mingw32/4.8.1/lto-wrapper.exe
+Target: x86_64-w64-mingw32
+Configured with: ../../../src/gcc-4.8.1/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs
+Thread model: posix
+gcc version 4.8.1 (tdm64-1) 
+configure:2122: $? = 0
+configure:2129: gcc -V >&5
+gcc.exe: error: unrecognized command line option '-V'
+gcc.exe: fatal error: no input files
+compilation terminated.
+configure:2132: $? = 1
+configure:2155: checking for C compiler default output file name
+configure:2182: gcc  -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  >&5
+configure:2185: $? = 0
+configure:2223: result: a.exe
+configure:2240: checking whether the C compiler works
+configure:2250: ./a.exe
+configure:2253: $? = 0
+configure:2270: result: yes
+configure:2277: checking whether we are cross compiling
+configure:2279: result: no
+configure:2282: checking for suffix of executables
+configure:2289: gcc -o conftest.exe  -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  >&5
+configure:2292: $? = 0
+configure:2316: result: .exe
+configure:2322: checking for suffix of object files
+configure:2348: gcc -c  -I/mingw/../devlibs/include conftest.c >&5
+configure:2351: $? = 0
+configure:2374: result: o
+configure:2378: checking whether we are using the GNU C compiler
+configure:2407: gcc -c  -I/mingw/../devlibs/include conftest.c >&5
+configure:2413: $? = 0
+configure:2430: result: yes
+configure:2435: checking whether gcc accepts -g
+configure:2465: gcc -c -g -I/mingw/../devlibs/include conftest.c >&5
+configure:2471: $? = 0
+configure:2570: result: yes
+configure:2587: checking for gcc option to accept ISO C89
+configure:2661: gcc  -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:2667: $? = 0
+configure:2690: result: none needed
+configure:2711: checking for an ANSI C-conforming const
+configure:2786: gcc -c -g -O2 -I/mingw/../devlibs/include conftest.c >&5
+configure:2792: $? = 0
+configure:2807: result: yes
+configure:2946: checking for sdl-config
+configure:2964: found /mingw/../devlibs/bin/sdl-config
+configure:2977: result: /mingw/../devlibs/bin/sdl-config
+configure:2986: checking for SDL - version >= 1.2.10
+configure:3083: gcc -o conftest.exe -g -O2 -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c  -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows >&5
+configure:3086: $? = 0
+configure:3092: ./conftest.exe
+configure:3095: $? = 0
+configure:3116: result: yes
+configure:3221: checking how to run the C preprocessor
+configure:3261: gcc -E -I/mingw/../devlibs/include conftest.c
+configure:3267: $? = 0
+configure:3298: gcc -E -I/mingw/../devlibs/include conftest.c
+conftest.c:8:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:3304: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3337: result: gcc -E
+configure:3366: gcc -E -I/mingw/../devlibs/include conftest.c
+configure:3372: $? = 0
+configure:3403: gcc -E -I/mingw/../devlibs/include conftest.c
+conftest.c:8:28: fatal error: ac_nonexistent.h: No such file or directory
+ #include <ac_nonexistent.h>
+                            ^
+compilation terminated.
+configure:3409: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3447: checking for X
+configure:3562: gcc -E -I/mingw/../devlibs/include conftest.c
+conftest.c:8:22: fatal error: X11/Xlib.h: No such file or directory
+ #include <X11/Xlib.h>
+                      ^
+compilation terminated.
+configure:3568: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <X11/Xlib.h>
+configure:3617: gcc -o conftest.exe -g -O2 -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -I/mingw/../devlibs/include -L/mingw/../devlibs/lib conftest.c -lX11  -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows >&5
+conftest.c:8:22: fatal error: X11/Xlib.h: No such file or directory
+ #include <X11/Xlib.h>
+                      ^
+compilation terminated.
+configure:3623: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <X11/Xlib.h>
+| int
+| main ()
+| {
+| XrmInitialize ()
+|   ;
+|   return 0;
+| }
+configure:3671: result: no
+configure:3699: checking for OpenGL support
+configure:3726: gcc -c -g -O2 -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -I/mingw/../devlibs/include conftest.c >&5
+configure:3732: $? = 0
+configure:3748: result: yes
+configure:3890: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by config.status, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on BHIG4NYZN1
+
+config.status:588: creating Makefile
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=i686-pc-mingw32
+ac_cv_c_compiler_gnu=yes
+ac_cv_c_const=yes
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=set
+ac_cv_env_CPPFLAGS_value=-I/mingw/../devlibs/include
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_LDFLAGS_set=set
+ac_cv_env_LDFLAGS_value=-L/mingw/../devlibs/lib
+ac_cv_env_LIBS_set=
+ac_cv_env_LIBS_value=
+ac_cv_env_XMKMF_set=
+ac_cv_env_XMKMF_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_exeext=.exe
+ac_cv_have_x=have_x=no
+ac_cv_host=i686-pc-mingw32
+ac_cv_objext=o
+ac_cv_path_SDL_CONFIG=/mingw/../devlibs/bin/sdl-config
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_cc_c89=
+ac_cv_prog_cc_g=yes
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+CC='gcc'
+CFLAGS='-g -O2 -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -DHAVE_OPENGL'
+CPP='gcc -E'
+CPPFLAGS='-I/mingw/../devlibs/include'
+DEFS='-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\"'
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+EXE='.exe'
+EXEEXT='.exe'
+GLLIB=' -lopengl32'
+LDFLAGS='-L/mingw/../devlibs/lib'
+LIBOBJS=''
+LIBS=' -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows'
+LTLIBOBJS=''
+MATHLIB=''
+OBJEXT='o'
+OSMESA_CONFIG=''
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+SDL_CFLAGS='-I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main'
+SDL_CONFIG='/mingw/../devlibs/bin/sdl-config'
+SDL_LIBS='-L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows'
+SHELL='/bin/sh'
+XMKMF=''
+ac_ct_CC='gcc'
+bindir='${exec_prefix}/bin'
+build='i686-pc-mingw32'
+build_alias=''
+build_cpu='i686'
+build_os='mingw32'
+build_vendor='pc'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+docdir='${datarootdir}/doc/${PACKAGE}'
+dvidir='${docdir}'
+exec_prefix='${prefix}'
+host='i686-pc-mingw32'
+host_alias=''
+host_cpu='i686'
+host_os='mingw32'
+host_vendor='pc'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${datarootdir}/info'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localedir='${datarootdir}/locale'
+localstatedir='${prefix}/var'
+mandir='${datarootdir}/man'
+oldincludedir='/usr/include'
+pdfdir='${docdir}'
+prefix='/usr/local'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+sbindir='${exec_prefix}/sbin'
+sharedstatedir='${prefix}/com'
+sysconfdir='${prefix}/etc'
+target_alias=''
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define PACKAGE_NAME ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define PACKAGE_STRING ""
+#define PACKAGE_BUGREPORT ""
+
+configure: exit 0
diff -ruN SDL-1.2.13/test/config.status SDL-1.2.13_OOx64/test/config.status
--- SDL-1.2.13/test/config.status	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/config.status	2013-10-03 19:00:40 +0000
@@ -0,0 +1,774 @@
+#! /bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=${CONFIG_SHELL-/bin/sh}
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in
+  *posix*) set -o posix ;;
+esac
+
+fi
+
+
+
+
+# PATH needs CR
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+as_nl='
+'
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  { (exit 1); exit 1; }
+fi
+
+# Work around bugs in pre-3.0 UWIN ksh.
+for as_var in ENV MAIL MAILPATH
+do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# CDPATH.
+$as_unset CDPATH
+
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line after each line using $LINENO; the second 'sed'
+  # does the real work.  The second script uses 'N' to pair each
+  # line-number line with the line containing $LINENO, and appends
+  # trailing '-' during substitution so that $LINENO is not a special
+  # case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # scripts with optimization help from Paolo Bonzini.  Blame Lee
+  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in
+-n*)
+  case `echo 'x\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  *)   ECHO_C='\c';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir
+fi
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s='ln -s'
+  # ... but there are two gotchas:
+  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+  # In both cases, we have to default to `cp -p'.
+  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+    as_ln_s='cp -p'
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+        test -d "$1/.";
+      else
+	case $1 in
+        -*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+
+# Save the log message, to keep $[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.61.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+# Files that config.status was made for.
+config_files=" Makefile"
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+
+ac_cs_version="\
+config.status
+configured by ./configure, generated by GNU Autoconf 2.61,
+  with options \"'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include'\"
+
+Copyright (C) 2006 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='/c/DriveD/devlibs/SDL-1.2.13/test'
+srcdir='.'
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --he | --h |  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+if $ac_cs_recheck; then
+  echo "running CONFIG_SHELL=/bin/sh /bin/sh ./configure " 'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include' $ac_configure_extra_args " --no-create --no-recursion" >&6
+  CONFIG_SHELL=/bin/sh
+  export CONFIG_SHELL
+  exec /bin/sh "./configure" 'LDFLAGS=-L/mingw/../devlibs/lib' 'CPPFLAGS=-I/mingw/../devlibs/include' $ac_configure_extra_args --no-create --no-recursion
+fi
+
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  echo "$ac_log"
+} >&5
+
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+#
+# Set up the sed scripts for CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+
+cat >"$tmp/subs-1.sed" <<\CEOF
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
+s,@SHELL@,|#_!!_#|/bin/sh,g
+s,@PATH_SEPARATOR@,|#_!!_#|:,g
+s,@PACKAGE_NAME@,|#_!!_#|,g
+s,@PACKAGE_TARNAME@,|#_!!_#|,g
+s,@PACKAGE_VERSION@,|#_!!_#|,g
+s,@PACKAGE_STRING@,|#_!!_#|,g
+s,@PACKAGE_BUGREPORT@,|#_!!_#|,g
+s,@exec_prefix@,|#_!!_#|${prefix},g
+s,@prefix@,|#_!!_#|/usr/local,g
+s,@program_transform_name@,|#_!!_#|s\,x\,x\,,g
+s,@bindir@,|#_!!_#|${exec_prefix}/bin,g
+s,@sbindir@,|#_!!_#|${exec_prefix}/sbin,g
+s,@libexecdir@,|#_!!_#|${exec_prefix}/libexec,g
+s,@datarootdir@,|#_!!_#|${prefix}/share,g
+s,@datadir@,|#_!!_#|${datarootdir},g
+s,@sysconfdir@,|#_!!_#|${prefix}/etc,g
+s,@sharedstatedir@,|#_!!_#|${prefix}/com,g
+s,@localstatedir@,|#_!!_#|${prefix}/var,g
+s,@includedir@,|#_!!_#|${prefix}/include,g
+s,@oldincludedir@,|#_!!_#|/usr/include,g
+s,@docdir@,|#_!!_#|${datarootdir}/doc/${PACKAGE},g
+s,@infodir@,|#_!!_#|${datarootdir}/info,g
+s,@htmldir@,|#_!!_#|${docdir},g
+s,@dvidir@,|#_!!_#|${docdir},g
+s,@pdfdir@,|#_!!_#|${docdir},g
+s,@psdir@,|#_!!_#|${docdir},g
+s,@libdir@,|#_!!_#|${exec_prefix}/lib,g
+s,@localedir@,|#_!!_#|${datarootdir}/locale,g
+s,@mandir@,|#_!!_#|${datarootdir}/man,g
+s,@DEFS@,|#_!!_#|-DPACKAGE_NAME=\\"\\" -DPACKAGE_TARNAME=\\"\\" -DPACKAGE_VERSION=\\"\\" -DPACKAGE_STRING=\\"\\" -DPACKAGE_BUGREPORT=\\"\\",g
+s,@ECHO_C@,|#_!!_#|,g
+s,@ECHO_N@,|#_!!_#|-n,g
+s,@ECHO_T@,|#_!!_#|,g
+s,@LIBS@,|#_!!_#| -L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows,g
+s,@build_alias@,|#_!!_#|,g
+s,@host_alias@,|#_!!_#|,g
+s,@target_alias@,|#_!!_#|,g
+s,@build@,|#_!!_#|i686-pc-mingw32,g
+s,@build_cpu@,|#_!!_#|i686,g
+s,@build_vendor@,|#_!!_#|pc,g
+s,@build_os@,|#_!!_#|mingw32,g
+s,@host@,|#_!!_#|i686-pc-mingw32,g
+s,@host_cpu@,|#_!!_#|i686,g
+s,@host_vendor@,|#_!!_#|pc,g
+s,@host_os@,|#_!!_#|mingw32,g
+s,@CC@,|#_!!_#|gcc,g
+s,@CFLAGS@,|#_!!_#|-g -O2 -I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main -DHAVE_OPENGL,g
+s,@LDFLAGS@,|#_!!_#|-L/mingw/../devlibs/lib,g
+s,@CPPFLAGS@,|#_!!_#|-I/mingw/../devlibs/include,g
+s,@ac_ct_CC@,|#_!!_#|gcc,g
+s,@EXEEXT@,|#_!!_#|.exe,g
+s,@OBJEXT@,|#_!!_#|o,g
+s,@OSMESA_CONFIG@,|#_!!_#|,g
+s,@EXE@,|#_!!_#|.exe,g
+s,@MATHLIB@,|#_!!_#|,g
+s,@SDL_CONFIG@,|#_!!_#|/mingw/../devlibs/bin/sdl-config,g
+s,@SDL_CFLAGS@,|#_!!_#|-I/mingw/../devlibs/include/SDL -D_GNU_SOURCE=1 -Dmain=SDL_main,g
+s,@SDL_LIBS@,|#_!!_#|-L/mingw/../devlibs/lib -lmingw32 -lSDLmain -lSDL -mwindows,g
+s,@XMKMF@,|#_!!_#|,g
+s,@CPP@,|#_!!_#|gcc -E,g
+s,@GLLIB@,|#_!!_#| -lopengl32,g
+s,@LIBOBJS@,|#_!!_#|,g
+s,@LTLIBOBJS@,|#_!!_#|,g
+:end
+s/|#_!!_#|//g
+CEOF
+fi # test -n "$CONFIG_FILES"
+
+
+for ac_tag in  :F $CONFIG_FILES
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
+echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+   { (exit 1); exit 1; }; };;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
+echo "$as_me: error: cannot find input file: $ac_f" >&2;}
+   { (exit 1); exit 1; }; };;
+      esac
+      ac_file_inputs="$ac_file_inputs $ac_f"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input="Generated from "`IFS=:
+	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    fi
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin";;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  { as_dir="$ac_dir"
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
+echo "$as_me: error: cannot create directory $as_dir" >&2;}
+   { (exit 1); exit 1; }; }; }
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+
+case `sed -n '/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p
+' $ac_file_inputs` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  ac_datarootdir_hack='
+  s&@datadir@&${datarootdir}&g
+  s&@docdir@&${datarootdir}/doc/${PACKAGE}&g
+  s&@infodir@&${datarootdir}/info&g
+  s&@localedir@&${datarootdir}/locale&g
+  s&@mandir@&${datarootdir}/man&g
+    s&\${datarootdir}&${prefix}/share&g' ;;
+esac
+  sed "/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}
+
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s&@configure_input@&$configure_input&;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+$ac_datarootdir_hack
+" $ac_file_inputs | sed -f "$tmp/subs-1.sed" >$tmp/out
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out"; rm -f "$tmp/out";;
+  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
+  esac
+ ;;
+
+
+
+  esac
+
+done # for ac_tag
+
+
+{ (exit 0); exit 0; }
Files SDL-1.2.13/test/libiconv-2.dll and SDL-1.2.13_OOx64/test/libiconv-2.dll differ
diff -ruN SDL-1.2.13/test/stderr.txt SDL-1.2.13_OOx64/test/stderr.txt
--- SDL-1.2.13/test/stderr.txt	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/stderr.txt	2013-10-03 19:24:56 +0000
@@ -0,0 +1,10 @@
+Creating Thread 0
+Creating Thread 1
+Creating Thread 2
+Creating Thread 3
+Creating Thread 4
+Creating Thread 5
+Creating Thread 6
+Creating Thread 7
+Creating Thread 8
+Creating Thread 9
diff -ruN SDL-1.2.13/test/stdout.txt SDL-1.2.13_OOx64/test/stdout.txt
--- SDL-1.2.13/test/stdout.txt	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/stdout.txt	2013-10-03 19:24:56 +0000
@@ -0,0 +1,30 @@
+Thread '0' waiting for signal
+Thread '0' sending signals to subthreads
+Thread '8' waiting for signal
+Thread '8' sending signals to subthreads
+Thread '1' waiting for signal
+Thread '1' sending signals to subthreads
+Thread '4' waiting for signal
+Thread '4' sending signals to subthreads
+Thread '5' waiting for signal
+Thread '5' sending signals to subthreads
+Thread '3' waiting for signal
+Thread '3' sending signals to subthreads
+Thread '9' waiting for signal
+Thread '9' sending signals to subthreads
+Thread '6' waiting for signal
+Thread '6' sending signals to subthreads
+Thread '7' waiting for signal
+Thread '7' sending signals to subthreads
+Thread '2' waiting for signal
+Thread '2' sending signals to subthreads
+Thread '0' exiting!
+Thread '4' exiting!
+Thread '2' exiting!
+Thread '1' exiting!
+Thread '9' exiting!
+Thread '6' exiting!
+Thread '8' exiting!
+Thread '3' exiting!
+Thread '5' exiting!
+Thread '7' exiting!
diff -ruN SDL-1.2.13/test/testhaptic.c SDL-1.2.13_OOx64/test/testhaptic.c
--- SDL-1.2.13/test/testhaptic.c	1970-01-01 00:00:00 +0000
+++ SDL-1.2.13_OOx64/test/testhaptic.c	2017-12-18 18:58:48 +0000
@@ -0,0 +1,247 @@
+/*
+Copyright (c) 2008, Edgar Simo Serra
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the name of the Simple Directmedia Layer (SDL) nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+ * includes
+ */
+#include "SDL.h"
+#include "SDL_haptic.h"
+
+#include <stdio.h> /* printf */
+#include <string.h> /* strstr */
+
+
+
+static SDL_Haptic *haptic;
+
+
+/*
+ * prototypes
+ */
+static void abort_execution (void);
+static void HapticPrintSupported( SDL_Haptic * haptic );
+
+
+/**
+ * @brief The entry point of this force feedback demo.
+ * @param[in] argc Number of arguments.
+ * @param[in] argv Array of argc arguments.
+ */
+int main( int argc, char** argv )
+{
+   int i;
+   char *name;
+   SDL_HapticEffect efx[5];
+   int id[5];
+   int nefx;
+   unsigned int supported;
+
+   name = NULL;
+   if (argc > 1) {
+      name = argv[1];
+      if ((strcmp(name,"--help")==0) || (strcmp(name,"-h")==0)) {
+         printf("USAGE: %s [device name]\n"
+                "If device name is specified, it will try to find a device whose name\n"
+                "contains device name for testing.\n", argv[0]);
+         return 0;
+      }
+   }
+
+   /* Initialize the force feedbackness */
+   SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC);
+   printf("%d Haptic devices detected.\n", SDL_NumHaptics());
+   if (SDL_NumHaptics() > 0) {
+      /* We'll just use the first force feedback device found */
+      if (name == NULL) {
+         i = 0;
+      }
+      /* Try to find matching device */
+      else {
+         for (i=0; i<SDL_NumHaptics(); i++) {
+            if (strstr(SDL_HapticName(i), name)!=NULL)
+               break;
+         }
+
+         if (i >= SDL_NumHaptics()) {
+            printf("Unable to find device matching '%s', aborting.\n", name);
+            return 1;
+         }
+      }
+
+      haptic = SDL_HapticOpen(i);
+      if (haptic==NULL) {
+         perror("Unable to create the haptic device");
+         return 1;
+      }
+      printf("Device: %s\n",SDL_HapticName(i));
+      HapticPrintSupported(haptic);
+   }
+   else {
+      printf("No Haptic devices found!\n");
+      return 1;
+   }
+
+   /* We only want force feedback errors. */
+   SDL_ClearError();
+
+   /* Create effects. */
+   memset(&efx,0,sizeof(efx));
+   nefx = 0;
+   supported = SDL_HapticQuery(haptic);
+
+   printf("\nUploading effects\n");
+   /* First we'll try a SINE effect. */
+   if (supported & SDL_HAPTIC_SINE) {
+      printf("   effect %d: Sine Wave\n",nefx);
+      efx[nefx].type = SDL_HAPTIC_SINE;
+      efx[nefx].periodic.period = 1000;
+      efx[nefx].periodic.magnitude = 0x4000;
+      efx[nefx].periodic.length = 5000;
+      efx[nefx].periodic.attack_length = 1000;
+      efx[nefx].periodic.fade_length = 1000;
+      id[nefx] = SDL_HapticNewEffect(haptic,&efx[nefx]);
+      if (id[nefx] < 0) {
+         printf("UPLOADING EFFECT ERROR: %s\n",SDL_GetError());
+         abort_execution();
+      }
+      nefx++;
+   }
+   /* Now we'll try a SAWTOOTHUP */
+   if (supported & SDL_HAPTIC_SAWTOOTHUP) {
+      printf("   effect %d: Sawtooth Up\n",nefx);
+      efx[nefx].type = SDL_HAPTIC_SQUARE;
+      efx[nefx].periodic.period = 500;
+      efx[nefx].periodic.magnitude = 0x5000;
+      efx[nefx].periodic.length = 5000;
+      efx[nefx].periodic.attack_length = 1000;
+      efx[nefx].periodic.fade_length = 1000;
+      id[nefx] = SDL_HapticNewEffect(haptic,&efx[nefx]);
+      if (id[nefx] < 0) {
+         printf("UPLOADING EFFECT ERROR: %s\n",SDL_GetError());
+         abort_execution();
+      }
+      nefx++;
+   }
+   /* Now the classical constant effect. */
+   if (supported & SDL_HAPTIC_CONSTANT) {
+      printf("   effect %d: Constant Force\n",nefx);
+      efx[nefx].type = SDL_HAPTIC_CONSTANT;
+      efx[nefx].constant.direction.type = SDL_HAPTIC_POLAR;
+      efx[nefx].constant.direction.dir[0] = 20000; /* Force comes from the south-west. */
+      efx[nefx].constant.length = 5000;
+      efx[nefx].constant.level = 0x6000;
+      efx[nefx].constant.attack_length = 1000;
+      efx[nefx].constant.fade_length = 1000;
+      id[nefx] = SDL_HapticNewEffect(haptic,&efx[nefx]);
+      if (id[nefx] < 0) {
+         printf("UPLOADING EFFECT ERROR: %s\n",SDL_GetError());
+         abort_execution();
+      }
+      nefx++;
+   }
+   /* The cute spring effect. */
+   if (supported & SDL_HAPTIC_SPRING) {
+      printf("   effect %d: Condition Spring\n",nefx);
+      efx[nefx].type = SDL_HAPTIC_SPRING;
+      efx[nefx].condition.length = 5000;
+      for (i=0; i<SDL_HapticNumAxes(haptic); i++) {
+         efx[nefx].condition.right_sat[i] = 0x7FFF;
+         efx[nefx].condition.left_sat[i] = 0x7FFF;
+         efx[nefx].condition.right_coeff[i] = 0x2000;
+         efx[nefx].condition.left_coeff[i] = 0x2000;
+         efx[nefx].condition.center[i] = 0x1000; /* Displace the center for it to move. */
+      }
+      id[nefx] = SDL_HapticNewEffect(haptic,&efx[nefx]);
+      if (id[nefx] < 0) {
+         printf("UPLOADING EFFECT ERROR: %s\n",SDL_GetError());
+         abort_execution();
+      }
+      nefx++;
+   }
+   /* The pretty awesome inertia effect. */
+   if (supported & SDL_HAPTIC_INERTIA) {
+      printf("   effect %d: Condition Inertia\n",nefx);
+      efx[nefx].type = SDL_HAPTIC_INERTIA;
+      efx[nefx].condition.length = 5000;
+      for (i=0; i<SDL_HapticNumAxes(haptic); i++) {
+         efx[nefx].condition.right_sat[i] = 0x7FFF;
+         efx[nefx].condition.left_sat[i] = 0x7FFF;
+         efx[nefx].condition.right_coeff[i] = 0x2000;
+         efx[nefx].condition.left_coeff[i] = 0x2000;
+      }
+      id[nefx] = SDL_HapticNewEffect(haptic,&efx[nefx]);
+      if (id[nefx] < 0) {
+         printf("UPLOADING EFFECT ERROR: %s\n",SDL_GetError());
+         abort_execution();
+      }
+      nefx++;
+   }
+
+   printf("\nNow playing effects for 5 seconds each with 1 second delay between\n");
+   for (i=0; i<nefx; i++) {
+      printf("   Playing effect %d\n",i);
+      SDL_HapticRunEffect(haptic, id[i], 1);
+      SDL_Delay(6000); /* Effects only have length 5000 */
+   }
+
+   /* Quit */
+   if (haptic != NULL) 
+      SDL_HapticClose(haptic);
+   SDL_Quit();
+
+   return 0;
+}
+
+
+/*
+ * Cleans up a bit.
+ */
+static void abort_execution (void)
+{
+   printf("\nAborting program execution.\n");
+
+   SDL_HapticClose(haptic);
+   SDL_Quit();
+
+   exit(1);
+}
+
+
+/*
+ * Displays information about the haptic device.
+ */
+static void HapticPrintSupported( SDL_Haptic * haptic )
+{
+   unsigned int supported;
+
+   supported = SDL_HapticQuery(haptic);
+   printf("   Supported effects [%d effects, %d playing]:\n",
+         SDL_HapticNumEffects(haptic),
+         SDL_HapticNumEffectsPlaying(haptic));
+   if (supported & SDL_HAPTIC_CONSTANT) printf("      constant\n");
+   if (supported & SDL_HAPTIC_SINE) printf("      sine\n");
+   if (supported & SDL_HAPTIC_SQUARE) printf("      square\n");
+   if (supported & SDL_HAPTIC_TRIANGLE) printf("      triangle\n");
+   if (supported & SDL_HAPTIC_SAWTOOTHUP) printf("      sawtoothup\n");
+   if (supported & SDL_HAPTIC_SAWTOOTHDOWN) printf("      sawtoothdown\n");
+   if (supported & SDL_HAPTIC_RAMP) printf("      ramp\n");
+   if (supported & SDL_HAPTIC_FRICTION) printf("      friction\n");
+   if (supported & SDL_HAPTIC_SPRING) printf("      spring\n");
+   if (supported & SDL_HAPTIC_DAMPER) printf("      damper\n");
+   if (supported & SDL_HAPTIC_INERTIA) printf("      inertia\n");
+   if (supported & SDL_HAPTIC_CUSTOM) printf("      custom\n");
+   printf("   Supported capabilities:\n");
+   if (supported & SDL_HAPTIC_GAIN) printf("      gain\n");
+   if (supported & SDL_HAPTIC_AUTOCENTER) printf("      autocenter\n");
+   if (supported & SDL_HAPTIC_STATUS) printf("      status\n");
+}
\ No newline at end of file
